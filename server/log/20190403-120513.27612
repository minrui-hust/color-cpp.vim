Log file created at: 2019/04/03 12:05:13
Running on machine: mr-pc
Log line format: [IWEF]mmdd hh:mm:ss.uuuuuu threadid file:line] msg
I0403 12:05:13.959125 27612 json_parser.cpp:18] 
[
	1,
	{
		"bufnr" : 3,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#include <fstream>\n\n#include \"common/proto/config/config_map.pb.h\"\n#include \"lidar_map.h\"\n\nnamespace allride {\nnamespace mapping {\n\nMapLayerDictionaryParser LidarMap::map_layer_dict_;\nstd::string LidarMap::database_path_;\nint LidarMap::cache_range_;\nint LidarMap::cache_margin_;\n\nbool LidarMap::configure(const std::string& config_file) {\n  std::ifstream map_config_ifs(config_file);\n  proto::config::ConfigMap map_config;\n  if (!map_config.ParseFromIstream(&map_config_ifs)) {\n    return false;\n  }\n\n  if (!map_layer_dict_.load(map_config.maplayer_dict_path())) {\n    return false;\n  }\n\n  database_path_ = map_config.database_path();\n\n  cache_range_ = map_config.cache_range();\n\n  cache_margin_ = map_config.cache_margin();\n\n  return true;\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map.cpp"
		}
	}
]
I0403 12:05:21.590132 27612 json_parser.cpp:18] 
[
	2,
	{
		"bufnr" : 3,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#include <fstream>\n\n#include \"common/proto/config/config_map.pb.h\"\n#include \"lidar_map.h\"\n\nnamespace allride {\nnamespace mapping {\n\nMapLayerDictionaryParser LidarMap::map_layer_dict_;\nstd::string LidarMap::database_path_;\nint LidarMap::cache_range_;\nint LidarMap::cache_margin_;\n\nbool LidarMap::configure(const std::string& config_file) {\n  std::ifstream map_config_ifs(config_file);\n  proto::config::ConfigMap map_config;\n  if (!map_config.ParseFromIstream(&map_config_ifs)) {\n    return false;\n  }\n\n  if (!map_layer_dict_.load(map_config.maplayer_dict_path())) {\n    return false;\n  }\n\n  database_path_ = map_config.database_path();\n\n  cache_range_ = map_config.cache_range();\n\n  cache_margin_ = map_config.cache_margin();\n\n  return true;\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map.cpp"
		}
	}
]
I0403 12:05:22.417064 27612 json_parser.cpp:18] 
[
	3,
	{
		"bufnr" : 3,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#include <fstream>\n\n#include \"common/proto/config/config_map.pb.h\"\n#include \"lidar_map.h\"\n\nnamespace allride {\nnamespace mapping {\n\nMapLayerDictionaryParser LidarMap::map_layer_dict_;\nstd::string LidarMap::database_path_;\nint LidarMap::cache_range_;\nint LidarMap::cache_margin_;\n\nbool LidarMap::configure(const std::string& config_file) {\n  std::ifstream map_config_ifs(config_file);\n  proto::config::ConfigMap map_config;\n  if (!map_config.ParseFromIstream(&map_config_ifs)) {\n    return false;\n  }\n\n  if (!map_layer_dict_.load(map_config.maplayer_dict_path())) {\n    return false;\n  }\n\n  database_path_ = map_config.database_path();\n\n  cache_range_ = map_config.cache_range();\n\n  cache_margin_ = map_config.cache_margin();\n\n  return true;\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map.cpp"
		}
	}
]
I0403 12:05:22.467144 27612 json_parser.cpp:18] 
[
	4,
	{
		"bufnr" : 5,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/point_types.h\"\n#include \"map_layer_dictionary_parser.h\"\n#include \"ndt3interface.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass LidarMap {\n public:\n  /// @brief configure the LidarMap class, mainly LayerID to resolution map, database path,\n  /// which are shared by all LidarMap and its decents\n  ///\n  /// @param config_file[in] the path to config file\n  ///\n  /// @return true on succeed, else false\n  ///\n  /// @note this should be called first before any operation about LidarMap\n  static bool configure(const std::string& config_file);\n\n  /// @brief initialize a layer before using it\n  ///\n  /// @param layer_id[in] specify which layer to initialize\n  ///\n  /// @return true on succeed, else false\n  virtual bool initializeLayer(int layer_id) = 0;\n\n  /// @brief add point to LidarMap on specific layer\n  ///\n  /// @param layer_id[in] specify which layer to add point cloud\n  /// @param pointcloud[in] the cloud point to add\n  ///\n  /// @return true on succeed, else false\n  virtual bool addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) = 0;\n\n protected:\n  static MapLayerDictionaryParser map_layer_dict_;\n  static std::string database_path_;\n  static int cache_range_;\n  static int cache_margin_;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map.h"
		}
	}
]
I0403 12:05:37.184470 27612 json_parser.cpp:18] 
[
	5,
	{
		"bufnr" : 5,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/point_types.h\"\n#include \"map_layer_dictionary_parser.h\"\n#include \"ndt3interface.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass LidarMap {\n public:\n  /// @brief configure the LidarMap class, mainly LayerID to resolution map, database path,\n  /// which are shared by all LidarMap and its decents\n  ///\n  /// @param config_file[in] the path to config file\n  ///\n  /// @return true on succeed, else false\n  ///\n  /// @note this should be called first before any operation about LidarMap\n  static bool configure(const std::string& config_file);\n\n  /// @brief initialize a layer before using it\n  ///\n  /// @param layer_id[in] specify which layer to initialize\n  ///\n  /// @return true on succeed, else false\n  virtual bool initializeLayer(int layer_id) = 0;\n\n  /// @brief add point to LidarMap on specific layer\n  ///\n  /// @param layer_id[in] specify which layer to add point cloud\n  /// @param pointcloud[in] the cloud point to add\n  ///\n  /// @return true on succeed, else false\n  virtual bool addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) = 0;\n\n protected:\n  static MapLayerDictionaryParser map_layer_dict_;\n  static std::string database_path_;\n  static int cache_range_;\n  static int cache_margin_;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map.h"
		}
	}
]
I0403 12:05:37.306818 27612 json_parser.cpp:18] 
[
	6,
	{
		"bufnr" : 6,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if (!initializeLayer(layer_id)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) {\n  auto iter = layers_.find(layer_id);\n  if (iter != layers_.end()) {\n    return iter->second;\n  } else {\n    return nullptr;\n  }\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(const std::string& type_name,\n                                                          float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return nullptr;\n  }\n  return getLayer(layer_id);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0403 12:05:44.382153 27612 json_parser.cpp:18] 
[
	7,
	{
		"bufnr" : 6,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if (!initializeLayer(layer_id)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) {\n  auto iter = layers_.find(layer_id);\n  if (iter != layers_.end()) {\n    return iter->second;\n  } else {\n    return nullptr;\n  }\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(const std::string& type_name,\n                                                          float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return nullptr;\n  }\n  return getLayer(layer_id);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0403 12:05:44.505388 27612 json_parser.cpp:18] 
[
	8,
	{
		"bufnr" : 7,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_online.h\"\n\nnamespace allride {\nnamespace mapping {\n\nvoid LidarMapOnline::setMapOrigin(const common::geometry::SE3& Tx_MP_map) { origin_ = Tx_MP_map; }\n\ncommon::geometry::SE3 LidarMapOnline::getMapOrigin() { return origin_; }\n\nvoid LidarMapOnline::resetMapRegion(const common::geometry::SE3& Tx_MP_V, double radius) {\n  common::geometry::SE3 Tx_delta /* = origin_.inverseCompose(Tx_MP_V) */;  // waiting for api\n\n  // first get all keys\n  std::vector<int> all_layer_ids;\n  for (const auto& pair : ndt3_pool_) {\n    all_layer_ids.emplace_back(pair.first);\n  }\n\n  // update ndt3 data of all layers\n  for (const auto& layer_id : all_layer_ids) {\n    std::shared_ptr<Ndt3Tile> new_ndt3 =\n        std::shared_ptr<Ndt3Tile>(new Ndt3Tile(map_layer_dict_.getGridSize(layer_id)));\n    ndt3_pool_[layer_id]->copyAndTransform(Tx_delta, radius, new_ndt3.get());\n    ndt3_pool_[layer_id] = new_ndt3;\n  }\n}\n\nbool LidarMapOnline::initializeLayer(int layer_id) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it != ndt3_pool_.end()) {\n    return false;  // re-initialize\n  }\n\n  float grid_size;\n  if (!map_layer_dict_.getInfoById(layer_id, nullptr, &grid_size, nullptr)) {\n    return false;\n  }\n\n  ndt3_pool_[layer_id] = std::shared_ptr<Ndt3Tile>(new Ndt3Tile(grid_size));\n\n  return true;\n}\n\nbool LidarMapOnline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  // add sample to ndt3\n  for (const auto& sample : pointcloud) {\n    ndt3_pool_it->second->addSample(sample);\n  }\n\n  return false;\n}\n\nbool LidarMapOnline::getMap(int layer_id, std::shared_ptr<Ndt3Interface>* ndt3) {\n  if (!ndt3) {\n    return false;\n  }\n\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  *ndt3 = ndt3_pool_it->second;\n  return true;\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp"
		}
	}
]
I0403 12:05:48.801156 27612 json_parser.cpp:18] 
[
	9,
	{
		"bufnr" : 8,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/geometry/se3.h\"\n#include \"common/math/point_types.h\"\n\n#include \"lidar_map.h\"\n#include \"ndt3tile.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass LidarMapOnline : public LidarMap {\n public:\n  /// @brief set pose(relative to global map) of the local map\n  ///\n  /// @param[in] Tx_MP_map is the origin to be set\n  void setMapOrigin(const common::geometry::SE3& Tx_MP_map);\n\n  /// @brief get pose(relative to global map) of the local map\n  ///\n  /// @return the origin of the local map\n  common::geometry::SE3 getMapOrigin();\n\n  /// @brief reset the local map to a new region\n  ///\n  /// @param[in] Tx_MP_V is the region center\n  ///\n  /// @param[in] radius is the region radius\n  void resetMapRegion(const common::geometry::SE3& Tx_MP_V, double radius);\n\n  /// @brief implemention of LidarMap::initializeLayer\n  ///\n  /// @see LidarMap for more infomation\n  bool initializeLayer(int layer_id) override;\n\n  /// @brief implemention of LidarMap::addPointCloud\n  ///\n  /// @see LidarMap for more infomation\n  bool addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) override;\n\n  /// @brief get map of specific layer\n  ///\n  /// @param layer_id[in] specify which layer to get\n  /// @param ndt3[out] store the got map data\n  ///\n  /// @return true on succeed, else false\n  bool getMap(int layer_id, std::shared_ptr<Ndt3Interface>* ndt3);\n\n private:\n  std::map<int, std::shared_ptr<Ndt3Tile>> ndt3_pool_;\n  common::geometry::SE3 origin_;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.h"
		}
	}
]
I0403 12:05:57.378703 27612 json_parser.cpp:18] 
[
	10,
	{
		"bufnr" : 8,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/geometry/se3.h\"\n#include \"common/math/point_types.h\"\n\n#include \"lidar_map.h\"\n#include \"ndt3tile.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass LidarMapOnline : public LidarMap {\n public:\n  /// @brief set pose(relative to global map) of the local map\n  ///\n  /// @param[in] Tx_MP_map is the origin to be set\n  void setMapOrigin(const common::geometry::SE3& Tx_MP_map);\n\n  /// @brief get pose(relative to global map) of the local map\n  ///\n  /// @return the origin of the local map\n  common::geometry::SE3 getMapOrigin();\n\n  /// @brief reset the local map to a new region\n  ///\n  /// @param[in] Tx_MP_V is the region center\n  ///\n  /// @param[in] radius is the region radius\n  void resetMapRegion(const common::geometry::SE3& Tx_MP_V, double radius);\n\n  /// @brief implemention of LidarMap::initializeLayer\n  ///\n  /// @see LidarMap for more infomation\n  bool initializeLayer(int layer_id) override;\n\n  /// @brief implemention of LidarMap::addPointCloud\n  ///\n  /// @see LidarMap for more infomation\n  bool addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) override;\n\n  /// @brief get map of specific layer\n  ///\n  /// @param layer_id[in] specify which layer to get\n  /// @param ndt3[out] store the got map data\n  ///\n  /// @return true on succeed, else false\n  bool getMap(int layer_id, std::shared_ptr<Ndt3Interface>* ndt3);\n\n private:\n  std::map<int, std::shared_ptr<Ndt3Tile>> ndt3_pool_;\n  common::geometry::SE3 origin_;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.h"
		}
	}
]
I0403 12:05:57.467869 27612 json_parser.cpp:18] 
[
	11,
	{
		"bufnr" : 9,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/map_layer.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#include <future>\n\n#include \"lidar_map_offline.h\"\n#include \"map_layer.h\"\n#include \"ndt3tile.h\"\n#include \"ndt3tile_multi.h\"\n#include \"tile_scope.h\"\n\nnamespace allride {\nnamespace mapping {\n\nbool MapLayer::initialize(const proto::map::MapLayerInfo& layer_info,\n                          const std::shared_ptr<LocalDatabase>& database) {\n  tile_client_ = std::shared_ptr<TileClient>(new TileClient(layer_info.layer_id(), database));\n  if (!tile_client_) {\n    return false;\n  }\n\n  tile_cache_ = std::unique_ptr<TileCache>(new TileCache(\n      LidarMapOffline::getCacheRange(), LidarMapOffline::getCacheMargin(), tile_client_));\n  if (!tile_cache_) {\n    return false;\n  }\n\n  tiler_ = std::unique_ptr<Tiler>(new Tiler(layer_info.tile_size()));\n  if (!tiler_) {\n    return false;\n  }\n\n  layer_info_.CopyFrom(layer_info);\n\n  initialized_ = true;\n\n  return true;\n}\n\nbool MapLayer::load(const Eigen::Vector3f& pos) {\n  if (!initialized_) {\n    return false;\n  }\n\n  return tile_cache_->load(tiler_->getTileID(pos));\n}\n\nbool MapLayer::getMap(const MapScope& scope, bool blocking, std::shared_ptr<Ndt3Interface>* ndt3) {\n  if (!initialized_) {\n    return false;\n  }\n\n  if (nullptr == ndt3) {\n    return false;\n  }\n\n  bool ret;\n  std::shared_ptr<TileCache::TileStorageHash> tiles;\n  ret = tile_cache_->getTiles(TileScope(scope, layer_info_.tile_size()), blocking, &tiles);\n\n  // what we got in tiles is a map of TileStorageData, need to transform to Ndt3Tile\n  std::shared_ptr<Ndt3TileMulti::Ndt3Hash> ndt3_tiles =\n      std::shared_ptr<Ndt3TileMulti::Ndt3Hash>(new Ndt3TileMulti::Ndt3Hash);\n  for (const auto& id_and_tile : *tiles) {\n    ndt3_tiles->insert(std::make_pair(\n        id_and_tile.first,\n        std::shared_ptr<Ndt3Tile>(new Ndt3Tile(layer_info_.grid_size(), id_and_tile.second))));\n  }\n\n  *ndt3 = std::shared_ptr<Ndt3TileMulti>(new Ndt3TileMulti(ndt3_tiles, layer_info_.tile_size()));\n\n  return ret;\n}\n\nbool MapLayer::addPointCloud(const common::PointCloudXYZI& pointcloud) {\n  if (!initialized_) {\n    return false;\n  }\n\n  for (const auto& sample : pointcloud) {\n    Tiler::TileID tile_id = tiler_->getTileID(Eigen::Vector3f(sample.x, sample.y, sample.z));\n    auto it = tile_pool_.find(tile_id);\n    std::shared_ptr<Ndt3Tile> tile;\n    if (tile_pool_.end() == it) {\n      tile = std::shared_ptr<Ndt3Tile>(new Ndt3Tile(layer_info_.grid_size()));\n      tile_pool_[tile_id] = tile;\n    } else {\n      tile = it->second;\n    }\n\n    tile->addSample(sample);\n  }\n\n  return true;\n}\n\nbool MapLayer::save() {\n  if (!initialized_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (const auto& pair : tile_pool_) {\n    pair.second->computeAllNormalsAndEigenvalues(0.02);\n    ret &= tile_client_->put(pair.first, pair.second->getStorage());\n  }\n\n  return ret;\n}\n\nconst Ndt3TileMulti::Ndt3Hash& MapLayer::getAllNdt3() { return tile_pool_; }\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/map_layer.cpp"
		}
	}
]
I0403 12:06:03.987912 27612 json_parser.cpp:18] 
[
	12,
	{
		"bufnr" : 9,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/map_layer.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#include <future>\n\n#include \"lidar_map_offline.h\"\n#include \"map_layer.h\"\n#include \"ndt3tile.h\"\n#include \"ndt3tile_multi.h\"\n#include \"tile_scope.h\"\n\nnamespace allride {\nnamespace mapping {\n\nbool MapLayer::initialize(const proto::map::MapLayerInfo& layer_info,\n                          const std::shared_ptr<LocalDatabase>& database) {\n  tile_client_ = std::shared_ptr<TileClient>(new TileClient(layer_info.layer_id(), database));\n  if (!tile_client_) {\n    return false;\n  }\n\n  tile_cache_ = std::unique_ptr<TileCache>(new TileCache(\n      LidarMapOffline::getCacheRange(), LidarMapOffline::getCacheMargin(), tile_client_));\n  if (!tile_cache_) {\n    return false;\n  }\n\n  tiler_ = std::unique_ptr<Tiler>(new Tiler(layer_info.tile_size()));\n  if (!tiler_) {\n    return false;\n  }\n\n  layer_info_.CopyFrom(layer_info);\n\n  initialized_ = true;\n\n  return true;\n}\n\nbool MapLayer::load(const Eigen::Vector3f& pos) {\n  if (!initialized_) {\n    return false;\n  }\n\n  return tile_cache_->load(tiler_->getTileID(pos));\n}\n\nbool MapLayer::getMap(const MapScope& scope, bool blocking, std::shared_ptr<Ndt3Interface>* ndt3) {\n  if (!initialized_) {\n    return false;\n  }\n\n  if (nullptr == ndt3) {\n    return false;\n  }\n\n  bool ret;\n  std::shared_ptr<TileCache::TileStorageHash> tiles;\n  ret = tile_cache_->getTiles(TileScope(scope, layer_info_.tile_size()), blocking, &tiles);\n\n  // what we got in tiles is a map of TileStorageData, need to transform to Ndt3Tile\n  std::shared_ptr<Ndt3TileMulti::Ndt3Hash> ndt3_tiles =\n      std::shared_ptr<Ndt3TileMulti::Ndt3Hash>(new Ndt3TileMulti::Ndt3Hash);\n  for (const auto& id_and_tile : *tiles) {\n    ndt3_tiles->insert(std::make_pair(\n        id_and_tile.first,\n        std::shared_ptr<Ndt3Tile>(new Ndt3Tile(layer_info_.grid_size(), id_and_tile.second))));\n  }\n\n  *ndt3 = std::shared_ptr<Ndt3TileMulti>(new Ndt3TileMulti(ndt3_tiles, layer_info_.tile_size()));\n\n  return ret;\n}\n\nbool MapLayer::addPointCloud(const common::PointCloudXYZI& pointcloud) {\n  if (!initialized_) {\n    return false;\n  }\n\n  for (const auto& sample : pointcloud) {\n    Tiler::TileID tile_id = tiler_->getTileID(Eigen::Vector3f(sample.x, sample.y, sample.z));\n    auto it = tile_pool_.find(tile_id);\n    std::shared_ptr<Ndt3Tile> tile;\n    if (tile_pool_.end() == it) {\n      tile = std::shared_ptr<Ndt3Tile>(new Ndt3Tile(layer_info_.grid_size()));\n      tile_pool_[tile_id] = tile;\n    } else {\n      tile = it->second;\n    }\n\n    tile->addSample(sample);\n  }\n\n  return true;\n}\n\nbool MapLayer::save() {\n  if (!initialized_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (const auto& pair : tile_pool_) {\n    pair.second->computeAllNormalsAndEigenvalues(0.02);\n    ret &= tile_client_->put(pair.first, pair.second->getStorage());\n  }\n\n  return ret;\n}\n\nconst Ndt3TileMulti::Ndt3Hash& MapLayer::getAllNdt3() { return tile_pool_; }\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/map_layer.cpp"
		}
	}
]
I0403 12:06:04.077499 27612 json_parser.cpp:18] 
[
	13,
	{
		"bufnr" : 8,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/geometry/se3.h\"\n#include \"common/math/point_types.h\"\n\n#include \"lidar_map.h\"\n#include \"ndt3tile.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass LidarMapOnline : public LidarMap {\n public:\n  /// @brief set pose(relative to global map) of the local map\n  ///\n  /// @param[in] Tx_MP_map is the origin to be set\n  void setMapOrigin(const common::geometry::SE3& Tx_MP_map);\n\n  /// @brief get pose(relative to global map) of the local map\n  ///\n  /// @return the origin of the local map\n  common::geometry::SE3 getMapOrigin();\n\n  /// @brief reset the local map to a new region\n  ///\n  /// @param[in] Tx_MP_V is the region center\n  ///\n  /// @param[in] radius is the region radius\n  void resetMapRegion(const common::geometry::SE3& Tx_MP_V, double radius);\n\n  /// @brief implemention of LidarMap::initializeLayer\n  ///\n  /// @see LidarMap for more infomation\n  bool initializeLayer(int layer_id) override;\n\n  /// @brief implemention of LidarMap::addPointCloud\n  ///\n  /// @see LidarMap for more infomation\n  bool addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) override;\n\n  /// @brief get map of specific layer\n  ///\n  /// @param layer_id[in] specify which layer to get\n  /// @param ndt3[out] store the got map data\n  ///\n  /// @return true on succeed, else false\n  bool getMap(int layer_id, std::shared_ptr<Ndt3Interface>* ndt3);\n\n private:\n  std::map<int, std::shared_ptr<Ndt3Tile>> ndt3_pool_;\n  common::geometry::SE3 origin_;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.h"
		}
	}
]
I0403 12:06:05.662529 27612 json_parser.cpp:18] 
[
	14,
	{
		"bufnr" : 8,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/geometry/se3.h\"\n#include \"common/math/point_types.h\"\n\n#include \"lidar_map.h\"\n#include \"ndt3tile.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass LidarMapOnline : public LidarMap {\n public:\n  /// @brief set pose(relative to global map) of the local map\n  ///\n  /// @param[in] Tx_MP_map is the origin to be set\n  void setMapOrigin(const common::geometry::SE3& Tx_MP_map);\n\n  /// @brief get pose(relative to global map) of the local map\n  ///\n  /// @return the origin of the local map\n  common::geometry::SE3 getMapOrigin();\n\n  /// @brief reset the local map to a new region\n  ///\n  /// @param[in] Tx_MP_V is the region center\n  ///\n  /// @param[in] radius is the region radius\n  void resetMapRegion(const common::geometry::SE3& Tx_MP_V, double radius);\n\n  /// @brief implemention of LidarMap::initializeLayer\n  ///\n  /// @see LidarMap for more infomation\n  bool initializeLayer(int layer_id) override;\n\n  /// @brief implemention of LidarMap::addPointCloud\n  ///\n  /// @see LidarMap for more infomation\n  bool addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) override;\n\n  /// @brief get map of specific layer\n  ///\n  /// @param layer_id[in] specify which layer to get\n  /// @param ndt3[out] store the got map data\n  ///\n  /// @return true on succeed, else false\n  bool getMap(int layer_id, std::shared_ptr<Ndt3Interface>* ndt3);\n\n private:\n  std::map<int, std::shared_ptr<Ndt3Tile>> ndt3_pool_;\n  common::geometry::SE3 origin_;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.h"
		}
	}
]
I0403 12:06:05.707662 27612 json_parser.cpp:18] 
[
	15,
	{
		"bufnr" : 9,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/map_layer.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#include <future>\n\n#include \"lidar_map_offline.h\"\n#include \"map_layer.h\"\n#include \"ndt3tile.h\"\n#include \"ndt3tile_multi.h\"\n#include \"tile_scope.h\"\n\nnamespace allride {\nnamespace mapping {\n\nbool MapLayer::initialize(const proto::map::MapLayerInfo& layer_info,\n                          const std::shared_ptr<LocalDatabase>& database) {\n  tile_client_ = std::shared_ptr<TileClient>(new TileClient(layer_info.layer_id(), database));\n  if (!tile_client_) {\n    return false;\n  }\n\n  tile_cache_ = std::unique_ptr<TileCache>(new TileCache(\n      LidarMapOffline::getCacheRange(), LidarMapOffline::getCacheMargin(), tile_client_));\n  if (!tile_cache_) {\n    return false;\n  }\n\n  tiler_ = std::unique_ptr<Tiler>(new Tiler(layer_info.tile_size()));\n  if (!tiler_) {\n    return false;\n  }\n\n  layer_info_.CopyFrom(layer_info);\n\n  initialized_ = true;\n\n  return true;\n}\n\nbool MapLayer::load(const Eigen::Vector3f& pos) {\n  if (!initialized_) {\n    return false;\n  }\n\n  return tile_cache_->load(tiler_->getTileID(pos));\n}\n\nbool MapLayer::getMap(const MapScope& scope, bool blocking, std::shared_ptr<Ndt3Interface>* ndt3) {\n  if (!initialized_) {\n    return false;\n  }\n\n  if (nullptr == ndt3) {\n    return false;\n  }\n\n  bool ret;\n  std::shared_ptr<TileCache::TileStorageHash> tiles;\n  ret = tile_cache_->getTiles(TileScope(scope, layer_info_.tile_size()), blocking, &tiles);\n\n  // what we got in tiles is a map of TileStorageData, need to transform to Ndt3Tile\n  std::shared_ptr<Ndt3TileMulti::Ndt3Hash> ndt3_tiles =\n      std::shared_ptr<Ndt3TileMulti::Ndt3Hash>(new Ndt3TileMulti::Ndt3Hash);\n  for (const auto& id_and_tile : *tiles) {\n    ndt3_tiles->insert(std::make_pair(\n        id_and_tile.first,\n        std::shared_ptr<Ndt3Tile>(new Ndt3Tile(layer_info_.grid_size(), id_and_tile.second))));\n  }\n\n  *ndt3 = std::shared_ptr<Ndt3TileMulti>(new Ndt3TileMulti(ndt3_tiles, layer_info_.tile_size()));\n\n  return ret;\n}\n\nbool MapLayer::addPointCloud(const common::PointCloudXYZI& pointcloud) {\n  if (!initialized_) {\n    return false;\n  }\n\n  for (const auto& sample : pointcloud) {\n    Tiler::TileID tile_id = tiler_->getTileID(Eigen::Vector3f(sample.x, sample.y, sample.z));\n    auto it = tile_pool_.find(tile_id);\n    std::shared_ptr<Ndt3Tile> tile;\n    if (tile_pool_.end() == it) {\n      tile = std::shared_ptr<Ndt3Tile>(new Ndt3Tile(layer_info_.grid_size()));\n      tile_pool_[tile_id] = tile;\n    } else {\n      tile = it->second;\n    }\n\n    tile->addSample(sample);\n  }\n\n  return true;\n}\n\nbool MapLayer::save() {\n  if (!initialized_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (const auto& pair : tile_pool_) {\n    pair.second->computeAllNormalsAndEigenvalues(0.02);\n    ret &= tile_client_->put(pair.first, pair.second->getStorage());\n  }\n\n  return ret;\n}\n\nconst Ndt3TileMulti::Ndt3Hash& MapLayer::getAllNdt3() { return tile_pool_; }\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/map_layer.cpp"
		}
	}
]
I0403 12:06:07.079382 27612 json_parser.cpp:18] 
[
	16,
	{
		"bufnr" : 9,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/map_layer.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#include <future>\n\n#include \"lidar_map_offline.h\"\n#include \"map_layer.h\"\n#include \"ndt3tile.h\"\n#include \"ndt3tile_multi.h\"\n#include \"tile_scope.h\"\n\nnamespace allride {\nnamespace mapping {\n\nbool MapLayer::initialize(const proto::map::MapLayerInfo& layer_info,\n                          const std::shared_ptr<LocalDatabase>& database) {\n  tile_client_ = std::shared_ptr<TileClient>(new TileClient(layer_info.layer_id(), database));\n  if (!tile_client_) {\n    return false;\n  }\n\n  tile_cache_ = std::unique_ptr<TileCache>(new TileCache(\n      LidarMapOffline::getCacheRange(), LidarMapOffline::getCacheMargin(), tile_client_));\n  if (!tile_cache_) {\n    return false;\n  }\n\n  tiler_ = std::unique_ptr<Tiler>(new Tiler(layer_info.tile_size()));\n  if (!tiler_) {\n    return false;\n  }\n\n  layer_info_.CopyFrom(layer_info);\n\n  initialized_ = true;\n\n  return true;\n}\n\nbool MapLayer::load(const Eigen::Vector3f& pos) {\n  if (!initialized_) {\n    return false;\n  }\n\n  return tile_cache_->load(tiler_->getTileID(pos));\n}\n\nbool MapLayer::getMap(const MapScope& scope, bool blocking, std::shared_ptr<Ndt3Interface>* ndt3) {\n  if (!initialized_) {\n    return false;\n  }\n\n  if (nullptr == ndt3) {\n    return false;\n  }\n\n  bool ret;\n  std::shared_ptr<TileCache::TileStorageHash> tiles;\n  ret = tile_cache_->getTiles(TileScope(scope, layer_info_.tile_size()), blocking, &tiles);\n\n  // what we got in tiles is a map of TileStorageData, need to transform to Ndt3Tile\n  std::shared_ptr<Ndt3TileMulti::Ndt3Hash> ndt3_tiles =\n      std::shared_ptr<Ndt3TileMulti::Ndt3Hash>(new Ndt3TileMulti::Ndt3Hash);\n  for (const auto& id_and_tile : *tiles) {\n    ndt3_tiles->insert(std::make_pair(\n        id_and_tile.first,\n        std::shared_ptr<Ndt3Tile>(new Ndt3Tile(layer_info_.grid_size(), id_and_tile.second))));\n  }\n\n  *ndt3 = std::shared_ptr<Ndt3TileMulti>(new Ndt3TileMulti(ndt3_tiles, layer_info_.tile_size()));\n\n  return ret;\n}\n\nbool MapLayer::addPointCloud(const common::PointCloudXYZI& pointcloud) {\n  if (!initialized_) {\n    return false;\n  }\n\n  for (const auto& sample : pointcloud) {\n    Tiler::TileID tile_id = tiler_->getTileID(Eigen::Vector3f(sample.x, sample.y, sample.z));\n    auto it = tile_pool_.find(tile_id);\n    std::shared_ptr<Ndt3Tile> tile;\n    if (tile_pool_.end() == it) {\n      tile = std::shared_ptr<Ndt3Tile>(new Ndt3Tile(layer_info_.grid_size()));\n      tile_pool_[tile_id] = tile;\n    } else {\n      tile = it->second;\n    }\n\n    tile->addSample(sample);\n  }\n\n  return true;\n}\n\nbool MapLayer::save() {\n  if (!initialized_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (const auto& pair : tile_pool_) {\n    pair.second->computeAllNormalsAndEigenvalues(0.02);\n    ret &= tile_client_->put(pair.first, pair.second->getStorage());\n  }\n\n  return ret;\n}\n\nconst Ndt3TileMulti::Ndt3Hash& MapLayer::getAllNdt3() { return tile_pool_; }\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/map_layer.cpp"
		}
	}
]
I0403 12:06:07.171990 27612 json_parser.cpp:18] 
[
	17,
	{
		"bufnr" : 8,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/geometry/se3.h\"\n#include \"common/math/point_types.h\"\n\n#include \"lidar_map.h\"\n#include \"ndt3tile.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass LidarMapOnline : public LidarMap {\n public:\n  /// @brief set pose(relative to global map) of the local map\n  ///\n  /// @param[in] Tx_MP_map is the origin to be set\n  void setMapOrigin(const common::geometry::SE3& Tx_MP_map);\n\n  /// @brief get pose(relative to global map) of the local map\n  ///\n  /// @return the origin of the local map\n  common::geometry::SE3 getMapOrigin();\n\n  /// @brief reset the local map to a new region\n  ///\n  /// @param[in] Tx_MP_V is the region center\n  ///\n  /// @param[in] radius is the region radius\n  void resetMapRegion(const common::geometry::SE3& Tx_MP_V, double radius);\n\n  /// @brief implemention of LidarMap::initializeLayer\n  ///\n  /// @see LidarMap for more infomation\n  bool initializeLayer(int layer_id) override;\n\n  /// @brief implemention of LidarMap::addPointCloud\n  ///\n  /// @see LidarMap for more infomation\n  bool addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) override;\n\n  /// @brief get map of specific layer\n  ///\n  /// @param layer_id[in] specify which layer to get\n  /// @param ndt3[out] store the got map data\n  ///\n  /// @return true on succeed, else false\n  bool getMap(int layer_id, std::shared_ptr<Ndt3Interface>* ndt3);\n\n private:\n  std::map<int, std::shared_ptr<Ndt3Tile>> ndt3_pool_;\n  common::geometry::SE3 origin_;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.h"
		}
	}
]
I0403 12:06:08.450124 27612 json_parser.cpp:18] 
[
	18,
	{
		"bufnr" : 8,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/geometry/se3.h\"\n#include \"common/math/point_types.h\"\n\n#include \"lidar_map.h\"\n#include \"ndt3tile.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass LidarMapOnline : public LidarMap {\n public:\n  /// @brief set pose(relative to global map) of the local map\n  ///\n  /// @param[in] Tx_MP_map is the origin to be set\n  void setMapOrigin(const common::geometry::SE3& Tx_MP_map);\n\n  /// @brief get pose(relative to global map) of the local map\n  ///\n  /// @return the origin of the local map\n  common::geometry::SE3 getMapOrigin();\n\n  /// @brief reset the local map to a new region\n  ///\n  /// @param[in] Tx_MP_V is the region center\n  ///\n  /// @param[in] radius is the region radius\n  void resetMapRegion(const common::geometry::SE3& Tx_MP_V, double radius);\n\n  /// @brief implemention of LidarMap::initializeLayer\n  ///\n  /// @see LidarMap for more infomation\n  bool initializeLayer(int layer_id) override;\n\n  /// @brief implemention of LidarMap::addPointCloud\n  ///\n  /// @see LidarMap for more infomation\n  bool addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) override;\n\n  /// @brief get map of specific layer\n  ///\n  /// @param layer_id[in] specify which layer to get\n  /// @param ndt3[out] store the got map data\n  ///\n  /// @return true on succeed, else false\n  bool getMap(int layer_id, std::shared_ptr<Ndt3Interface>* ndt3);\n\n private:\n  std::map<int, std::shared_ptr<Ndt3Tile>> ndt3_pool_;\n  common::geometry::SE3 origin_;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.h"
		}
	}
]
I0403 12:06:08.495717 27612 json_parser.cpp:18] 
[
	19,
	{
		"bufnr" : 9,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/map_layer.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#include <future>\n\n#include \"lidar_map_offline.h\"\n#include \"map_layer.h\"\n#include \"ndt3tile.h\"\n#include \"ndt3tile_multi.h\"\n#include \"tile_scope.h\"\n\nnamespace allride {\nnamespace mapping {\n\nbool MapLayer::initialize(const proto::map::MapLayerInfo& layer_info,\n                          const std::shared_ptr<LocalDatabase>& database) {\n  tile_client_ = std::shared_ptr<TileClient>(new TileClient(layer_info.layer_id(), database));\n  if (!tile_client_) {\n    return false;\n  }\n\n  tile_cache_ = std::unique_ptr<TileCache>(new TileCache(\n      LidarMapOffline::getCacheRange(), LidarMapOffline::getCacheMargin(), tile_client_));\n  if (!tile_cache_) {\n    return false;\n  }\n\n  tiler_ = std::unique_ptr<Tiler>(new Tiler(layer_info.tile_size()));\n  if (!tiler_) {\n    return false;\n  }\n\n  layer_info_.CopyFrom(layer_info);\n\n  initialized_ = true;\n\n  return true;\n}\n\nbool MapLayer::load(const Eigen::Vector3f& pos) {\n  if (!initialized_) {\n    return false;\n  }\n\n  return tile_cache_->load(tiler_->getTileID(pos));\n}\n\nbool MapLayer::getMap(const MapScope& scope, bool blocking, std::shared_ptr<Ndt3Interface>* ndt3) {\n  if (!initialized_) {\n    return false;\n  }\n\n  if (nullptr == ndt3) {\n    return false;\n  }\n\n  bool ret;\n  std::shared_ptr<TileCache::TileStorageHash> tiles;\n  ret = tile_cache_->getTiles(TileScope(scope, layer_info_.tile_size()), blocking, &tiles);\n\n  // what we got in tiles is a map of TileStorageData, need to transform to Ndt3Tile\n  std::shared_ptr<Ndt3TileMulti::Ndt3Hash> ndt3_tiles =\n      std::shared_ptr<Ndt3TileMulti::Ndt3Hash>(new Ndt3TileMulti::Ndt3Hash);\n  for (const auto& id_and_tile : *tiles) {\n    ndt3_tiles->insert(std::make_pair(\n        id_and_tile.first,\n        std::shared_ptr<Ndt3Tile>(new Ndt3Tile(layer_info_.grid_size(), id_and_tile.second))));\n  }\n\n  *ndt3 = std::shared_ptr<Ndt3TileMulti>(new Ndt3TileMulti(ndt3_tiles, layer_info_.tile_size()));\n\n  return ret;\n}\n\nbool MapLayer::addPointCloud(const common::PointCloudXYZI& pointcloud) {\n  if (!initialized_) {\n    return false;\n  }\n\n  for (const auto& sample : pointcloud) {\n    Tiler::TileID tile_id = tiler_->getTileID(Eigen::Vector3f(sample.x, sample.y, sample.z));\n    auto it = tile_pool_.find(tile_id);\n    std::shared_ptr<Ndt3Tile> tile;\n    if (tile_pool_.end() == it) {\n      tile = std::shared_ptr<Ndt3Tile>(new Ndt3Tile(layer_info_.grid_size()));\n      tile_pool_[tile_id] = tile;\n    } else {\n      tile = it->second;\n    }\n\n    tile->addSample(sample);\n  }\n\n  return true;\n}\n\nbool MapLayer::save() {\n  if (!initialized_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (const auto& pair : tile_pool_) {\n    pair.second->computeAllNormalsAndEigenvalues(0.02);\n    ret &= tile_client_->put(pair.first, pair.second->getStorage());\n  }\n\n  return ret;\n}\n\nconst Ndt3TileMulti::Ndt3Hash& MapLayer::getAllNdt3() { return tile_pool_; }\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/map_layer.cpp"
		}
	}
]
I0403 12:06:10.019412 27612 json_parser.cpp:18] 
[
	20,
	{
		"bufnr" : 9,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/map_layer.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#include <future>\n\n#include \"lidar_map_offline.h\"\n#include \"map_layer.h\"\n#include \"ndt3tile.h\"\n#include \"ndt3tile_multi.h\"\n#include \"tile_scope.h\"\n\nnamespace allride {\nnamespace mapping {\n\nbool MapLayer::initialize(const proto::map::MapLayerInfo& layer_info,\n                          const std::shared_ptr<LocalDatabase>& database) {\n  tile_client_ = std::shared_ptr<TileClient>(new TileClient(layer_info.layer_id(), database));\n  if (!tile_client_) {\n    return false;\n  }\n\n  tile_cache_ = std::unique_ptr<TileCache>(new TileCache(\n      LidarMapOffline::getCacheRange(), LidarMapOffline::getCacheMargin(), tile_client_));\n  if (!tile_cache_) {\n    return false;\n  }\n\n  tiler_ = std::unique_ptr<Tiler>(new Tiler(layer_info.tile_size()));\n  if (!tiler_) {\n    return false;\n  }\n\n  layer_info_.CopyFrom(layer_info);\n\n  initialized_ = true;\n\n  return true;\n}\n\nbool MapLayer::load(const Eigen::Vector3f& pos) {\n  if (!initialized_) {\n    return false;\n  }\n\n  return tile_cache_->load(tiler_->getTileID(pos));\n}\n\nbool MapLayer::getMap(const MapScope& scope, bool blocking, std::shared_ptr<Ndt3Interface>* ndt3) {\n  if (!initialized_) {\n    return false;\n  }\n\n  if (nullptr == ndt3) {\n    return false;\n  }\n\n  bool ret;\n  std::shared_ptr<TileCache::TileStorageHash> tiles;\n  ret = tile_cache_->getTiles(TileScope(scope, layer_info_.tile_size()), blocking, &tiles);\n\n  // what we got in tiles is a map of TileStorageData, need to transform to Ndt3Tile\n  std::shared_ptr<Ndt3TileMulti::Ndt3Hash> ndt3_tiles =\n      std::shared_ptr<Ndt3TileMulti::Ndt3Hash>(new Ndt3TileMulti::Ndt3Hash);\n  for (const auto& id_and_tile : *tiles) {\n    ndt3_tiles->insert(std::make_pair(\n        id_and_tile.first,\n        std::shared_ptr<Ndt3Tile>(new Ndt3Tile(layer_info_.grid_size(), id_and_tile.second))));\n  }\n\n  *ndt3 = std::shared_ptr<Ndt3TileMulti>(new Ndt3TileMulti(ndt3_tiles, layer_info_.tile_size()));\n\n  return ret;\n}\n\nbool MapLayer::addPointCloud(const common::PointCloudXYZI& pointcloud) {\n  if (!initialized_) {\n    return false;\n  }\n\n  for (const auto& sample : pointcloud) {\n    Tiler::TileID tile_id = tiler_->getTileID(Eigen::Vector3f(sample.x, sample.y, sample.z));\n    auto it = tile_pool_.find(tile_id);\n    std::shared_ptr<Ndt3Tile> tile;\n    if (tile_pool_.end() == it) {\n      tile = std::shared_ptr<Ndt3Tile>(new Ndt3Tile(layer_info_.grid_size()));\n      tile_pool_[tile_id] = tile;\n    } else {\n      tile = it->second;\n    }\n\n    tile->addSample(sample);\n  }\n\n  return true;\n}\n\nbool MapLayer::save() {\n  if (!initialized_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (const auto& pair : tile_pool_) {\n    pair.second->computeAllNormalsAndEigenvalues(0.02);\n    ret &= tile_client_->put(pair.first, pair.second->getStorage());\n  }\n\n  return ret;\n}\n\nconst Ndt3TileMulti::Ndt3Hash& MapLayer::getAllNdt3() { return tile_pool_; }\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/map_layer.cpp"
		}
	}
]
I0403 12:06:10.106667 27612 json_parser.cpp:18] 
[
	21,
	{
		"bufnr" : 6,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if (!initializeLayer(layer_id)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) {\n  auto iter = layers_.find(layer_id);\n  if (iter != layers_.end()) {\n    return iter->second;\n  } else {\n    return nullptr;\n  }\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(const std::string& type_name,\n                                                          float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return nullptr;\n  }\n  return getLayer(layer_id);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0403 12:06:13.738031 27612 json_parser.cpp:18] 
[
	22,
	{
		"bufnr" : 6,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if (!initializeLayer(layer_id)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) {\n  auto iter = layers_.find(layer_id);\n  if (iter != layers_.end()) {\n    return iter->second;\n  } else {\n    return nullptr;\n  }\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(const std::string& type_name,\n                                                          float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return nullptr;\n  }\n  return getLayer(layer_id);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0403 12:06:13.814746 27612 json_parser.cpp:18] 
[
	23,
	{
		"bufnr" : 3,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#include <fstream>\n\n#include \"common/proto/config/config_map.pb.h\"\n#include \"lidar_map.h\"\n\nnamespace allride {\nnamespace mapping {\n\nMapLayerDictionaryParser LidarMap::map_layer_dict_;\nstd::string LidarMap::database_path_;\nint LidarMap::cache_range_;\nint LidarMap::cache_margin_;\n\nbool LidarMap::configure(const std::string& config_file) {\n  std::ifstream map_config_ifs(config_file);\n  proto::config::ConfigMap map_config;\n  if (!map_config.ParseFromIstream(&map_config_ifs)) {\n    return false;\n  }\n\n  if (!map_layer_dict_.load(map_config.maplayer_dict_path())) {\n    return false;\n  }\n\n  database_path_ = map_config.database_path();\n\n  cache_range_ = map_config.cache_range();\n\n  cache_margin_ = map_config.cache_margin();\n\n  return true;\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map.cpp"
		}
	}
]
I0403 12:06:16.160073 27612 json_parser.cpp:18] 
[
	24,
	{
		"bufnr" : 3,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#include <fstream>\n\n#include \"common/proto/config/config_map.pb.h\"\n#include \"lidar_map.h\"\n\nnamespace allride {\nnamespace mapping {\n\nMapLayerDictionaryParser LidarMap::map_layer_dict_;\nstd::string LidarMap::database_path_;\nint LidarMap::cache_range_;\nint LidarMap::cache_margin_;\n\nbool LidarMap::configure(const std::string& config_file) {\n  std::ifstream map_config_ifs(config_file);\n  proto::config::ConfigMap map_config;\n  if (!map_config.ParseFromIstream(&map_config_ifs)) {\n    return false;\n  }\n\n  if (!map_layer_dict_.load(map_config.maplayer_dict_path())) {\n    return false;\n  }\n\n  database_path_ = map_config.database_path();\n\n  cache_range_ = map_config.cache_range();\n\n  cache_margin_ = map_config.cache_margin();\n\n  return true;\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map.cpp"
		}
	}
]
I0403 12:06:16.204453 27612 json_parser.cpp:18] 
[
	25,
	{
		"bufnr" : 5,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/point_types.h\"\n#include \"map_layer_dictionary_parser.h\"\n#include \"ndt3interface.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass LidarMap {\n public:\n  /// @brief configure the LidarMap class, mainly LayerID to resolution map, database path,\n  /// which are shared by all LidarMap and its decents\n  ///\n  /// @param config_file[in] the path to config file\n  ///\n  /// @return true on succeed, else false\n  ///\n  /// @note this should be called first before any operation about LidarMap\n  static bool configure(const std::string& config_file);\n\n  /// @brief initialize a layer before using it\n  ///\n  /// @param layer_id[in] specify which layer to initialize\n  ///\n  /// @return true on succeed, else false\n  virtual bool initializeLayer(int layer_id) = 0;\n\n  /// @brief add point to LidarMap on specific layer\n  ///\n  /// @param layer_id[in] specify which layer to add point cloud\n  /// @param pointcloud[in] the cloud point to add\n  ///\n  /// @return true on succeed, else false\n  virtual bool addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) = 0;\n\n protected:\n  static MapLayerDictionaryParser map_layer_dict_;\n  static std::string database_path_;\n  static int cache_range_;\n  static int cache_margin_;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map.h"
		}
	}
]
I0403 12:06:50.159616 27612 json_parser.cpp:18] 
[
	26,
	{
		"bufnr" : 5,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/point_types.h\"\n#include \"map_layer_dictionary_parser.h\"\n#include \"ndt3interface.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass LidarMap {\n public:\n  /// @brief configure the LidarMap class, mainly LayerID to resolution map, database path,\n  /// which are shared by all LidarMap and its decents\n  ///\n  /// @param config_file[in] the path to config file\n  ///\n  /// @return true on succeed, else false\n  ///\n  /// @note this should be called first before any operation about LidarMap\n  static bool configure(const std::string& config_file);\n\n  /// @brief initialize a layer before using it\n  ///\n  /// @param layer_id[in] specify which layer to initialize\n  ///\n  /// @return true on succeed, else false\n  virtual bool initializeLayer(int layer_id) = 0;\n\n  /// @brief add point to LidarMap on specific layer\n  ///\n  /// @param layer_id[in] specify which layer to add point cloud\n  /// @param pointcloud[in] the cloud point to add\n  ///\n  /// @return true on succeed, else false\n  virtual bool addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) = 0;\n\n protected:\n  static MapLayerDictionaryParser map_layer_dict_;\n  static std::string database_path_;\n  static int cache_range_;\n  static int cache_margin_;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map.h"
		}
	}
]
I0403 12:06:50.200124 27612 json_parser.cpp:18] 
[
	27,
	{
		"bufnr" : 3,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#include <fstream>\n\n#include \"common/proto/config/config_map.pb.h\"\n#include \"lidar_map.h\"\n\nnamespace allride {\nnamespace mapping {\n\nMapLayerDictionaryParser LidarMap::map_layer_dict_;\nstd::string LidarMap::database_path_;\nint LidarMap::cache_range_;\nint LidarMap::cache_margin_;\n\nbool LidarMap::configure(const std::string& config_file) {\n  std::ifstream map_config_ifs(config_file);\n  proto::config::ConfigMap map_config;\n  if (!map_config.ParseFromIstream(&map_config_ifs)) {\n    return false;\n  }\n\n  if (!map_layer_dict_.load(map_config.maplayer_dict_path())) {\n    return false;\n  }\n\n  database_path_ = map_config.database_path();\n\n  cache_range_ = map_config.cache_range();\n\n  cache_margin_ = map_config.cache_margin();\n\n  return true;\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map.cpp"
		}
	}
]
I0403 12:06:53.089875 27612 json_parser.cpp:18] 
[
	28,
	{
		"bufnr" : 3,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#include <fstream>\n\n#include \"common/proto/config/config_map.pb.h\"\n#include \"lidar_map.h\"\n\nnamespace allride {\nnamespace mapping {\n\nMapLayerDictionaryParser LidarMap::map_layer_dict_;\nstd::string LidarMap::database_path_;\nint LidarMap::cache_range_;\nint LidarMap::cache_margin_;\n\nbool LidarMap::configure(const std::string& config_file) {\n  std::ifstream map_config_ifs(config_file);\n  proto::config::ConfigMap map_config;\n  if (!map_config.ParseFromIstream(&map_config_ifs)) {\n    return false;\n  }\n\n  if (!map_layer_dict_.load(map_config.maplayer_dict_path())) {\n    return false;\n  }\n\n  database_path_ = map_config.database_path();\n\n  cache_range_ = map_config.cache_range();\n\n  cache_margin_ = map_config.cache_margin();\n\n  return true;\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map.cpp"
		}
	}
]
I0403 12:06:53.143759 27612 json_parser.cpp:18] 
[
	29,
	{
		"bufnr" : 10,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/ndt3tile_multi.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#include \"ndt3tile_multi.h\"\n\nnamespace allride {\nnamespace mapping {\n\nNdt3TileMulti::Ndt3TileMulti(const std::shared_ptr<Ndt3Hash>& tiles, float tile_size) {\n  tiles_hash_ = tiles;\n  tiler_ = std::unique_ptr<Tiler>(new Tiler(tile_size));\n}\n\nstd::shared_ptr<Ndt3Interface::MapMatrixArray> Ndt3TileMulti::getMeans() const {\n  std::shared_ptr<MapMatrixArray> map_matrix_array;\n  map_matrix_array = std::shared_ptr<MapMatrixArray>(new MapMatrixArray);\n\n  for (const auto& it : *tiles_hash_) {\n    map_matrix_array->push_back(it.second->getMeansInner());\n  }\n\n  return map_matrix_array;\n}\n\nstd::shared_ptr<Ndt3Interface::MapMatrixArray> Ndt3TileMulti::getCovariances() const {\n  std::shared_ptr<MapMatrixArray> map_matrix_array;\n  map_matrix_array = std::shared_ptr<MapMatrixArray>(new MapMatrixArray);\n\n  for (const auto& it : *tiles_hash_) {\n    map_matrix_array->push_back(it.second->getCovariancesInner());\n  }\n\n  return map_matrix_array;\n}\n\nstd::shared_ptr<Ndt3Interface::MapMatrixArray> Ndt3TileMulti::getCounts() const {\n  std::shared_ptr<MapMatrixArray> map_matrix_array;\n  map_matrix_array = std::shared_ptr<MapMatrixArray>(new MapMatrixArray);\n\n  for (const auto& it : *tiles_hash_) {\n    map_matrix_array->push_back(it.second->getCountsInner());\n  }\n\n  return map_matrix_array;\n}\n\nstd::shared_ptr<Ndt3Interface::MapMatrixArray> Ndt3TileMulti::getScales() const {\n  std::shared_ptr<MapMatrixArray> map_matrix_array;\n  map_matrix_array = std::shared_ptr<MapMatrixArray>(new MapMatrixArray);\n\n  for (const auto& it : *tiles_hash_) {\n    map_matrix_array->push_back(it.second->getScalesInner());\n  }\n\n  return map_matrix_array;\n}\n\nstd::shared_ptr<Ndt3Interface::MapMatrixArray> Ndt3TileMulti::getNormals() const {\n  std::shared_ptr<MapMatrixArray> map_matrix_array;\n  map_matrix_array = std::shared_ptr<MapMatrixArray>(new MapMatrixArray);\n\n  for (const auto& it : *tiles_hash_) {\n    map_matrix_array->push_back(it.second->getNormalsInner());\n  }\n\n  return map_matrix_array;\n}\n\nstd::shared_ptr<Ndt3Interface::MapMatrixArray> Ndt3TileMulti::getEigenvalues() const {\n  std::shared_ptr<MapMatrixArray> map_matrix_array;\n  map_matrix_array = std::shared_ptr<MapMatrixArray>(new MapMatrixArray);\n\n  for (const auto& it : *tiles_hash_) {\n    map_matrix_array->push_back(it.second->getEigenvaluesInner());\n  }\n\n  return map_matrix_array;\n}\n\nstd::shared_ptr<Ndt3Interface::MapMatrixArray> Ndt3TileMulti::getIntensities() const {\n  std::shared_ptr<MapMatrixArray> map_matrix_array;\n  map_matrix_array = std::shared_ptr<MapMatrixArray>(new MapMatrixArray);\n\n  for (const auto& it : *tiles_hash_) {\n    map_matrix_array->push_back(it.second->getIntensitiesInner());\n  }\n\n  return map_matrix_array;\n}\n\nbool Ndt3TileMulti::getMean(const Eigen::Vector3f& pos, Eigen::Vector3f* mean) const {\n  if (nullptr == tiles_hash_ || nullptr == tiler_) {\n    return false;\n  }\n\n  auto tile_id = tiler_->getTileID(pos);\n  auto it = tiles_hash_->find(tile_id);\n  if (tiles_hash_->end() == it) {\n    return false;\n  }\n\n  return it->second->getMean(pos, mean);\n}\n\nbool Ndt3TileMulti::getCovariance(const Eigen::Vector3f& pos, Eigen::Matrix3f* cov) const {\n  if (nullptr == tiles_hash_ || nullptr == tiler_) {\n    return false;\n  }\n\n  auto tile_id = tiler_->getTileID(pos);\n  auto it = tiles_hash_->find(tile_id);\n  if (tiles_hash_->end() == it) {\n    return false;\n  }\n\n  return it->second->getCovariance(pos, cov);\n}\n\nbool Ndt3TileMulti::getCount(const Eigen::Vector3f& pos, float* count) const {\n  if (nullptr == tiles_hash_ || nullptr == tiler_) {\n    return false;\n  }\n\n  auto tile_id = tiler_->getTileID(pos);\n  auto it = tiles_hash_->find(tile_id);\n  if (tiles_hash_->end() == it) {\n    return false;\n  }\n\n  return it->second->getCount(pos, count);\n}\n\nbool Ndt3TileMulti::getScale(const Eigen::Vector3f& pos, float* scale) const {\n  if (nullptr == tiles_hash_ || nullptr == tiler_) {\n    return false;\n  }\n\n  auto tile_id = tiler_->getTileID(pos);\n  auto it = tiles_hash_->find(tile_id);\n  if (tiles_hash_->end() == it) {\n    return false;\n  }\n\n  return it->second->getScale(pos, scale);\n}\n\nbool Ndt3TileMulti::getNormal(const Eigen::Vector3f& pos, Eigen::Vector3f* normal) const {\n  if (nullptr == tiles_hash_ || nullptr == tiler_) {\n    return false;\n  }\n\n  auto tile_id = tiler_->getTileID(pos);\n  auto it = tiles_hash_->find(tile_id);\n  if (tiles_hash_->end() == it) {\n    return false;\n  }\n\n  return it->second->getNormal(pos, normal);\n}\n\nbool Ndt3TileMulti::getEigenvalue(const Eigen::Vector3f& pos, Eigen::Vector3f* eigen) const {\n  if (nullptr == tiles_hash_ || nullptr == tiler_) {\n    return false;\n  }\n\n  auto tile_id = tiler_->getTileID(pos);\n  auto it = tiles_hash_->find(tile_id);\n  if (tiles_hash_->end() == it) {\n    return false;\n  }\n\n  return it->second->getEigenvalue(pos, eigen);\n}\n\nbool Ndt3TileMulti::getIntensity(const Eigen::Vector3f& pos, float* intensity) const {\n  if (nullptr == tiles_hash_ || nullptr == tiler_) {\n    return false;\n  }\n\n  auto tile_id = tiler_->getTileID(pos);\n  auto it = tiles_hash_->find(tile_id);\n  if (tiles_hash_->end() == it) {\n    return false;\n  }\n\n  return it->second->getIntensity(pos, intensity);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/ndt3tile_multi.cpp"
		}
	}
]
I0403 12:07:10.327950 27612 json_parser.cpp:18] 
[
	30,
	{
		"bufnr" : 10,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/ndt3tile_multi.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#include \"ndt3tile_multi.h\"\n\nnamespace allride {\nnamespace mapping {\n\nNdt3TileMulti::Ndt3TileMulti(const std::shared_ptr<Ndt3Hash>& tiles, float tile_size) {\n  tiles_hash_ = tiles;\n  tiler_ = std::unique_ptr<Tiler>(new Tiler(tile_size));\n}\n\nstd::shared_ptr<Ndt3Interface::MapMatrixArray> Ndt3TileMulti::getMeans() const {\n  std::shared_ptr<MapMatrixArray> map_matrix_array;\n  map_matrix_array = std::shared_ptr<MapMatrixArray>(new MapMatrixArray);\n\n  for (const auto& it : *tiles_hash_) {\n    map_matrix_array->push_back(it.second->getMeansInner());\n  }\n\n  return map_matrix_array;\n}\n\nstd::shared_ptr<Ndt3Interface::MapMatrixArray> Ndt3TileMulti::getCovariances() const {\n  std::shared_ptr<MapMatrixArray> map_matrix_array;\n  map_matrix_array = std::shared_ptr<MapMatrixArray>(new MapMatrixArray);\n\n  for (const auto& it : *tiles_hash_) {\n    map_matrix_array->push_back(it.second->getCovariancesInner());\n  }\n\n  return map_matrix_array;\n}\n\nstd::shared_ptr<Ndt3Interface::MapMatrixArray> Ndt3TileMulti::getCounts() const {\n  std::shared_ptr<MapMatrixArray> map_matrix_array;\n  map_matrix_array = std::shared_ptr<MapMatrixArray>(new MapMatrixArray);\n\n  for (const auto& it : *tiles_hash_) {\n    map_matrix_array->push_back(it.second->getCountsInner());\n  }\n\n  return map_matrix_array;\n}\n\nstd::shared_ptr<Ndt3Interface::MapMatrixArray> Ndt3TileMulti::getScales() const {\n  std::shared_ptr<MapMatrixArray> map_matrix_array;\n  map_matrix_array = std::shared_ptr<MapMatrixArray>(new MapMatrixArray);\n\n  for (const auto& it : *tiles_hash_) {\n    map_matrix_array->push_back(it.second->getScalesInner());\n  }\n\n  return map_matrix_array;\n}\n\nstd::shared_ptr<Ndt3Interface::MapMatrixArray> Ndt3TileMulti::getNormals() const {\n  std::shared_ptr<MapMatrixArray> map_matrix_array;\n  map_matrix_array = std::shared_ptr<MapMatrixArray>(new MapMatrixArray);\n\n  for (const auto& it : *tiles_hash_) {\n    map_matrix_array->push_back(it.second->getNormalsInner());\n  }\n\n  return map_matrix_array;\n}\n\nstd::shared_ptr<Ndt3Interface::MapMatrixArray> Ndt3TileMulti::getEigenvalues() const {\n  std::shared_ptr<MapMatrixArray> map_matrix_array;\n  map_matrix_array = std::shared_ptr<MapMatrixArray>(new MapMatrixArray);\n\n  for (const auto& it : *tiles_hash_) {\n    map_matrix_array->push_back(it.second->getEigenvaluesInner());\n  }\n\n  return map_matrix_array;\n}\n\nstd::shared_ptr<Ndt3Interface::MapMatrixArray> Ndt3TileMulti::getIntensities() const {\n  std::shared_ptr<MapMatrixArray> map_matrix_array;\n  map_matrix_array = std::shared_ptr<MapMatrixArray>(new MapMatrixArray);\n\n  for (const auto& it : *tiles_hash_) {\n    map_matrix_array->push_back(it.second->getIntensitiesInner());\n  }\n\n  return map_matrix_array;\n}\n\nbool Ndt3TileMulti::getMean(const Eigen::Vector3f& pos, Eigen::Vector3f* mean) const {\n  if (nullptr == tiles_hash_ || nullptr == tiler_) {\n    return false;\n  }\n\n  auto tile_id = tiler_->getTileID(pos);\n  auto it = tiles_hash_->find(tile_id);\n  if (tiles_hash_->end() == it) {\n    return false;\n  }\n\n  return it->second->getMean(pos, mean);\n}\n\nbool Ndt3TileMulti::getCovariance(const Eigen::Vector3f& pos, Eigen::Matrix3f* cov) const {\n  if (nullptr == tiles_hash_ || nullptr == tiler_) {\n    return false;\n  }\n\n  auto tile_id = tiler_->getTileID(pos);\n  auto it = tiles_hash_->find(tile_id);\n  if (tiles_hash_->end() == it) {\n    return false;\n  }\n\n  return it->second->getCovariance(pos, cov);\n}\n\nbool Ndt3TileMulti::getCount(const Eigen::Vector3f& pos, float* count) const {\n  if (nullptr == tiles_hash_ || nullptr == tiler_) {\n    return false;\n  }\n\n  auto tile_id = tiler_->getTileID(pos);\n  auto it = tiles_hash_->find(tile_id);\n  if (tiles_hash_->end() == it) {\n    return false;\n  }\n\n  return it->second->getCount(pos, count);\n}\n\nbool Ndt3TileMulti::getScale(const Eigen::Vector3f& pos, float* scale) const {\n  if (nullptr == tiles_hash_ || nullptr == tiler_) {\n    return false;\n  }\n\n  auto tile_id = tiler_->getTileID(pos);\n  auto it = tiles_hash_->find(tile_id);\n  if (tiles_hash_->end() == it) {\n    return false;\n  }\n\n  return it->second->getScale(pos, scale);\n}\n\nbool Ndt3TileMulti::getNormal(const Eigen::Vector3f& pos, Eigen::Vector3f* normal) const {\n  if (nullptr == tiles_hash_ || nullptr == tiler_) {\n    return false;\n  }\n\n  auto tile_id = tiler_->getTileID(pos);\n  auto it = tiles_hash_->find(tile_id);\n  if (tiles_hash_->end() == it) {\n    return false;\n  }\n\n  return it->second->getNormal(pos, normal);\n}\n\nbool Ndt3TileMulti::getEigenvalue(const Eigen::Vector3f& pos, Eigen::Vector3f* eigen) const {\n  if (nullptr == tiles_hash_ || nullptr == tiler_) {\n    return false;\n  }\n\n  auto tile_id = tiler_->getTileID(pos);\n  auto it = tiles_hash_->find(tile_id);\n  if (tiles_hash_->end() == it) {\n    return false;\n  }\n\n  return it->second->getEigenvalue(pos, eigen);\n}\n\nbool Ndt3TileMulti::getIntensity(const Eigen::Vector3f& pos, float* intensity) const {\n  if (nullptr == tiles_hash_ || nullptr == tiler_) {\n    return false;\n  }\n\n  auto tile_id = tiler_->getTileID(pos);\n  auto it = tiles_hash_->find(tile_id);\n  if (tiles_hash_->end() == it) {\n    return false;\n  }\n\n  return it->second->getIntensity(pos, intensity);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/ndt3tile_multi.cpp"
		}
	}
]
I0403 12:08:06.441283 27612 json_parser.cpp:18] 
[
	33,
	{
		"bufnr" : 13,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/ndt3interface.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/eigen_types.h\"\n#include \"tile_data_storage.h\"\n\nnamespace allride {\nnamespace mapping {\n\n/// @brief Define the interface to utilize the Ndt3Data(s).\nclass Ndt3Interface {\n public:\n  typedef std::vector<TileDataStorage::MapMatrix,\n                      Eigen::aligned_allocator<TileDataStorage::MapMatrix>>\n      MapMatrixArray;\n\n  /// @brief get the means of all existing grids in the Ndt3Data(s)\n  ///\n  /// @return an array of the means stored in an Eigen::map\n  virtual std::shared_ptr<MapMatrixArray> getMeans() const = 0;\n\n  /// @brief get the covariances of all existing grids in the Ndt3Data(s)\n  ///\n  /// @return an array of the covariances stored in an Eigen::map\n  virtual std::shared_ptr<MapMatrixArray> getCovariances() const = 0;\n\n  /// @brief get the counts of all existing grids in the Ndt3Data(s)\n  ///\n  /// @return an array of the counts stored in an Eigen::map\n  virtual std::shared_ptr<MapMatrixArray> getCounts() const = 0;\n\n  /// @brief get the scales of all existing grids in the Ndt3Data(s)\n  ///\n  /// @return an array of the scales stored in an Eigen::map\n  virtual std::shared_ptr<MapMatrixArray> getScales() const = 0;\n\n  /// @brief get the normals of all existing grids in the Ndt3Data(s)\n  ///\n  /// @return an array of the normals stored in an Eigen::map\n  virtual std::shared_ptr<MapMatrixArray> getNormals() const = 0;\n\n  /// @brief get the eigen values of all existing grids in the Ndt3Data(s)\n  ///\n  /// @return an array of the eigen values stored in an Eigen::map\n  virtual std::shared_ptr<MapMatrixArray> getEigenvalues() const = 0;\n\n  /// @brief get the intensities of all existing grids in the Ndt3Data(s)\n  ///\n  /// @return an array of the intensities stored in an Eigen::map\n  virtual std::shared_ptr<MapMatrixArray> getIntensities() const = 0;\n\n  /// @brief get the mean of a grid specified by a position\n  ///\n  /// @param[in] pos the point which the querying grid contains\n  /// @param[out] mean stores the mean got\n  ///\n  /// @return true if the querying grid exists, else false\n  virtual bool getMean(const Eigen::Vector3f& pos, Eigen::Vector3f* mean) const = 0;\n\n  /// @brief get the covariance of a grid specified by a position\n  ///\n  /// @param[in] pos the point which the querying grid contains\n  /// @param[out] cov stores the covariance got\n  ///\n  /// @return true if the querying grid exists, else false\n  virtual bool getCovariance(const Eigen::Vector3f& pos, Eigen::Matrix3f* cov) const = 0;\n\n  /// @brief get the covariance of a grid specified by a position\n  ///\n  /// @param[in] pos the point which the querying grid contains\n  /// @param[out] cov stores the covariance got\n  ///\n  /// @return true if the querying grid exists, else false\n  virtual bool getCount(const Eigen::Vector3f& pos, float* count) const = 0;\n\n  /// @brief get the covariance of a grid specified by a position\n  ///\n  /// @param[in] pos the point which the querying grid contains\n  /// @param[out] cov stores the covariance got\n  ///\n  /// @return true if the querying grid exists, else false\n  virtual bool getScale(const Eigen::Vector3f& pos, float* scale) const = 0;\n\n  /// @brief get the normal of a grid specified by a position\n  ///\n  /// @param[in] pos the point which the querying grid contains\n  /// @param[out] cov stores the normal got\n  ///\n  /// @return true if the querying grid exists, else false\n  virtual bool getNormal(const Eigen::Vector3f& pos, Eigen::Vector3f* normal) const = 0;\n\n  /// @brief get the eigen value of a grid specified by a position\n  ///\n  /// @param[in] pos the point which the querying grid contains\n  /// @param[out] cov stores the eigen value got\n  ///\n  /// @return true if the querying grid exists, else false\n  virtual bool getEigenvalue(const Eigen::Vector3f& pos, Eigen::Vector3f* eigen) const = 0;\n\n  /// @brief get the intensity of a grid specified by a position\n  ///\n  /// @param[in] pos the point which the querying grid contains\n  /// @param[out] cov stores the intensity got\n  ///\n  /// @return true if the querying grid exists, else false\n  virtual bool getIntensity(const Eigen::Vector3f& pos, float* intensity) const = 0;\n};\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/ndt3interface.h"
		}
	}
]
I0403 12:08:20.644399 27612 json_parser.cpp:18] 
[
	34,
	{
		"bufnr" : 13,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/ndt3interface.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/eigen_types.h\"\n#include \"tile_data_storage.h\"\n\nnamespace allride {\nnamespace mapping {\n\n/// @brief Define the interface to utilize the Ndt3Data(s).\nclass Ndt3Interface {\n public:\n  typedef std::vector<TileDataStorage::MapMatrix,\n                      Eigen::aligned_allocator<TileDataStorage::MapMatrix>>\n      MapMatrixArray;\n\n  /// @brief get the means of all existing grids in the Ndt3Data(s)\n  ///\n  /// @return an array of the means stored in an Eigen::map\n  virtual std::shared_ptr<MapMatrixArray> getMeans() const = 0;\n\n  /// @brief get the covariances of all existing grids in the Ndt3Data(s)\n  ///\n  /// @return an array of the covariances stored in an Eigen::map\n  virtual std::shared_ptr<MapMatrixArray> getCovariances() const = 0;\n\n  /// @brief get the counts of all existing grids in the Ndt3Data(s)\n  ///\n  /// @return an array of the counts stored in an Eigen::map\n  virtual std::shared_ptr<MapMatrixArray> getCounts() const = 0;\n\n  /// @brief get the scales of all existing grids in the Ndt3Data(s)\n  ///\n  /// @return an array of the scales stored in an Eigen::map\n  virtual std::shared_ptr<MapMatrixArray> getScales() const = 0;\n\n  /// @brief get the normals of all existing grids in the Ndt3Data(s)\n  ///\n  /// @return an array of the normals stored in an Eigen::map\n  virtual std::shared_ptr<MapMatrixArray> getNormals() const = 0;\n\n  /// @brief get the eigen values of all existing grids in the Ndt3Data(s)\n  ///\n  /// @return an array of the eigen values stored in an Eigen::map\n  virtual std::shared_ptr<MapMatrixArray> getEigenvalues() const = 0;\n\n  /// @brief get the intensities of all existing grids in the Ndt3Data(s)\n  ///\n  /// @return an array of the intensities stored in an Eigen::map\n  virtual std::shared_ptr<MapMatrixArray> getIntensities() const = 0;\n\n  /// @brief get the mean of a grid specified by a position\n  ///\n  /// @param[in] pos the point which the querying grid contains\n  /// @param[out] mean stores the mean got\n  ///\n  /// @return true if the querying grid exists, else false\n  virtual bool getMean(const Eigen::Vector3f& pos, Eigen::Vector3f* mean) const = 0;\n\n  /// @brief get the covariance of a grid specified by a position\n  ///\n  /// @param[in] pos the point which the querying grid contains\n  /// @param[out] cov stores the covariance got\n  ///\n  /// @return true if the querying grid exists, else false\n  virtual bool getCovariance(const Eigen::Vector3f& pos, Eigen::Matrix3f* cov) const = 0;\n\n  /// @brief get the covariance of a grid specified by a position\n  ///\n  /// @param[in] pos the point which the querying grid contains\n  /// @param[out] cov stores the covariance got\n  ///\n  /// @return true if the querying grid exists, else false\n  virtual bool getCount(const Eigen::Vector3f& pos, float* count) const = 0;\n\n  /// @brief get the covariance of a grid specified by a position\n  ///\n  /// @param[in] pos the point which the querying grid contains\n  /// @param[out] cov stores the covariance got\n  ///\n  /// @return true if the querying grid exists, else false\n  virtual bool getScale(const Eigen::Vector3f& pos, float* scale) const = 0;\n\n  /// @brief get the normal of a grid specified by a position\n  ///\n  /// @param[in] pos the point which the querying grid contains\n  /// @param[out] cov stores the normal got\n  ///\n  /// @return true if the querying grid exists, else false\n  virtual bool getNormal(const Eigen::Vector3f& pos, Eigen::Vector3f* normal) const = 0;\n\n  /// @brief get the eigen value of a grid specified by a position\n  ///\n  /// @param[in] pos the point which the querying grid contains\n  /// @param[out] cov stores the eigen value got\n  ///\n  /// @return true if the querying grid exists, else false\n  virtual bool getEigenvalue(const Eigen::Vector3f& pos, Eigen::Vector3f* eigen) const = 0;\n\n  /// @brief get the intensity of a grid specified by a position\n  ///\n  /// @param[in] pos the point which the querying grid contains\n  /// @param[out] cov stores the intensity got\n  ///\n  /// @return true if the querying grid exists, else false\n  virtual bool getIntensity(const Eigen::Vector3f& pos, float* intensity) const = 0;\n};\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/ndt3interface.h"
		}
	}
]
I0403 12:08:20.684511 27612 json_parser.cpp:18] 
[
	35,
	{
		"bufnr" : 10,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/ndt3tile_multi.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#include \"ndt3tile_multi.h\"\n\nnamespace allride {\nnamespace mapping {\n\nNdt3TileMulti::Ndt3TileMulti(const std::shared_ptr<Ndt3Hash>& tiles, float tile_size) {\n  tiles_hash_ = tiles;\n  tiler_ = std::unique_ptr<Tiler>(new Tiler(tile_size));\n}\n\nstd::shared_ptr<Ndt3Interface::MapMatrixArray> Ndt3TileMulti::getMeans() const {\n  std::shared_ptr<MapMatrixArray> map_matrix_array;\n  map_matrix_array = std::shared_ptr<MapMatrixArray>(new MapMatrixArray);\n\n  for (const auto& it : *tiles_hash_) {\n    map_matrix_array->push_back(it.second->getMeansInner());\n  }\n\n  return map_matrix_array;\n}\n\nstd::shared_ptr<Ndt3Interface::MapMatrixArray> Ndt3TileMulti::getCovariances() const {\n  std::shared_ptr<MapMatrixArray> map_matrix_array;\n  map_matrix_array = std::shared_ptr<MapMatrixArray>(new MapMatrixArray);\n\n  for (const auto& it : *tiles_hash_) {\n    map_matrix_array->push_back(it.second->getCovariancesInner());\n  }\n\n  return map_matrix_array;\n}\n\nstd::shared_ptr<Ndt3Interface::MapMatrixArray> Ndt3TileMulti::getCounts() const {\n  std::shared_ptr<MapMatrixArray> map_matrix_array;\n  map_matrix_array = std::shared_ptr<MapMatrixArray>(new MapMatrixArray);\n\n  for (const auto& it : *tiles_hash_) {\n    map_matrix_array->push_back(it.second->getCountsInner());\n  }\n\n  return map_matrix_array;\n}\n\nstd::shared_ptr<Ndt3Interface::MapMatrixArray> Ndt3TileMulti::getScales() const {\n  std::shared_ptr<MapMatrixArray> map_matrix_array;\n  map_matrix_array = std::shared_ptr<MapMatrixArray>(new MapMatrixArray);\n\n  for (const auto& it : *tiles_hash_) {\n    map_matrix_array->push_back(it.second->getScalesInner());\n  }\n\n  return map_matrix_array;\n}\n\nstd::shared_ptr<Ndt3Interface::MapMatrixArray> Ndt3TileMulti::getNormals() const {\n  std::shared_ptr<MapMatrixArray> map_matrix_array;\n  map_matrix_array = std::shared_ptr<MapMatrixArray>(new MapMatrixArray);\n\n  for (const auto& it : *tiles_hash_) {\n    map_matrix_array->push_back(it.second->getNormalsInner());\n  }\n\n  return map_matrix_array;\n}\n\nstd::shared_ptr<Ndt3Interface::MapMatrixArray> Ndt3TileMulti::getEigenvalues() const {\n  std::shared_ptr<MapMatrixArray> map_matrix_array;\n  map_matrix_array = std::shared_ptr<MapMatrixArray>(new MapMatrixArray);\n\n  for (const auto& it : *tiles_hash_) {\n    map_matrix_array->push_back(it.second->getEigenvaluesInner());\n  }\n\n  return map_matrix_array;\n}\n\nstd::shared_ptr<Ndt3Interface::MapMatrixArray> Ndt3TileMulti::getIntensities() const {\n  std::shared_ptr<MapMatrixArray> map_matrix_array;\n  map_matrix_array = std::shared_ptr<MapMatrixArray>(new MapMatrixArray);\n\n  for (const auto& it : *tiles_hash_) {\n    map_matrix_array->push_back(it.second->getIntensitiesInner());\n  }\n\n  return map_matrix_array;\n}\n\nbool Ndt3TileMulti::getMean(const Eigen::Vector3f& pos, Eigen::Vector3f* mean) const {\n  if (nullptr == tiles_hash_ || nullptr == tiler_) {\n    return false;\n  }\n\n  auto tile_id = tiler_->getTileID(pos);\n  auto it = tiles_hash_->find(tile_id);\n  if (tiles_hash_->end() == it) {\n    return false;\n  }\n\n  return it->second->getMean(pos, mean);\n}\n\nbool Ndt3TileMulti::getCovariance(const Eigen::Vector3f& pos, Eigen::Matrix3f* cov) const {\n  if (nullptr == tiles_hash_ || nullptr == tiler_) {\n    return false;\n  }\n\n  auto tile_id = tiler_->getTileID(pos);\n  auto it = tiles_hash_->find(tile_id);\n  if (tiles_hash_->end() == it) {\n    return false;\n  }\n\n  return it->second->getCovariance(pos, cov);\n}\n\nbool Ndt3TileMulti::getCount(const Eigen::Vector3f& pos, float* count) const {\n  if (nullptr == tiles_hash_ || nullptr == tiler_) {\n    return false;\n  }\n\n  auto tile_id = tiler_->getTileID(pos);\n  auto it = tiles_hash_->find(tile_id);\n  if (tiles_hash_->end() == it) {\n    return false;\n  }\n\n  return it->second->getCount(pos, count);\n}\n\nbool Ndt3TileMulti::getScale(const Eigen::Vector3f& pos, float* scale) const {\n  if (nullptr == tiles_hash_ || nullptr == tiler_) {\n    return false;\n  }\n\n  auto tile_id = tiler_->getTileID(pos);\n  auto it = tiles_hash_->find(tile_id);\n  if (tiles_hash_->end() == it) {\n    return false;\n  }\n\n  return it->second->getScale(pos, scale);\n}\n\nbool Ndt3TileMulti::getNormal(const Eigen::Vector3f& pos, Eigen::Vector3f* normal) const {\n  if (nullptr == tiles_hash_ || nullptr == tiler_) {\n    return false;\n  }\n\n  auto tile_id = tiler_->getTileID(pos);\n  auto it = tiles_hash_->find(tile_id);\n  if (tiles_hash_->end() == it) {\n    return false;\n  }\n\n  return it->second->getNormal(pos, normal);\n}\n\nbool Ndt3TileMulti::getEigenvalue(const Eigen::Vector3f& pos, Eigen::Vector3f* eigen) const {\n  if (nullptr == tiles_hash_ || nullptr == tiler_) {\n    return false;\n  }\n\n  auto tile_id = tiler_->getTileID(pos);\n  auto it = tiles_hash_->find(tile_id);\n  if (tiles_hash_->end() == it) {\n    return false;\n  }\n\n  return it->second->getEigenvalue(pos, eigen);\n}\n\nbool Ndt3TileMulti::getIntensity(const Eigen::Vector3f& pos, float* intensity) const {\n  if (nullptr == tiles_hash_ || nullptr == tiler_) {\n    return false;\n  }\n\n  auto tile_id = tiler_->getTileID(pos);\n  auto it = tiles_hash_->find(tile_id);\n  if (tiles_hash_->end() == it) {\n    return false;\n  }\n\n  return it->second->getIntensity(pos, intensity);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/ndt3tile_multi.cpp"
		}
	}
]
I0403 12:08:23.257027 27612 json_parser.cpp:18] 
[
	36,
	{
		"bufnr" : 10,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/ndt3tile_multi.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#include \"ndt3tile_multi.h\"\n\nnamespace allride {\nnamespace mapping {\n\nNdt3TileMulti::Ndt3TileMulti(const std::shared_ptr<Ndt3Hash>& tiles, float tile_size) {\n  tiles_hash_ = tiles;\n  tiler_ = std::unique_ptr<Tiler>(new Tiler(tile_size));\n}\n\nstd::shared_ptr<Ndt3Interface::MapMatrixArray> Ndt3TileMulti::getMeans() const {\n  std::shared_ptr<MapMatrixArray> map_matrix_array;\n  map_matrix_array = std::shared_ptr<MapMatrixArray>(new MapMatrixArray);\n\n  for (const auto& it : *tiles_hash_) {\n    map_matrix_array->push_back(it.second->getMeansInner());\n  }\n\n  return map_matrix_array;\n}\n\nstd::shared_ptr<Ndt3Interface::MapMatrixArray> Ndt3TileMulti::getCovariances() const {\n  std::shared_ptr<MapMatrixArray> map_matrix_array;\n  map_matrix_array = std::shared_ptr<MapMatrixArray>(new MapMatrixArray);\n\n  for (const auto& it : *tiles_hash_) {\n    map_matrix_array->push_back(it.second->getCovariancesInner());\n  }\n\n  return map_matrix_array;\n}\n\nstd::shared_ptr<Ndt3Interface::MapMatrixArray> Ndt3TileMulti::getCounts() const {\n  std::shared_ptr<MapMatrixArray> map_matrix_array;\n  map_matrix_array = std::shared_ptr<MapMatrixArray>(new MapMatrixArray);\n\n  for (const auto& it : *tiles_hash_) {\n    map_matrix_array->push_back(it.second->getCountsInner());\n  }\n\n  return map_matrix_array;\n}\n\nstd::shared_ptr<Ndt3Interface::MapMatrixArray> Ndt3TileMulti::getScales() const {\n  std::shared_ptr<MapMatrixArray> map_matrix_array;\n  map_matrix_array = std::shared_ptr<MapMatrixArray>(new MapMatrixArray);\n\n  for (const auto& it : *tiles_hash_) {\n    map_matrix_array->push_back(it.second->getScalesInner());\n  }\n\n  return map_matrix_array;\n}\n\nstd::shared_ptr<Ndt3Interface::MapMatrixArray> Ndt3TileMulti::getNormals() const {\n  std::shared_ptr<MapMatrixArray> map_matrix_array;\n  map_matrix_array = std::shared_ptr<MapMatrixArray>(new MapMatrixArray);\n\n  for (const auto& it : *tiles_hash_) {\n    map_matrix_array->push_back(it.second->getNormalsInner());\n  }\n\n  return map_matrix_array;\n}\n\nstd::shared_ptr<Ndt3Interface::MapMatrixArray> Ndt3TileMulti::getEigenvalues() const {\n  std::shared_ptr<MapMatrixArray> map_matrix_array;\n  map_matrix_array = std::shared_ptr<MapMatrixArray>(new MapMatrixArray);\n\n  for (const auto& it : *tiles_hash_) {\n    map_matrix_array->push_back(it.second->getEigenvaluesInner());\n  }\n\n  return map_matrix_array;\n}\n\nstd::shared_ptr<Ndt3Interface::MapMatrixArray> Ndt3TileMulti::getIntensities() const {\n  std::shared_ptr<MapMatrixArray> map_matrix_array;\n  map_matrix_array = std::shared_ptr<MapMatrixArray>(new MapMatrixArray);\n\n  for (const auto& it : *tiles_hash_) {\n    map_matrix_array->push_back(it.second->getIntensitiesInner());\n  }\n\n  return map_matrix_array;\n}\n\nbool Ndt3TileMulti::getMean(const Eigen::Vector3f& pos, Eigen::Vector3f* mean) const {\n  if (nullptr == tiles_hash_ || nullptr == tiler_) {\n    return false;\n  }\n\n  auto tile_id = tiler_->getTileID(pos);\n  auto it = tiles_hash_->find(tile_id);\n  if (tiles_hash_->end() == it) {\n    return false;\n  }\n\n  return it->second->getMean(pos, mean);\n}\n\nbool Ndt3TileMulti::getCovariance(const Eigen::Vector3f& pos, Eigen::Matrix3f* cov) const {\n  if (nullptr == tiles_hash_ || nullptr == tiler_) {\n    return false;\n  }\n\n  auto tile_id = tiler_->getTileID(pos);\n  auto it = tiles_hash_->find(tile_id);\n  if (tiles_hash_->end() == it) {\n    return false;\n  }\n\n  return it->second->getCovariance(pos, cov);\n}\n\nbool Ndt3TileMulti::getCount(const Eigen::Vector3f& pos, float* count) const {\n  if (nullptr == tiles_hash_ || nullptr == tiler_) {\n    return false;\n  }\n\n  auto tile_id = tiler_->getTileID(pos);\n  auto it = tiles_hash_->find(tile_id);\n  if (tiles_hash_->end() == it) {\n    return false;\n  }\n\n  return it->second->getCount(pos, count);\n}\n\nbool Ndt3TileMulti::getScale(const Eigen::Vector3f& pos, float* scale) const {\n  if (nullptr == tiles_hash_ || nullptr == tiler_) {\n    return false;\n  }\n\n  auto tile_id = tiler_->getTileID(pos);\n  auto it = tiles_hash_->find(tile_id);\n  if (tiles_hash_->end() == it) {\n    return false;\n  }\n\n  return it->second->getScale(pos, scale);\n}\n\nbool Ndt3TileMulti::getNormal(const Eigen::Vector3f& pos, Eigen::Vector3f* normal) const {\n  if (nullptr == tiles_hash_ || nullptr == tiler_) {\n    return false;\n  }\n\n  auto tile_id = tiler_->getTileID(pos);\n  auto it = tiles_hash_->find(tile_id);\n  if (tiles_hash_->end() == it) {\n    return false;\n  }\n\n  return it->second->getNormal(pos, normal);\n}\n\nbool Ndt3TileMulti::getEigenvalue(const Eigen::Vector3f& pos, Eigen::Vector3f* eigen) const {\n  if (nullptr == tiles_hash_ || nullptr == tiler_) {\n    return false;\n  }\n\n  auto tile_id = tiler_->getTileID(pos);\n  auto it = tiles_hash_->find(tile_id);\n  if (tiles_hash_->end() == it) {\n    return false;\n  }\n\n  return it->second->getEigenvalue(pos, eigen);\n}\n\nbool Ndt3TileMulti::getIntensity(const Eigen::Vector3f& pos, float* intensity) const {\n  if (nullptr == tiles_hash_ || nullptr == tiler_) {\n    return false;\n  }\n\n  auto tile_id = tiler_->getTileID(pos);\n  auto it = tiles_hash_->find(tile_id);\n  if (tiles_hash_->end() == it) {\n    return false;\n  }\n\n  return it->second->getIntensity(pos, intensity);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/ndt3tile_multi.cpp"
		}
	}
]
I0403 12:08:54.529268 27612 json_parser.cpp:18] 
[
	37,
	{
		"bufnr" : 10,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/ndt3tile_multi.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#include \"ndt3tile_multi.h\"\n\nnamespace allride {\nnamespace mapping {\n\nNdt3TileMulti::Ndt3TileMulti(const std::shared_ptr<Ndt3Hash>& tiles, float tile_size) {\n  tiles_hash_ = tiles;\n  tiler_ = std::unique_ptr<Tiler>(new Tiler(tile_size));\n}\n\nstd::shared_ptr<Ndt3Interface::MapMatrixArray> Ndt3TileMulti::getMeans() const {\n  std::shared_ptr<MapMatrixArray> map_matrix_array;\n  map_matrix_array = std::shared_ptr<MapMatrixArray>(new MapMatrixArray);\n\n  for (const auto& it : *tiles_hash_) {\n    map_matrix_array->push_back(it.second->getMeansInner());\n  }\n\n  return map_matrix_array;\n}\n\nstd::shared_ptr<Ndt3Interface::MapMatrixArray> Ndt3TileMulti::getCovariances() const {\n  std::shared_ptr<MapMatrixArray> map_matrix_array;\n  map_matrix_array = std::shared_ptr<MapMatrixArray>(new MapMatrixArray);\n\n  for (const auto& it : *tiles_hash_) {\n    map_matrix_array->push_back(it.second->getCovariancesInner());\n  }\n\n  return map_matrix_array;\n}\n\nstd::shared_ptr<Ndt3Interface::MapMatrixArray> Ndt3TileMulti::getCounts() const {\n  std::shared_ptr<MapMatrixArray> map_matrix_array;\n  map_matrix_array = std::shared_ptr<MapMatrixArray>(new MapMatrixArray);\n\n  for (const auto& it : *tiles_hash_) {\n    map_matrix_array->push_back(it.second->getCountsInner());\n  }\n\n  return map_matrix_array;\n}\n\nstd::shared_ptr<Ndt3Interface::MapMatrixArray> Ndt3TileMulti::getScales() const {\n  std::shared_ptr<MapMatrixArray> map_matrix_array;\n  map_matrix_array = std::shared_ptr<MapMatrixArray>(new MapMatrixArray);\n\n  for (const auto& it : *tiles_hash_) {\n    map_matrix_array->push_back(it.second->getScalesInner());\n  }\n\n  return map_matrix_array;\n}\n\nstd::shared_ptr<Ndt3Interface::MapMatrixArray> Ndt3TileMulti::getNormals() const {\n  std::shared_ptr<MapMatrixArray> map_matrix_array;\n  map_matrix_array = std::shared_ptr<MapMatrixArray>(new MapMatrixArray);\n\n  for (const auto& it : *tiles_hash_) {\n    map_matrix_array->push_back(it.second->getNormalsInner());\n  }\n\n  return map_matrix_array;\n}\n\nstd::shared_ptr<Ndt3Interface::MapMatrixArray> Ndt3TileMulti::getEigenvalues() const {\n  std::shared_ptr<MapMatrixArray> map_matrix_array;\n  map_matrix_array = std::shared_ptr<MapMatrixArray>(new MapMatrixArray);\n\n  for (const auto& it : *tiles_hash_) {\n    map_matrix_array->push_back(it.second->getEigenvaluesInner());\n  }\n\n  return map_matrix_array;\n}\n\nstd::shared_ptr<Ndt3Interface::MapMatrixArray> Ndt3TileMulti::getIntensities() const {\n  std::shared_ptr<MapMatrixArray> map_matrix_array;\n  map_matrix_array = std::shared_ptr<MapMatrixArray>(new MapMatrixArray);\n\n  for (const auto& it : *tiles_hash_) {\n    map_matrix_array->push_back(it.second->getIntensitiesInner());\n  }\n\n  return map_matrix_array;\n}\n\nbool Ndt3TileMulti::getMean(const Eigen::Vector3f& pos, Eigen::Vector3f* mean) const {\n  if (nullptr == tiles_hash_ || nullptr == tiler_) {\n    return false;\n  }\n\n  auto tile_id = tiler_->getTileID(pos);\n  auto it = tiles_hash_->find(tile_id);\n  if (tiles_hash_->end() == it) {\n    return false;\n  }\n\n  return it->second->getMean(pos, mean);\n}\n\nbool Ndt3TileMulti::getCovariance(const Eigen::Vector3f& pos, Eigen::Matrix3f* cov) const {\n  if (nullptr == tiles_hash_ || nullptr == tiler_) {\n    return false;\n  }\n\n  auto tile_id = tiler_->getTileID(pos);\n  auto it = tiles_hash_->find(tile_id);\n  if (tiles_hash_->end() == it) {\n    return false;\n  }\n\n  return it->second->getCovariance(pos, cov);\n}\n\nbool Ndt3TileMulti::getCount(const Eigen::Vector3f& pos, float* count) const {\n  if (nullptr == tiles_hash_ || nullptr == tiler_) {\n    return false;\n  }\n\n  auto tile_id = tiler_->getTileID(pos);\n  auto it = tiles_hash_->find(tile_id);\n  if (tiles_hash_->end() == it) {\n    return false;\n  }\n\n  return it->second->getCount(pos, count);\n}\n\nbool Ndt3TileMulti::getScale(const Eigen::Vector3f& pos, float* scale) const {\n  if (nullptr == tiles_hash_ || nullptr == tiler_) {\n    return false;\n  }\n\n  auto tile_id = tiler_->getTileID(pos);\n  auto it = tiles_hash_->find(tile_id);\n  if (tiles_hash_->end() == it) {\n    return false;\n  }\n\n  return it->second->getScale(pos, scale);\n}\n\nbool Ndt3TileMulti::getNormal(const Eigen::Vector3f& pos, Eigen::Vector3f* normal) const {\n  if (nullptr == tiles_hash_ || nullptr == tiler_) {\n    return false;\n  }\n\n  auto tile_id = tiler_->getTileID(pos);\n  auto it = tiles_hash_->find(tile_id);\n  if (tiles_hash_->end() == it) {\n    return false;\n  }\n\n  return it->second->getNormal(pos, normal);\n}\n\nbool Ndt3TileMulti::getEigenvalue(const Eigen::Vector3f& pos, Eigen::Vector3f* eigen) const {\n  if (nullptr == tiles_hash_ || nullptr == tiler_) {\n    return false;\n  }\n\n  auto tile_id = tiler_->getTileID(pos);\n  auto it = tiles_hash_->find(tile_id);\n  if (tiles_hash_->end() == it) {\n    return false;\n  }\n\n  return it->second->getEigenvalue(pos, eigen);\n}\n\nbool Ndt3TileMulti::getIntensity(const Eigen::Vector3f& pos, float* intensity) const {\n  if (nullptr == tiles_hash_ || nullptr == tiler_) {\n    return false;\n  }\n\n  auto tile_id = tiler_->getTileID(pos);\n  auto it = tiles_hash_->find(tile_id);\n  if (tiles_hash_->end() == it) {\n    return false;\n  }\n\n  return it->second->getIntensity(pos, intensity);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/ndt3tile_multi.cpp"
		}
	}
]
I0403 12:08:56.770124 27612 json_parser.cpp:18] 
[
	38,
	{
		"bufnr" : 10,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/ndt3tile_multi.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#include \"ndt3tile_multi.h\"\n\nnamespace allride {\nnamespace mapping {\n\nNdt3TileMulti::Ndt3TileMulti(const std::shared_ptr<Ndt3Hash>& tiles, float tile_size) {\n  tiles_hash_ = tiles;\n  tiler_ = std::unique_ptr<Tiler>(new Tiler(tile_size));\n}\n\nstd::shared_ptr<Ndt3Interface::MapMatrixArray> Ndt3TileMulti::getMeans() const {\n  std::shared_ptr<MapMatrixArray> map_matrix_array;\n  map_matrix_array = std::shared_ptr<MapMatrixArray>(new MapMatrixArray);\n\n  for (const auto& it : *tiles_hash_) {\n    map_matrix_array->push_back(it.second->getMeansInner());\n  }\n\n  return map_matrix_array;\n}\n\nstd::shared_ptr<Ndt3Interface::MapMatrixArray> Ndt3TileMulti::getCovariances() const {\n  std::shared_ptr<MapMatrixArray> map_matrix_array;\n  map_matrix_array = std::shared_ptr<MapMatrixArray>(new MapMatrixArray);\n\n  for (const auto& it : *tiles_hash_) {\n    map_matrix_array->push_back(it.second->getCovariancesInner());\n  }\n\n  return map_matrix_array;\n}\n\nstd::shared_ptr<Ndt3Interface::MapMatrixArray> Ndt3TileMulti::getCounts() const {\n  std::shared_ptr<MapMatrixArray> map_matrix_array;\n  map_matrix_array = std::shared_ptr<MapMatrixArray>(new MapMatrixArray);\n\n  for (const auto& it : *tiles_hash_) {\n    map_matrix_array->push_back(it.second->getCountsInner());\n  }\n\n  return map_matrix_array;\n}\n\nstd::shared_ptr<Ndt3Interface::MapMatrixArray> Ndt3TileMulti::getScales() const {\n  std::shared_ptr<MapMatrixArray> map_matrix_array;\n  map_matrix_array = std::shared_ptr<MapMatrixArray>(new MapMatrixArray);\n\n  for (const auto& it : *tiles_hash_) {\n    map_matrix_array->push_back(it.second->getScalesInner());\n  }\n\n  return map_matrix_array;\n}\n\nstd::shared_ptr<Ndt3Interface::MapMatrixArray> Ndt3TileMulti::getNormals() const {\n  std::shared_ptr<MapMatrixArray> map_matrix_array;\n  map_matrix_array = std::shared_ptr<MapMatrixArray>(new MapMatrixArray);\n\n  for (const auto& it : *tiles_hash_) {\n    map_matrix_array->push_back(it.second->getNormalsInner());\n  }\n\n  return map_matrix_array;\n}\n\nstd::shared_ptr<Ndt3Interface::MapMatrixArray> Ndt3TileMulti::getEigenvalues() const {\n  std::shared_ptr<MapMatrixArray> map_matrix_array;\n  map_matrix_array = std::shared_ptr<MapMatrixArray>(new MapMatrixArray);\n\n  for (const auto& it : *tiles_hash_) {\n    map_matrix_array->push_back(it.second->getEigenvaluesInner());\n  }\n\n  return map_matrix_array;\n}\n\nstd::shared_ptr<Ndt3Interface::MapMatrixArray> Ndt3TileMulti::getIntensities() const {\n  std::shared_ptr<MapMatrixArray> map_matrix_array;\n  map_matrix_array = std::shared_ptr<MapMatrixArray>(new MapMatrixArray);\n\n  for (const auto& it : *tiles_hash_) {\n    map_matrix_array->push_back(it.second->getIntensitiesInner());\n  }\n\n  return map_matrix_array;\n}\n\nbool Ndt3TileMulti::getMean(const Eigen::Vector3f& pos, Eigen::Vector3f* mean) const {\n  if (nullptr == tiles_hash_ || nullptr == tiler_) {\n    return false;\n  }\n\n  auto tile_id = tiler_->getTileID(pos);\n  auto it = tiles_hash_->find(tile_id);\n  if (tiles_hash_->end() == it) {\n    return false;\n  }\n\n  return it->second->getMean(pos, mean);\n}\n\nbool Ndt3TileMulti::getCovariance(const Eigen::Vector3f& pos, Eigen::Matrix3f* cov) const {\n  if (nullptr == tiles_hash_ || nullptr == tiler_) {\n    return false;\n  }\n\n  auto tile_id = tiler_->getTileID(pos);\n  auto it = tiles_hash_->find(tile_id);\n  if (tiles_hash_->end() == it) {\n    return false;\n  }\n\n  return it->second->getCovariance(pos, cov);\n}\n\nbool Ndt3TileMulti::getCount(const Eigen::Vector3f& pos, float* count) const {\n  if (nullptr == tiles_hash_ || nullptr == tiler_) {\n    return false;\n  }\n\n  auto tile_id = tiler_->getTileID(pos);\n  auto it = tiles_hash_->find(tile_id);\n  if (tiles_hash_->end() == it) {\n    return false;\n  }\n\n  return it->second->getCount(pos, count);\n}\n\nbool Ndt3TileMulti::getScale(const Eigen::Vector3f& pos, float* scale) const {\n  if (nullptr == tiles_hash_ || nullptr == tiler_) {\n    return false;\n  }\n\n  auto tile_id = tiler_->getTileID(pos);\n  auto it = tiles_hash_->find(tile_id);\n  if (tiles_hash_->end() == it) {\n    return false;\n  }\n\n  return it->second->getScale(pos, scale);\n}\n\nbool Ndt3TileMulti::getNormal(const Eigen::Vector3f& pos, Eigen::Vector3f* normal) const {\n  if (nullptr == tiles_hash_ || nullptr == tiler_) {\n    return false;\n  }\n\n  auto tile_id = tiler_->getTileID(pos);\n  auto it = tiles_hash_->find(tile_id);\n  if (tiles_hash_->end() == it) {\n    return false;\n  }\n\n  return it->second->getNormal(pos, normal);\n}\n\nbool Ndt3TileMulti::getEigenvalue(const Eigen::Vector3f& pos, Eigen::Vector3f* eigen) const {\n  if (nullptr == tiles_hash_ || nullptr == tiler_) {\n    return false;\n  }\n\n  auto tile_id = tiler_->getTileID(pos);\n  auto it = tiles_hash_->find(tile_id);\n  if (tiles_hash_->end() == it) {\n    return false;\n  }\n\n  return it->second->getEigenvalue(pos, eigen);\n}\n\nbool Ndt3TileMulti::getIntensity(const Eigen::Vector3f& pos, float* intensity) const {\n  if (nullptr == tiles_hash_ || nullptr == tiler_) {\n    return false;\n  }\n\n  auto tile_id = tiler_->getTileID(pos);\n  auto it = tiles_hash_->find(tile_id);\n  if (tiles_hash_->end() == it) {\n    return false;\n  }\n\n  return it->second->getIntensity(pos, intensity);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/ndt3tile_multi.cpp"
		}
	}
]
I0403 12:08:56.866765 27612 json_parser.cpp:18] 
[
	39,
	{
		"bufnr" : 14,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/ndt3tile_multi.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/eigen_types.h\"\n\n#include \"ndt3interface.h\"\n#include \"ndt3tile.h\"\n#include \"tile_cache.h\"\n#include \"tile_data_storage.h\"\n#include \"tiler.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass Ndt3TileMulti : public Ndt3Interface {\n public:\n  typedef std::unordered_map<Tiler::TileID, std::shared_ptr<Ndt3Tile>> Ndt3Hash;\n\n  /// @brief construct from a TileHash\n  Ndt3TileMulti(const std::shared_ptr<Ndt3Hash>& tiles, float tile_size);\n\n  /// @brief implemention of the Ndt3Interface::getMeans\n  std::shared_ptr<MapMatrixArray> getMeans() const override;\n\n  /// @brief implemention of the Ndt3Interface::getCovariances\n  std::shared_ptr<MapMatrixArray> getCovariances() const override;\n\n  /// @brief implemention of the Ndt3Interface::getCounts\n  std::shared_ptr<MapMatrixArray> getCounts() const override;\n\n  /// @brief implemention of the Ndt3Interface::getScales\n  std::shared_ptr<MapMatrixArray> getScales() const override;\n\n  /// @brief implemention of the Ndt3Interface::getNormals\n  std::shared_ptr<MapMatrixArray> getNormals() const override;\n\n  /// @brief implemention of the Ndt3Interface::getEigenvalues\n  std::shared_ptr<MapMatrixArray> getEigenvalues() const override;\n\n  /// @brief implemention of the Ndt3Interface::getIntensities\n  std::shared_ptr<MapMatrixArray> getIntensities() const override;\n\n  /// @brief implemention of the Ndt3Interface::getMean\n  bool getMean(const Eigen::Vector3f& pos, Eigen::Vector3f* mean) const override;\n\n  /// @brief implemention of the Ndt3Interface::getCovariance\n  bool getCovariance(const Eigen::Vector3f& pos, Eigen::Matrix3f* cov) const override;\n\n  /// @brief implemention of the Ndt3Interface::getCount\n  bool getCount(const Eigen::Vector3f& pos, float* count) const override;\n\n  /// @brief implemention of the Ndt3Interface::getScale\n  bool getScale(const Eigen::Vector3f& pos, float* scale) const override;\n\n  /// @brief implemention of the Ndt3Interface::getNormal\n  bool getNormal(const Eigen::Vector3f& pos, Eigen::Vector3f* normal) const override;\n\n  /// @brief implemention of the Ndt3Interface::getEigenvalue\n  bool getEigenvalue(const Eigen::Vector3f& pos, Eigen::Vector3f* eigen) const override;\n\n  /// @brief implemention of the Ndt3Interface::getIntensity\n  bool getIntensity(const Eigen::Vector3f& pos, float* intensity) const override;\n\n private:\n  std::shared_ptr<Ndt3Hash> tiles_hash_;  /// an std::unordered_map\n  std::unique_ptr<Tiler> tiler_;\n};\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/ndt3tile_multi.h"
		}
	}
]
I0403 12:09:03.282171 27612 json_parser.cpp:18] 
[
	40,
	{
		"bufnr" : 14,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/ndt3tile_multi.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/eigen_types.h\"\n\n#include \"ndt3interface.h\"\n#include \"ndt3tile.h\"\n#include \"tile_cache.h\"\n#include \"tile_data_storage.h\"\n#include \"tiler.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass Ndt3TileMulti : public Ndt3Interface {\n public:\n  typedef std::unordered_map<Tiler::TileID, std::shared_ptr<Ndt3Tile>> Ndt3Hash;\n\n  /// @brief construct from a TileHash\n  Ndt3TileMulti(const std::shared_ptr<Ndt3Hash>& tiles, float tile_size);\n\n  /// @brief implemention of the Ndt3Interface::getMeans\n  std::shared_ptr<MapMatrixArray> getMeans() const override;\n\n  /// @brief implemention of the Ndt3Interface::getCovariances\n  std::shared_ptr<MapMatrixArray> getCovariances() const override;\n\n  /// @brief implemention of the Ndt3Interface::getCounts\n  std::shared_ptr<MapMatrixArray> getCounts() const override;\n\n  /// @brief implemention of the Ndt3Interface::getScales\n  std::shared_ptr<MapMatrixArray> getScales() const override;\n\n  /// @brief implemention of the Ndt3Interface::getNormals\n  std::shared_ptr<MapMatrixArray> getNormals() const override;\n\n  /// @brief implemention of the Ndt3Interface::getEigenvalues\n  std::shared_ptr<MapMatrixArray> getEigenvalues() const override;\n\n  /// @brief implemention of the Ndt3Interface::getIntensities\n  std::shared_ptr<MapMatrixArray> getIntensities() const override;\n\n  /// @brief implemention of the Ndt3Interface::getMean\n  bool getMean(const Eigen::Vector3f& pos, Eigen::Vector3f* mean) const override;\n\n  /// @brief implemention of the Ndt3Interface::getCovariance\n  bool getCovariance(const Eigen::Vector3f& pos, Eigen::Matrix3f* cov) const override;\n\n  /// @brief implemention of the Ndt3Interface::getCount\n  bool getCount(const Eigen::Vector3f& pos, float* count) const override;\n\n  /// @brief implemention of the Ndt3Interface::getScale\n  bool getScale(const Eigen::Vector3f& pos, float* scale) const override;\n\n  /// @brief implemention of the Ndt3Interface::getNormal\n  bool getNormal(const Eigen::Vector3f& pos, Eigen::Vector3f* normal) const override;\n\n  /// @brief implemention of the Ndt3Interface::getEigenvalue\n  bool getEigenvalue(const Eigen::Vector3f& pos, Eigen::Vector3f* eigen) const override;\n\n  /// @brief implemention of the Ndt3Interface::getIntensity\n  bool getIntensity(const Eigen::Vector3f& pos, float* intensity) const override;\n\n private:\n  std::shared_ptr<Ndt3Hash> tiles_hash_;  /// an std::unordered_map\n  std::unique_ptr<Tiler> tiler_;\n};\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/ndt3tile_multi.h"
		}
	}
]
I0403 12:10:17.387248 27612 json_parser.cpp:18] 
[
	41,
	{
		"bufnr" : 15,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/map_layer.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include <mutex>\n#include <unordered_map>\n\n#include \"common/math/point_types.h\"\n#include \"local_database.h\"\n#include \"map_scope.h\"\n#include \"ndt3tile.h\"\n#include \"ndt3tile_multi.h\"\n#include \"tile_cache.h\"\n#include \"tile_client.h\"\n#include \"tiler.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass MapLayer {\n public:\n  /// @brief initialize the map layer\n  ///\n  /// @param layer_info[in] LayerInfo to initialize a MapLayer\n  /// @param database[in] database to be used by layer\n  ///\n  /// @return true on succeed, else false\n  bool initialize(const proto::map::MapLayerInfo& layer_info,\n                  const std::shared_ptr<LocalDatabase>& database);\n\n  /// @brief load data to cache from database\n  ///\n  /// @param[in] pos the center of the region to be loaded\n  ///\n  /// @return true on succeed, else false\n  bool load(const Eigen::Vector3f& pos);\n\n  /// @brief get all the tiles of a specific region\n  ///\n  /// @param[in] scope specify the region\n  /// @param[in] blocking if blocking is set, we will wait when cache miss happens\n  /// @param[out] tiles tile pointers stored in an unordered_map\n  ///\n  /// @return true on succeed, else false. we may fail when cache miss and blocking\n  /// is set to false\n  bool getMap(const MapScope& scope, bool blocking, std::shared_ptr<Ndt3Interface>* ndt3);\n\n  /// @brief add point cloud in to layer(when building map)\n  ///\n  /// @param pointcloud[in] point cloud to add\n  ///\n  /// @return true on succeed, else false\n  bool addPointCloud(const common::PointCloudXYZI& pointcloud);\n\n  /// @brief save to data to database\n  ///\n  /// @return true on succeed, else false\n  bool save();\n\n  /// @brief get all the ndt3tile of a layer, used when building map\n  ///\n  /// @return a const ref of the ndt3hash\n  const Ndt3TileMulti::Ndt3Hash& getAllNdt3();\n\n private:\n  bool initialized_ = false;\n  std::unique_ptr<Tiler> tiler_;\n  std::shared_ptr<TileClient> tile_client_;\n  std::unique_ptr<TileCache> tile_cache_;\n  proto::map::MapLayerInfo layer_info_;\n  Ndt3TileMulti::Ndt3Hash tile_pool_;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/map_layer.h"
		}
	}
]
I0403 12:10:25.120070 27612 json_parser.cpp:18] 
[
	42,
	{
		"bufnr" : 15,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/map_layer.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include <mutex>\n#include <unordered_map>\n\n#include \"common/math/point_types.h\"\n#include \"local_database.h\"\n#include \"map_scope.h\"\n#include \"ndt3tile.h\"\n#include \"ndt3tile_multi.h\"\n#include \"tile_cache.h\"\n#include \"tile_client.h\"\n#include \"tiler.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass MapLayer {\n public:\n  /// @brief initialize the map layer\n  ///\n  /// @param layer_info[in] LayerInfo to initialize a MapLayer\n  /// @param database[in] database to be used by layer\n  ///\n  /// @return true on succeed, else false\n  bool initialize(const proto::map::MapLayerInfo& layer_info,\n                  const std::shared_ptr<LocalDatabase>& database);\n\n  /// @brief load data to cache from database\n  ///\n  /// @param[in] pos the center of the region to be loaded\n  ///\n  /// @return true on succeed, else false\n  bool load(const Eigen::Vector3f& pos);\n\n  /// @brief get all the tiles of a specific region\n  ///\n  /// @param[in] scope specify the region\n  /// @param[in] blocking if blocking is set, we will wait when cache miss happens\n  /// @param[out] tiles tile pointers stored in an unordered_map\n  ///\n  /// @return true on succeed, else false. we may fail when cache miss and blocking\n  /// is set to false\n  bool getMap(const MapScope& scope, bool blocking, std::shared_ptr<Ndt3Interface>* ndt3);\n\n  /// @brief add point cloud in to layer(when building map)\n  ///\n  /// @param pointcloud[in] point cloud to add\n  ///\n  /// @return true on succeed, else false\n  bool addPointCloud(const common::PointCloudXYZI& pointcloud);\n\n  /// @brief save to data to database\n  ///\n  /// @return true on succeed, else false\n  bool save();\n\n  /// @brief get all the ndt3tile of a layer, used when building map\n  ///\n  /// @return a const ref of the ndt3hash\n  const Ndt3TileMulti::Ndt3Hash& getAllNdt3();\n\n private:\n  bool initialized_ = false;\n  std::unique_ptr<Tiler> tiler_;\n  std::shared_ptr<TileClient> tile_client_;\n  std::unique_ptr<TileCache> tile_cache_;\n  proto::map::MapLayerInfo layer_info_;\n  Ndt3TileMulti::Ndt3Hash tile_pool_;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/map_layer.h"
		}
	}
]
I0403 12:10:25.185375 27612 json_parser.cpp:18] 
[
	43,
	{
		"bufnr" : 9,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/map_layer.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#include <future>\n\n#include \"lidar_map_offline.h\"\n#include \"map_layer.h\"\n#include \"ndt3tile.h\"\n#include \"ndt3tile_multi.h\"\n#include \"tile_scope.h\"\n\nnamespace allride {\nnamespace mapping {\n\nbool MapLayer::initialize(const proto::map::MapLayerInfo& layer_info,\n                          const std::shared_ptr<LocalDatabase>& database) {\n  tile_client_ = std::shared_ptr<TileClient>(new TileClient(layer_info.layer_id(), database));\n  if (!tile_client_) {\n    return false;\n  }\n\n  tile_cache_ = std::unique_ptr<TileCache>(new TileCache(\n      LidarMapOffline::getCacheRange(), LidarMapOffline::getCacheMargin(), tile_client_));\n  if (!tile_cache_) {\n    return false;\n  }\n\n  tiler_ = std::unique_ptr<Tiler>(new Tiler(layer_info.tile_size()));\n  if (!tiler_) {\n    return false;\n  }\n\n  layer_info_.CopyFrom(layer_info);\n\n  initialized_ = true;\n\n  return true;\n}\n\nbool MapLayer::load(const Eigen::Vector3f& pos) {\n  if (!initialized_) {\n    return false;\n  }\n\n  return tile_cache_->load(tiler_->getTileID(pos));\n}\n\nbool MapLayer::getMap(const MapScope& scope, bool blocking, std::shared_ptr<Ndt3Interface>* ndt3) {\n  if (!initialized_) {\n    return false;\n  }\n\n  if (nullptr == ndt3) {\n    return false;\n  }\n\n  bool ret;\n  std::shared_ptr<TileCache::TileStorageHash> tiles;\n  ret = tile_cache_->getTiles(TileScope(scope, layer_info_.tile_size()), blocking, &tiles);\n\n  // what we got in tiles is a map of TileStorageData, need to transform to Ndt3Tile\n  std::shared_ptr<Ndt3TileMulti::Ndt3Hash> ndt3_tiles =\n      std::shared_ptr<Ndt3TileMulti::Ndt3Hash>(new Ndt3TileMulti::Ndt3Hash);\n  for (const auto& id_and_tile : *tiles) {\n    ndt3_tiles->insert(std::make_pair(\n        id_and_tile.first,\n        std::shared_ptr<Ndt3Tile>(new Ndt3Tile(layer_info_.grid_size(), id_and_tile.second))));\n  }\n\n  *ndt3 = std::shared_ptr<Ndt3TileMulti>(new Ndt3TileMulti(ndt3_tiles, layer_info_.tile_size()));\n\n  return ret;\n}\n\nbool MapLayer::addPointCloud(const common::PointCloudXYZI& pointcloud) {\n  if (!initialized_) {\n    return false;\n  }\n\n  for (const auto& sample : pointcloud) {\n    Tiler::TileID tile_id = tiler_->getTileID(Eigen::Vector3f(sample.x, sample.y, sample.z));\n    auto it = tile_pool_.find(tile_id);\n    std::shared_ptr<Ndt3Tile> tile;\n    if (tile_pool_.end() == it) {\n      tile = std::shared_ptr<Ndt3Tile>(new Ndt3Tile(layer_info_.grid_size()));\n      tile_pool_[tile_id] = tile;\n    } else {\n      tile = it->second;\n    }\n\n    tile->addSample(sample);\n  }\n\n  return true;\n}\n\nbool MapLayer::save() {\n  if (!initialized_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (const auto& pair : tile_pool_) {\n    pair.second->computeAllNormalsAndEigenvalues(0.02);\n    ret &= tile_client_->put(pair.first, pair.second->getStorage());\n  }\n\n  return ret;\n}\n\nconst Ndt3TileMulti::Ndt3Hash& MapLayer::getAllNdt3() { return tile_pool_; }\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/map_layer.cpp"
		}
	}
]
I0403 12:10:27.396917 27612 json_parser.cpp:18] 
[
	44,
	{
		"bufnr" : 9,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/map_layer.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#include <future>\n\n#include \"lidar_map_offline.h\"\n#include \"map_layer.h\"\n#include \"ndt3tile.h\"\n#include \"ndt3tile_multi.h\"\n#include \"tile_scope.h\"\n\nnamespace allride {\nnamespace mapping {\n\nbool MapLayer::initialize(const proto::map::MapLayerInfo& layer_info,\n                          const std::shared_ptr<LocalDatabase>& database) {\n  tile_client_ = std::shared_ptr<TileClient>(new TileClient(layer_info.layer_id(), database));\n  if (!tile_client_) {\n    return false;\n  }\n\n  tile_cache_ = std::unique_ptr<TileCache>(new TileCache(\n      LidarMapOffline::getCacheRange(), LidarMapOffline::getCacheMargin(), tile_client_));\n  if (!tile_cache_) {\n    return false;\n  }\n\n  tiler_ = std::unique_ptr<Tiler>(new Tiler(layer_info.tile_size()));\n  if (!tiler_) {\n    return false;\n  }\n\n  layer_info_.CopyFrom(layer_info);\n\n  initialized_ = true;\n\n  return true;\n}\n\nbool MapLayer::load(const Eigen::Vector3f& pos) {\n  if (!initialized_) {\n    return false;\n  }\n\n  return tile_cache_->load(tiler_->getTileID(pos));\n}\n\nbool MapLayer::getMap(const MapScope& scope, bool blocking, std::shared_ptr<Ndt3Interface>* ndt3) {\n  if (!initialized_) {\n    return false;\n  }\n\n  if (nullptr == ndt3) {\n    return false;\n  }\n\n  bool ret;\n  std::shared_ptr<TileCache::TileStorageHash> tiles;\n  ret = tile_cache_->getTiles(TileScope(scope, layer_info_.tile_size()), blocking, &tiles);\n\n  // what we got in tiles is a map of TileStorageData, need to transform to Ndt3Tile\n  std::shared_ptr<Ndt3TileMulti::Ndt3Hash> ndt3_tiles =\n      std::shared_ptr<Ndt3TileMulti::Ndt3Hash>(new Ndt3TileMulti::Ndt3Hash);\n  for (const auto& id_and_tile : *tiles) {\n    ndt3_tiles->insert(std::make_pair(\n        id_and_tile.first,\n        std::shared_ptr<Ndt3Tile>(new Ndt3Tile(layer_info_.grid_size(), id_and_tile.second))));\n  }\n\n  *ndt3 = std::shared_ptr<Ndt3TileMulti>(new Ndt3TileMulti(ndt3_tiles, layer_info_.tile_size()));\n\n  return ret;\n}\n\nbool MapLayer::addPointCloud(const common::PointCloudXYZI& pointcloud) {\n  if (!initialized_) {\n    return false;\n  }\n\n  for (const auto& sample : pointcloud) {\n    Tiler::TileID tile_id = tiler_->getTileID(Eigen::Vector3f(sample.x, sample.y, sample.z));\n    auto it = tile_pool_.find(tile_id);\n    std::shared_ptr<Ndt3Tile> tile;\n    if (tile_pool_.end() == it) {\n      tile = std::shared_ptr<Ndt3Tile>(new Ndt3Tile(layer_info_.grid_size()));\n      tile_pool_[tile_id] = tile;\n    } else {\n      tile = it->second;\n    }\n\n    tile->addSample(sample);\n  }\n\n  return true;\n}\n\nbool MapLayer::save() {\n  if (!initialized_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (const auto& pair : tile_pool_) {\n    pair.second->computeAllNormalsAndEigenvalues(0.02);\n    ret &= tile_client_->put(pair.first, pair.second->getStorage());\n  }\n\n  return ret;\n}\n\nconst Ndt3TileMulti::Ndt3Hash& MapLayer::getAllNdt3() { return tile_pool_; }\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/map_layer.cpp"
		}
	}
]
I0403 12:10:27.483389 27612 json_parser.cpp:18] 
[
	45,
	{
		"bufnr" : 15,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/map_layer.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include <mutex>\n#include <unordered_map>\n\n#include \"common/math/point_types.h\"\n#include \"local_database.h\"\n#include \"map_scope.h\"\n#include \"ndt3tile.h\"\n#include \"ndt3tile_multi.h\"\n#include \"tile_cache.h\"\n#include \"tile_client.h\"\n#include \"tiler.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass MapLayer {\n public:\n  /// @brief initialize the map layer\n  ///\n  /// @param layer_info[in] LayerInfo to initialize a MapLayer\n  /// @param database[in] database to be used by layer\n  ///\n  /// @return true on succeed, else false\n  bool initialize(const proto::map::MapLayerInfo& layer_info,\n                  const std::shared_ptr<LocalDatabase>& database);\n\n  /// @brief load data to cache from database\n  ///\n  /// @param[in] pos the center of the region to be loaded\n  ///\n  /// @return true on succeed, else false\n  bool load(const Eigen::Vector3f& pos);\n\n  /// @brief get all the tiles of a specific region\n  ///\n  /// @param[in] scope specify the region\n  /// @param[in] blocking if blocking is set, we will wait when cache miss happens\n  /// @param[out] tiles tile pointers stored in an unordered_map\n  ///\n  /// @return true on succeed, else false. we may fail when cache miss and blocking\n  /// is set to false\n  bool getMap(const MapScope& scope, bool blocking, std::shared_ptr<Ndt3Interface>* ndt3);\n\n  /// @brief add point cloud in to layer(when building map)\n  ///\n  /// @param pointcloud[in] point cloud to add\n  ///\n  /// @return true on succeed, else false\n  bool addPointCloud(const common::PointCloudXYZI& pointcloud);\n\n  /// @brief save to data to database\n  ///\n  /// @return true on succeed, else false\n  bool save();\n\n  /// @brief get all the ndt3tile of a layer, used when building map\n  ///\n  /// @return a const ref of the ndt3hash\n  const Ndt3TileMulti::Ndt3Hash& getAllNdt3();\n\n private:\n  bool initialized_ = false;\n  std::unique_ptr<Tiler> tiler_;\n  std::shared_ptr<TileClient> tile_client_;\n  std::unique_ptr<TileCache> tile_cache_;\n  proto::map::MapLayerInfo layer_info_;\n  Ndt3TileMulti::Ndt3Hash tile_pool_;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/map_layer.h"
		}
	}
]
I0403 12:10:29.544934 27612 json_parser.cpp:18] 
[
	46,
	{
		"bufnr" : 15,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/map_layer.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include <mutex>\n#include <unordered_map>\n\n#include \"common/math/point_types.h\"\n#include \"local_database.h\"\n#include \"map_scope.h\"\n#include \"ndt3tile.h\"\n#include \"ndt3tile_multi.h\"\n#include \"tile_cache.h\"\n#include \"tile_client.h\"\n#include \"tiler.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass MapLayer {\n public:\n  /// @brief initialize the map layer\n  ///\n  /// @param layer_info[in] LayerInfo to initialize a MapLayer\n  /// @param database[in] database to be used by layer\n  ///\n  /// @return true on succeed, else false\n  bool initialize(const proto::map::MapLayerInfo& layer_info,\n                  const std::shared_ptr<LocalDatabase>& database);\n\n  /// @brief load data to cache from database\n  ///\n  /// @param[in] pos the center of the region to be loaded\n  ///\n  /// @return true on succeed, else false\n  bool load(const Eigen::Vector3f& pos);\n\n  /// @brief get all the tiles of a specific region\n  ///\n  /// @param[in] scope specify the region\n  /// @param[in] blocking if blocking is set, we will wait when cache miss happens\n  /// @param[out] tiles tile pointers stored in an unordered_map\n  ///\n  /// @return true on succeed, else false. we may fail when cache miss and blocking\n  /// is set to false\n  bool getMap(const MapScope& scope, bool blocking, std::shared_ptr<Ndt3Interface>* ndt3);\n\n  /// @brief add point cloud in to layer(when building map)\n  ///\n  /// @param pointcloud[in] point cloud to add\n  ///\n  /// @return true on succeed, else false\n  bool addPointCloud(const common::PointCloudXYZI& pointcloud);\n\n  /// @brief save to data to database\n  ///\n  /// @return true on succeed, else false\n  bool save();\n\n  /// @brief get all the ndt3tile of a layer, used when building map\n  ///\n  /// @return a const ref of the ndt3hash\n  const Ndt3TileMulti::Ndt3Hash& getAllNdt3();\n\n private:\n  bool initialized_ = false;\n  std::unique_ptr<Tiler> tiler_;\n  std::shared_ptr<TileClient> tile_client_;\n  std::unique_ptr<TileCache> tile_cache_;\n  proto::map::MapLayerInfo layer_info_;\n  Ndt3TileMulti::Ndt3Hash tile_pool_;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/map_layer.h"
		}
	}
]
I0403 12:10:29.605479 27612 json_parser.cpp:18] 
[
	47,
	{
		"bufnr" : 13,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/ndt3interface.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/eigen_types.h\"\n#include \"tile_data_storage.h\"\n\nnamespace allride {\nnamespace mapping {\n\n/// @brief Define the interface to utilize the Ndt3Data(s).\nclass Ndt3Interface {\n public:\n  typedef std::vector<TileDataStorage::MapMatrix,\n                      Eigen::aligned_allocator<TileDataStorage::MapMatrix>>\n      MapMatrixArray;\n\n  /// @brief get the means of all existing grids in the Ndt3Data(s)\n  ///\n  /// @return an array of the means stored in an Eigen::map\n  virtual std::shared_ptr<MapMatrixArray> getMeans() const = 0;\n\n  /// @brief get the covariances of all existing grids in the Ndt3Data(s)\n  ///\n  /// @return an array of the covariances stored in an Eigen::map\n  virtual std::shared_ptr<MapMatrixArray> getCovariances() const = 0;\n\n  /// @brief get the counts of all existing grids in the Ndt3Data(s)\n  ///\n  /// @return an array of the counts stored in an Eigen::map\n  virtual std::shared_ptr<MapMatrixArray> getCounts() const = 0;\n\n  /// @brief get the scales of all existing grids in the Ndt3Data(s)\n  ///\n  /// @return an array of the scales stored in an Eigen::map\n  virtual std::shared_ptr<MapMatrixArray> getScales() const = 0;\n\n  /// @brief get the normals of all existing grids in the Ndt3Data(s)\n  ///\n  /// @return an array of the normals stored in an Eigen::map\n  virtual std::shared_ptr<MapMatrixArray> getNormals() const = 0;\n\n  /// @brief get the eigen values of all existing grids in the Ndt3Data(s)\n  ///\n  /// @return an array of the eigen values stored in an Eigen::map\n  virtual std::shared_ptr<MapMatrixArray> getEigenvalues() const = 0;\n\n  /// @brief get the intensities of all existing grids in the Ndt3Data(s)\n  ///\n  /// @return an array of the intensities stored in an Eigen::map\n  virtual std::shared_ptr<MapMatrixArray> getIntensities() const = 0;\n\n  /// @brief get the mean of a grid specified by a position\n  ///\n  /// @param[in] pos the point which the querying grid contains\n  /// @param[out] mean stores the mean got\n  ///\n  /// @return true if the querying grid exists, else false\n  virtual bool getMean(const Eigen::Vector3f& pos, Eigen::Vector3f* mean) const = 0;\n\n  /// @brief get the covariance of a grid specified by a position\n  ///\n  /// @param[in] pos the point which the querying grid contains\n  /// @param[out] cov stores the covariance got\n  ///\n  /// @return true if the querying grid exists, else false\n  virtual bool getCovariance(const Eigen::Vector3f& pos, Eigen::Matrix3f* cov) const = 0;\n\n  /// @brief get the covariance of a grid specified by a position\n  ///\n  /// @param[in] pos the point which the querying grid contains\n  /// @param[out] cov stores the covariance got\n  ///\n  /// @return true if the querying grid exists, else false\n  virtual bool getCount(const Eigen::Vector3f& pos, float* count) const = 0;\n\n  /// @brief get the covariance of a grid specified by a position\n  ///\n  /// @param[in] pos the point which the querying grid contains\n  /// @param[out] cov stores the covariance got\n  ///\n  /// @return true if the querying grid exists, else false\n  virtual bool getScale(const Eigen::Vector3f& pos, float* scale) const = 0;\n\n  /// @brief get the normal of a grid specified by a position\n  ///\n  /// @param[in] pos the point which the querying grid contains\n  /// @param[out] cov stores the normal got\n  ///\n  /// @return true if the querying grid exists, else false\n  virtual bool getNormal(const Eigen::Vector3f& pos, Eigen::Vector3f* normal) const = 0;\n\n  /// @brief get the eigen value of a grid specified by a position\n  ///\n  /// @param[in] pos the point which the querying grid contains\n  /// @param[out] cov stores the eigen value got\n  ///\n  /// @return true if the querying grid exists, else false\n  virtual bool getEigenvalue(const Eigen::Vector3f& pos, Eigen::Vector3f* eigen) const = 0;\n\n  /// @brief get the intensity of a grid specified by a position\n  ///\n  /// @param[in] pos the point which the querying grid contains\n  /// @param[out] cov stores the intensity got\n  ///\n  /// @return true if the querying grid exists, else false\n  virtual bool getIntensity(const Eigen::Vector3f& pos, float* intensity) const = 0;\n};\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/ndt3interface.h"
		}
	}
]
I0403 12:10:31.982924 27612 json_parser.cpp:18] 
[
	48,
	{
		"bufnr" : 13,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/ndt3interface.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/eigen_types.h\"\n#include \"tile_data_storage.h\"\n\nnamespace allride {\nnamespace mapping {\n\n/// @brief Define the interface to utilize the Ndt3Data(s).\nclass Ndt3Interface {\n public:\n  typedef std::vector<TileDataStorage::MapMatrix,\n                      Eigen::aligned_allocator<TileDataStorage::MapMatrix>>\n      MapMatrixArray;\n\n  /// @brief get the means of all existing grids in the Ndt3Data(s)\n  ///\n  /// @return an array of the means stored in an Eigen::map\n  virtual std::shared_ptr<MapMatrixArray> getMeans() const = 0;\n\n  /// @brief get the covariances of all existing grids in the Ndt3Data(s)\n  ///\n  /// @return an array of the covariances stored in an Eigen::map\n  virtual std::shared_ptr<MapMatrixArray> getCovariances() const = 0;\n\n  /// @brief get the counts of all existing grids in the Ndt3Data(s)\n  ///\n  /// @return an array of the counts stored in an Eigen::map\n  virtual std::shared_ptr<MapMatrixArray> getCounts() const = 0;\n\n  /// @brief get the scales of all existing grids in the Ndt3Data(s)\n  ///\n  /// @return an array of the scales stored in an Eigen::map\n  virtual std::shared_ptr<MapMatrixArray> getScales() const = 0;\n\n  /// @brief get the normals of all existing grids in the Ndt3Data(s)\n  ///\n  /// @return an array of the normals stored in an Eigen::map\n  virtual std::shared_ptr<MapMatrixArray> getNormals() const = 0;\n\n  /// @brief get the eigen values of all existing grids in the Ndt3Data(s)\n  ///\n  /// @return an array of the eigen values stored in an Eigen::map\n  virtual std::shared_ptr<MapMatrixArray> getEigenvalues() const = 0;\n\n  /// @brief get the intensities of all existing grids in the Ndt3Data(s)\n  ///\n  /// @return an array of the intensities stored in an Eigen::map\n  virtual std::shared_ptr<MapMatrixArray> getIntensities() const = 0;\n\n  /// @brief get the mean of a grid specified by a position\n  ///\n  /// @param[in] pos the point which the querying grid contains\n  /// @param[out] mean stores the mean got\n  ///\n  /// @return true if the querying grid exists, else false\n  virtual bool getMean(const Eigen::Vector3f& pos, Eigen::Vector3f* mean) const = 0;\n\n  /// @brief get the covariance of a grid specified by a position\n  ///\n  /// @param[in] pos the point which the querying grid contains\n  /// @param[out] cov stores the covariance got\n  ///\n  /// @return true if the querying grid exists, else false\n  virtual bool getCovariance(const Eigen::Vector3f& pos, Eigen::Matrix3f* cov) const = 0;\n\n  /// @brief get the covariance of a grid specified by a position\n  ///\n  /// @param[in] pos the point which the querying grid contains\n  /// @param[out] cov stores the covariance got\n  ///\n  /// @return true if the querying grid exists, else false\n  virtual bool getCount(const Eigen::Vector3f& pos, float* count) const = 0;\n\n  /// @brief get the covariance of a grid specified by a position\n  ///\n  /// @param[in] pos the point which the querying grid contains\n  /// @param[out] cov stores the covariance got\n  ///\n  /// @return true if the querying grid exists, else false\n  virtual bool getScale(const Eigen::Vector3f& pos, float* scale) const = 0;\n\n  /// @brief get the normal of a grid specified by a position\n  ///\n  /// @param[in] pos the point which the querying grid contains\n  /// @param[out] cov stores the normal got\n  ///\n  /// @return true if the querying grid exists, else false\n  virtual bool getNormal(const Eigen::Vector3f& pos, Eigen::Vector3f* normal) const = 0;\n\n  /// @brief get the eigen value of a grid specified by a position\n  ///\n  /// @param[in] pos the point which the querying grid contains\n  /// @param[out] cov stores the eigen value got\n  ///\n  /// @return true if the querying grid exists, else false\n  virtual bool getEigenvalue(const Eigen::Vector3f& pos, Eigen::Vector3f* eigen) const = 0;\n\n  /// @brief get the intensity of a grid specified by a position\n  ///\n  /// @param[in] pos the point which the querying grid contains\n  /// @param[out] cov stores the intensity got\n  ///\n  /// @return true if the querying grid exists, else false\n  virtual bool getIntensity(const Eigen::Vector3f& pos, float* intensity) const = 0;\n};\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/ndt3interface.h"
		}
	}
]
I0403 12:10:42.882594 27612 json_parser.cpp:18] 
[
	49,
	{
		"bufnr" : 10,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/ndt3tile_multi.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#include \"ndt3tile_multi.h\"\n\nnamespace allride {\nnamespace mapping {\n\nNdt3TileMulti::Ndt3TileMulti(const std::shared_ptr<Ndt3Hash>& tiles, float tile_size) {\n  tiles_hash_ = tiles;\n  tiler_ = std::unique_ptr<Tiler>(new Tiler(tile_size));\n}\n\nstd::shared_ptr<Ndt3Interface::MapMatrixArray> Ndt3TileMulti::getMeans() const {\n  std::shared_ptr<MapMatrixArray> map_matrix_array;\n  map_matrix_array = std::shared_ptr<MapMatrixArray>(new MapMatrixArray);\n\n  for (const auto& it : *tiles_hash_) {\n    map_matrix_array->push_back(it.second->getMeansInner());\n  }\n\n  return map_matrix_array;\n}\n\nstd::shared_ptr<Ndt3Interface::MapMatrixArray> Ndt3TileMulti::getCovariances() const {\n  std::shared_ptr<MapMatrixArray> map_matrix_array;\n  map_matrix_array = std::shared_ptr<MapMatrixArray>(new MapMatrixArray);\n\n  for (const auto& it : *tiles_hash_) {\n    map_matrix_array->push_back(it.second->getCovariancesInner());\n  }\n\n  return map_matrix_array;\n}\n\nstd::shared_ptr<Ndt3Interface::MapMatrixArray> Ndt3TileMulti::getCounts() const {\n  std::shared_ptr<MapMatrixArray> map_matrix_array;\n  map_matrix_array = std::shared_ptr<MapMatrixArray>(new MapMatrixArray);\n\n  for (const auto& it : *tiles_hash_) {\n    map_matrix_array->push_back(it.second->getCountsInner());\n  }\n\n  return map_matrix_array;\n}\n\nstd::shared_ptr<Ndt3Interface::MapMatrixArray> Ndt3TileMulti::getScales() const {\n  std::shared_ptr<MapMatrixArray> map_matrix_array;\n  map_matrix_array = std::shared_ptr<MapMatrixArray>(new MapMatrixArray);\n\n  for (const auto& it : *tiles_hash_) {\n    map_matrix_array->push_back(it.second->getScalesInner());\n  }\n\n  return map_matrix_array;\n}\n\nstd::shared_ptr<Ndt3Interface::MapMatrixArray> Ndt3TileMulti::getNormals() const {\n  std::shared_ptr<MapMatrixArray> map_matrix_array;\n  map_matrix_array = std::shared_ptr<MapMatrixArray>(new MapMatrixArray);\n\n  for (const auto& it : *tiles_hash_) {\n    map_matrix_array->push_back(it.second->getNormalsInner());\n  }\n\n  return map_matrix_array;\n}\n\nstd::shared_ptr<Ndt3Interface::MapMatrixArray> Ndt3TileMulti::getEigenvalues() const {\n  std::shared_ptr<MapMatrixArray> map_matrix_array;\n  map_matrix_array = std::shared_ptr<MapMatrixArray>(new MapMatrixArray);\n\n  for (const auto& it : *tiles_hash_) {\n    map_matrix_array->push_back(it.second->getEigenvaluesInner());\n  }\n\n  return map_matrix_array;\n}\n\nstd::shared_ptr<Ndt3Interface::MapMatrixArray> Ndt3TileMulti::getIntensities() const {\n  std::shared_ptr<MapMatrixArray> map_matrix_array;\n  map_matrix_array = std::shared_ptr<MapMatrixArray>(new MapMatrixArray);\n\n  for (const auto& it : *tiles_hash_) {\n    map_matrix_array->push_back(it.second->getIntensitiesInner());\n  }\n\n  return map_matrix_array;\n}\n\nbool Ndt3TileMulti::getMean(const Eigen::Vector3f& pos, Eigen::Vector3f* mean) const {\n  if (nullptr == tiles_hash_ || nullptr == tiler_) {\n    return false;\n  }\n\n  auto tile_id = tiler_->getTileID(pos);\n  auto it = tiles_hash_->find(tile_id);\n  if (tiles_hash_->end() == it) {\n    return false;\n  }\n\n  return it->second->getMean(pos, mean);\n}\n\nbool Ndt3TileMulti::getCovariance(const Eigen::Vector3f& pos, Eigen::Matrix3f* cov) const {\n  if (nullptr == tiles_hash_ || nullptr == tiler_) {\n    return false;\n  }\n\n  auto tile_id = tiler_->getTileID(pos);\n  auto it = tiles_hash_->find(tile_id);\n  if (tiles_hash_->end() == it) {\n    return false;\n  }\n\n  return it->second->getCovariance(pos, cov);\n}\n\nbool Ndt3TileMulti::getCount(const Eigen::Vector3f& pos, float* count) const {\n  if (nullptr == tiles_hash_ || nullptr == tiler_) {\n    return false;\n  }\n\n  auto tile_id = tiler_->getTileID(pos);\n  auto it = tiles_hash_->find(tile_id);\n  if (tiles_hash_->end() == it) {\n    return false;\n  }\n\n  return it->second->getCount(pos, count);\n}\n\nbool Ndt3TileMulti::getScale(const Eigen::Vector3f& pos, float* scale) const {\n  if (nullptr == tiles_hash_ || nullptr == tiler_) {\n    return false;\n  }\n\n  auto tile_id = tiler_->getTileID(pos);\n  auto it = tiles_hash_->find(tile_id);\n  if (tiles_hash_->end() == it) {\n    return false;\n  }\n\n  return it->second->getScale(pos, scale);\n}\n\nbool Ndt3TileMulti::getNormal(const Eigen::Vector3f& pos, Eigen::Vector3f* normal) const {\n  if (nullptr == tiles_hash_ || nullptr == tiler_) {\n    return false;\n  }\n\n  auto tile_id = tiler_->getTileID(pos);\n  auto it = tiles_hash_->find(tile_id);\n  if (tiles_hash_->end() == it) {\n    return false;\n  }\n\n  return it->second->getNormal(pos, normal);\n}\n\nbool Ndt3TileMulti::getEigenvalue(const Eigen::Vector3f& pos, Eigen::Vector3f* eigen) const {\n  if (nullptr == tiles_hash_ || nullptr == tiler_) {\n    return false;\n  }\n\n  auto tile_id = tiler_->getTileID(pos);\n  auto it = tiles_hash_->find(tile_id);\n  if (tiles_hash_->end() == it) {\n    return false;\n  }\n\n  return it->second->getEigenvalue(pos, eigen);\n}\n\nbool Ndt3TileMulti::getIntensity(const Eigen::Vector3f& pos, float* intensity) const {\n  if (nullptr == tiles_hash_ || nullptr == tiler_) {\n    return false;\n  }\n\n  auto tile_id = tiler_->getTileID(pos);\n  auto it = tiles_hash_->find(tile_id);\n  if (tiles_hash_->end() == it) {\n    return false;\n  }\n\n  return it->second->getIntensity(pos, intensity);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/ndt3tile_multi.cpp"
		}
	}
]
I0403 12:10:46.342073 27612 json_parser.cpp:18] 
[
	50,
	{
		"bufnr" : 10,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/ndt3tile_multi.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#include \"ndt3tile_multi.h\"\n\nnamespace allride {\nnamespace mapping {\n\nNdt3TileMulti::Ndt3TileMulti(const std::shared_ptr<Ndt3Hash>& tiles, float tile_size) {\n  tiles_hash_ = tiles;\n  tiler_ = std::unique_ptr<Tiler>(new Tiler(tile_size));\n}\n\nstd::shared_ptr<Ndt3Interface::MapMatrixArray> Ndt3TileMulti::getMeans() const {\n  std::shared_ptr<MapMatrixArray> map_matrix_array;\n  map_matrix_array = std::shared_ptr<MapMatrixArray>(new MapMatrixArray);\n\n  for (const auto& it : *tiles_hash_) {\n    map_matrix_array->push_back(it.second->getMeansInner());\n  }\n\n  return map_matrix_array;\n}\n\nstd::shared_ptr<Ndt3Interface::MapMatrixArray> Ndt3TileMulti::getCovariances() const {\n  std::shared_ptr<MapMatrixArray> map_matrix_array;\n  map_matrix_array = std::shared_ptr<MapMatrixArray>(new MapMatrixArray);\n\n  for (const auto& it : *tiles_hash_) {\n    map_matrix_array->push_back(it.second->getCovariancesInner());\n  }\n\n  return map_matrix_array;\n}\n\nstd::shared_ptr<Ndt3Interface::MapMatrixArray> Ndt3TileMulti::getCounts() const {\n  std::shared_ptr<MapMatrixArray> map_matrix_array;\n  map_matrix_array = std::shared_ptr<MapMatrixArray>(new MapMatrixArray);\n\n  for (const auto& it : *tiles_hash_) {\n    map_matrix_array->push_back(it.second->getCountsInner());\n  }\n\n  return map_matrix_array;\n}\n\nstd::shared_ptr<Ndt3Interface::MapMatrixArray> Ndt3TileMulti::getScales() const {\n  std::shared_ptr<MapMatrixArray> map_matrix_array;\n  map_matrix_array = std::shared_ptr<MapMatrixArray>(new MapMatrixArray);\n\n  for (const auto& it : *tiles_hash_) {\n    map_matrix_array->push_back(it.second->getScalesInner());\n  }\n\n  return map_matrix_array;\n}\n\nstd::shared_ptr<Ndt3Interface::MapMatrixArray> Ndt3TileMulti::getNormals() const {\n  std::shared_ptr<MapMatrixArray> map_matrix_array;\n  map_matrix_array = std::shared_ptr<MapMatrixArray>(new MapMatrixArray);\n\n  for (const auto& it : *tiles_hash_) {\n    map_matrix_array->push_back(it.second->getNormalsInner());\n  }\n\n  return map_matrix_array;\n}\n\nstd::shared_ptr<Ndt3Interface::MapMatrixArray> Ndt3TileMulti::getEigenvalues() const {\n  std::shared_ptr<MapMatrixArray> map_matrix_array;\n  map_matrix_array = std::shared_ptr<MapMatrixArray>(new MapMatrixArray);\n\n  for (const auto& it : *tiles_hash_) {\n    map_matrix_array->push_back(it.second->getEigenvaluesInner());\n  }\n\n  return map_matrix_array;\n}\n\nstd::shared_ptr<Ndt3Interface::MapMatrixArray> Ndt3TileMulti::getIntensities() const {\n  std::shared_ptr<MapMatrixArray> map_matrix_array;\n  map_matrix_array = std::shared_ptr<MapMatrixArray>(new MapMatrixArray);\n\n  for (const auto& it : *tiles_hash_) {\n    map_matrix_array->push_back(it.second->getIntensitiesInner());\n  }\n\n  return map_matrix_array;\n}\n\nbool Ndt3TileMulti::getMean(const Eigen::Vector3f& pos, Eigen::Vector3f* mean) const {\n  if (nullptr == tiles_hash_ || nullptr == tiler_) {\n    return false;\n  }\n\n  auto tile_id = tiler_->getTileID(pos);\n  auto it = tiles_hash_->find(tile_id);\n  if (tiles_hash_->end() == it) {\n    return false;\n  }\n\n  return it->second->getMean(pos, mean);\n}\n\nbool Ndt3TileMulti::getCovariance(const Eigen::Vector3f& pos, Eigen::Matrix3f* cov) const {\n  if (nullptr == tiles_hash_ || nullptr == tiler_) {\n    return false;\n  }\n\n  auto tile_id = tiler_->getTileID(pos);\n  auto it = tiles_hash_->find(tile_id);\n  if (tiles_hash_->end() == it) {\n    return false;\n  }\n\n  return it->second->getCovariance(pos, cov);\n}\n\nbool Ndt3TileMulti::getCount(const Eigen::Vector3f& pos, float* count) const {\n  if (nullptr == tiles_hash_ || nullptr == tiler_) {\n    return false;\n  }\n\n  auto tile_id = tiler_->getTileID(pos);\n  auto it = tiles_hash_->find(tile_id);\n  if (tiles_hash_->end() == it) {\n    return false;\n  }\n\n  return it->second->getCount(pos, count);\n}\n\nbool Ndt3TileMulti::getScale(const Eigen::Vector3f& pos, float* scale) const {\n  if (nullptr == tiles_hash_ || nullptr == tiler_) {\n    return false;\n  }\n\n  auto tile_id = tiler_->getTileID(pos);\n  auto it = tiles_hash_->find(tile_id);\n  if (tiles_hash_->end() == it) {\n    return false;\n  }\n\n  return it->second->getScale(pos, scale);\n}\n\nbool Ndt3TileMulti::getNormal(const Eigen::Vector3f& pos, Eigen::Vector3f* normal) const {\n  if (nullptr == tiles_hash_ || nullptr == tiler_) {\n    return false;\n  }\n\n  auto tile_id = tiler_->getTileID(pos);\n  auto it = tiles_hash_->find(tile_id);\n  if (tiles_hash_->end() == it) {\n    return false;\n  }\n\n  return it->second->getNormal(pos, normal);\n}\n\nbool Ndt3TileMulti::getEigenvalue(const Eigen::Vector3f& pos, Eigen::Vector3f* eigen) const {\n  if (nullptr == tiles_hash_ || nullptr == tiler_) {\n    return false;\n  }\n\n  auto tile_id = tiler_->getTileID(pos);\n  auto it = tiles_hash_->find(tile_id);\n  if (tiles_hash_->end() == it) {\n    return false;\n  }\n\n  return it->second->getEigenvalue(pos, eigen);\n}\n\nbool Ndt3TileMulti::getIntensity(const Eigen::Vector3f& pos, float* intensity) const {\n  if (nullptr == tiles_hash_ || nullptr == tiler_) {\n    return false;\n  }\n\n  auto tile_id = tiler_->getTileID(pos);\n  auto it = tiles_hash_->find(tile_id);\n  if (tiles_hash_->end() == it) {\n    return false;\n  }\n\n  return it->second->getIntensity(pos, intensity);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/ndt3tile_multi.cpp"
		}
	}
]
I0403 12:10:46.444732 27612 json_parser.cpp:18] 
[
	51,
	{
		"bufnr" : 14,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/ndt3tile_multi.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/eigen_types.h\"\n\n#include \"ndt3interface.h\"\n#include \"ndt3tile.h\"\n#include \"tile_cache.h\"\n#include \"tile_data_storage.h\"\n#include \"tiler.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass Ndt3TileMulti : public Ndt3Interface {\n public:\n  typedef std::unordered_map<Tiler::TileID, std::shared_ptr<Ndt3Tile>> Ndt3Hash;\n\n  /// @brief construct from a TileHash\n  Ndt3TileMulti(const std::shared_ptr<Ndt3Hash>& tiles, float tile_size);\n\n  /// @brief implemention of the Ndt3Interface::getMeans\n  std::shared_ptr<MapMatrixArray> getMeans() const override;\n\n  /// @brief implemention of the Ndt3Interface::getCovariances\n  std::shared_ptr<MapMatrixArray> getCovariances() const override;\n\n  /// @brief implemention of the Ndt3Interface::getCounts\n  std::shared_ptr<MapMatrixArray> getCounts() const override;\n\n  /// @brief implemention of the Ndt3Interface::getScales\n  std::shared_ptr<MapMatrixArray> getScales() const override;\n\n  /// @brief implemention of the Ndt3Interface::getNormals\n  std::shared_ptr<MapMatrixArray> getNormals() const override;\n\n  /// @brief implemention of the Ndt3Interface::getEigenvalues\n  std::shared_ptr<MapMatrixArray> getEigenvalues() const override;\n\n  /// @brief implemention of the Ndt3Interface::getIntensities\n  std::shared_ptr<MapMatrixArray> getIntensities() const override;\n\n  /// @brief implemention of the Ndt3Interface::getMean\n  bool getMean(const Eigen::Vector3f& pos, Eigen::Vector3f* mean) const override;\n\n  /// @brief implemention of the Ndt3Interface::getCovariance\n  bool getCovariance(const Eigen::Vector3f& pos, Eigen::Matrix3f* cov) const override;\n\n  /// @brief implemention of the Ndt3Interface::getCount\n  bool getCount(const Eigen::Vector3f& pos, float* count) const override;\n\n  /// @brief implemention of the Ndt3Interface::getScale\n  bool getScale(const Eigen::Vector3f& pos, float* scale) const override;\n\n  /// @brief implemention of the Ndt3Interface::getNormal\n  bool getNormal(const Eigen::Vector3f& pos, Eigen::Vector3f* normal) const override;\n\n  /// @brief implemention of the Ndt3Interface::getEigenvalue\n  bool getEigenvalue(const Eigen::Vector3f& pos, Eigen::Vector3f* eigen) const override;\n\n  /// @brief implemention of the Ndt3Interface::getIntensity\n  bool getIntensity(const Eigen::Vector3f& pos, float* intensity) const override;\n\n private:\n  std::shared_ptr<Ndt3Hash> tiles_hash_;  /// an std::unordered_map\n  std::unique_ptr<Tiler> tiler_;\n};\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/ndt3tile_multi.h"
		}
	}
]
I0403 12:10:48.697713 27612 json_parser.cpp:18] 
[
	52,
	{
		"bufnr" : 14,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/ndt3tile_multi.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/eigen_types.h\"\n\n#include \"ndt3interface.h\"\n#include \"ndt3tile.h\"\n#include \"tile_cache.h\"\n#include \"tile_data_storage.h\"\n#include \"tiler.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass Ndt3TileMulti : public Ndt3Interface {\n public:\n  typedef std::unordered_map<Tiler::TileID, std::shared_ptr<Ndt3Tile>> Ndt3Hash;\n\n  /// @brief construct from a TileHash\n  Ndt3TileMulti(const std::shared_ptr<Ndt3Hash>& tiles, float tile_size);\n\n  /// @brief implemention of the Ndt3Interface::getMeans\n  std::shared_ptr<MapMatrixArray> getMeans() const override;\n\n  /// @brief implemention of the Ndt3Interface::getCovariances\n  std::shared_ptr<MapMatrixArray> getCovariances() const override;\n\n  /// @brief implemention of the Ndt3Interface::getCounts\n  std::shared_ptr<MapMatrixArray> getCounts() const override;\n\n  /// @brief implemention of the Ndt3Interface::getScales\n  std::shared_ptr<MapMatrixArray> getScales() const override;\n\n  /// @brief implemention of the Ndt3Interface::getNormals\n  std::shared_ptr<MapMatrixArray> getNormals() const override;\n\n  /// @brief implemention of the Ndt3Interface::getEigenvalues\n  std::shared_ptr<MapMatrixArray> getEigenvalues() const override;\n\n  /// @brief implemention of the Ndt3Interface::getIntensities\n  std::shared_ptr<MapMatrixArray> getIntensities() const override;\n\n  /// @brief implemention of the Ndt3Interface::getMean\n  bool getMean(const Eigen::Vector3f& pos, Eigen::Vector3f* mean) const override;\n\n  /// @brief implemention of the Ndt3Interface::getCovariance\n  bool getCovariance(const Eigen::Vector3f& pos, Eigen::Matrix3f* cov) const override;\n\n  /// @brief implemention of the Ndt3Interface::getCount\n  bool getCount(const Eigen::Vector3f& pos, float* count) const override;\n\n  /// @brief implemention of the Ndt3Interface::getScale\n  bool getScale(const Eigen::Vector3f& pos, float* scale) const override;\n\n  /// @brief implemention of the Ndt3Interface::getNormal\n  bool getNormal(const Eigen::Vector3f& pos, Eigen::Vector3f* normal) const override;\n\n  /// @brief implemention of the Ndt3Interface::getEigenvalue\n  bool getEigenvalue(const Eigen::Vector3f& pos, Eigen::Vector3f* eigen) const override;\n\n  /// @brief implemention of the Ndt3Interface::getIntensity\n  bool getIntensity(const Eigen::Vector3f& pos, float* intensity) const override;\n\n private:\n  std::shared_ptr<Ndt3Hash> tiles_hash_;  /// an std::unordered_map\n  std::unique_ptr<Tiler> tiler_;\n};\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/ndt3tile_multi.h"
		}
	}
]
I0403 12:10:50.568241 27612 json_parser.cpp:18] 
[
	53,
	{
		"bufnr" : 3,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#include <fstream>\n\n#include \"common/proto/config/config_map.pb.h\"\n#include \"lidar_map.h\"\n\nnamespace allride {\nnamespace mapping {\n\nMapLayerDictionaryParser LidarMap::map_layer_dict_;\nstd::string LidarMap::database_path_;\nint LidarMap::cache_range_;\nint LidarMap::cache_margin_;\n\nbool LidarMap::configure(const std::string& config_file) {\n  std::ifstream map_config_ifs(config_file);\n  proto::config::ConfigMap map_config;\n  if (!map_config.ParseFromIstream(&map_config_ifs)) {\n    return false;\n  }\n\n  if (!map_layer_dict_.load(map_config.maplayer_dict_path())) {\n    return false;\n  }\n\n  database_path_ = map_config.database_path();\n\n  cache_range_ = map_config.cache_range();\n\n  cache_margin_ = map_config.cache_margin();\n\n  return true;\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map.cpp"
		}
	}
]
I0403 12:10:51.498543 27612 json_parser.cpp:18] 
[
	54,
	{
		"bufnr" : 3,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#include <fstream>\n\n#include \"common/proto/config/config_map.pb.h\"\n#include \"lidar_map.h\"\n\nnamespace allride {\nnamespace mapping {\n\nMapLayerDictionaryParser LidarMap::map_layer_dict_;\nstd::string LidarMap::database_path_;\nint LidarMap::cache_range_;\nint LidarMap::cache_margin_;\n\nbool LidarMap::configure(const std::string& config_file) {\n  std::ifstream map_config_ifs(config_file);\n  proto::config::ConfigMap map_config;\n  if (!map_config.ParseFromIstream(&map_config_ifs)) {\n    return false;\n  }\n\n  if (!map_layer_dict_.load(map_config.maplayer_dict_path())) {\n    return false;\n  }\n\n  database_path_ = map_config.database_path();\n\n  cache_range_ = map_config.cache_range();\n\n  cache_margin_ = map_config.cache_margin();\n\n  return true;\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map.cpp"
		}
	}
]
I0403 12:10:51.544667 27612 json_parser.cpp:18] 
[
	55,
	{
		"bufnr" : 5,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/point_types.h\"\n#include \"map_layer_dictionary_parser.h\"\n#include \"ndt3interface.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass LidarMap {\n public:\n  /// @brief configure the LidarMap class, mainly LayerID to resolution map, database path,\n  /// which are shared by all LidarMap and its decents\n  ///\n  /// @param config_file[in] the path to config file\n  ///\n  /// @return true on succeed, else false\n  ///\n  /// @note this should be called first before any operation about LidarMap\n  static bool configure(const std::string& config_file);\n\n  /// @brief initialize a layer before using it\n  ///\n  /// @param layer_id[in] specify which layer to initialize\n  ///\n  /// @return true on succeed, else false\n  virtual bool initializeLayer(int layer_id) = 0;\n\n  /// @brief add point to LidarMap on specific layer\n  ///\n  /// @param layer_id[in] specify which layer to add point cloud\n  /// @param pointcloud[in] the cloud point to add\n  ///\n  /// @return true on succeed, else false\n  virtual bool addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) = 0;\n\n protected:\n  static MapLayerDictionaryParser map_layer_dict_;\n  static std::string database_path_;\n  static int cache_range_;\n  static int cache_margin_;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map.h"
		}
	}
]
I0403 12:10:52.091482 27612 json_parser.cpp:18] 
[
	56,
	{
		"bufnr" : 5,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/point_types.h\"\n#include \"map_layer_dictionary_parser.h\"\n#include \"ndt3interface.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass LidarMap {\n public:\n  /// @brief configure the LidarMap class, mainly LayerID to resolution map, database path,\n  /// which are shared by all LidarMap and its decents\n  ///\n  /// @param config_file[in] the path to config file\n  ///\n  /// @return true on succeed, else false\n  ///\n  /// @note this should be called first before any operation about LidarMap\n  static bool configure(const std::string& config_file);\n\n  /// @brief initialize a layer before using it\n  ///\n  /// @param layer_id[in] specify which layer to initialize\n  ///\n  /// @return true on succeed, else false\n  virtual bool initializeLayer(int layer_id) = 0;\n\n  /// @brief add point to LidarMap on specific layer\n  ///\n  /// @param layer_id[in] specify which layer to add point cloud\n  /// @param pointcloud[in] the cloud point to add\n  ///\n  /// @return true on succeed, else false\n  virtual bool addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) = 0;\n\n protected:\n  static MapLayerDictionaryParser map_layer_dict_;\n  static std::string database_path_;\n  static int cache_range_;\n  static int cache_margin_;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map.h"
		}
	}
]
I0403 12:10:52.138013 27612 json_parser.cpp:18] 
[
	57,
	{
		"bufnr" : 6,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if (!initializeLayer(layer_id)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) {\n  auto iter = layers_.find(layer_id);\n  if (iter != layers_.end()) {\n    return iter->second;\n  } else {\n    return nullptr;\n  }\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(const std::string& type_name,\n                                                          float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return nullptr;\n  }\n  return getLayer(layer_id);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0403 12:10:52.641969 27612 json_parser.cpp:18] 
[
	58,
	{
		"bufnr" : 6,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if (!initializeLayer(layer_id)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) {\n  auto iter = layers_.find(layer_id);\n  if (iter != layers_.end()) {\n    return iter->second;\n  } else {\n    return nullptr;\n  }\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(const std::string& type_name,\n                                                          float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return nullptr;\n  }\n  return getLayer(layer_id);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0403 12:10:52.737718 27612 json_parser.cpp:18] 
[
	59,
	{
		"bufnr" : 16,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/eigen_types.h\"\n\n#include \"common/proto/config/config_map.pb.h\"\n\n#include \"lidar_map.h\"\n#include \"local_database.h\"\n#include \"map_layer.h\"\n#include \"map_scope.h\"\n#include \"ndt3interface.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass LidarMapOffline : public LidarMap {\n public:\n  /// @brief configure the LidarMapOffline class, mainly static members\n  /// which shared by all LidarMapOffline instance, such as database\n  ///\n  /// @param mode[in] specify the database operation mode, read, write, create...\n  ///\n  /// @note this should be called first before any operation about\n  /// LidarMapOffline\n  static bool configure(LocalDatabase::MODE mode);\n\n  /// @brief get the cache range(in number of tiles)\n  static int getCacheRange() { return LidarMap::cache_range_; }\n\n  /// @brief get the watermark of tile cache\n  static int getCacheMargin() { return LidarMap::cache_margin_; }\n\n  /// @brief implimention of LidarMap::initializeLayer, see LidarMap for more infomation\n  bool initializeLayer(int layer_id) override;\n\n  /// @brief initialize a layer by specify type_name, grid_size and tile\n  /// @return the layer_id of the initilized layer, if failed, a negtive number will be returned\n  int initializeLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief implimention of LidarMap::addPointCloud, see LidarMap for more infomation\n  bool addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) override;\n\n  /// @brief load the map to cache\n  /// @param[in] pos the center of the region to be loaded\n  /// @return true on succeed, else false\n  bool load(const Eigen::Vector3f& pos);\n\n  /// @brief Get the map of a layer in specific region\n  ///\n  /// @param layer_id[in] specify which layer to get\n  /// @param[in] scope specifies the submap region.\n  /// @param[in] blocking if is true, this call will block if cache miss happens,\n  /// until tiles are loaded or timeout\n  /// @param[out] ndt3 stores the map we got\n  ///\n  /// @return true on succeed, else false. we may fails when there is a cache miss\n  /// in blocking mode\n  bool getMap(int layer_id, const MapScope& scope, bool blocking,\n              std::shared_ptr<Ndt3Interface>* ndt3);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @param layer_item[in] a layer item contains nessecery infomation\n  /// to add one layer\n  ///\n  /// @return true on succeed, else false\n  bool addLayer(const proto::config::MapLayerItem& layer_item);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @return the layer id of the layer we add\n  int addLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief save the map into database\n  ///\n  /// @return true on succeed, else false\n  bool save();\n\n  /// @brief get one maplayer\n  ///\n  /// @param layer_id[in] specify which layer to get\n  ///\n  /// @return maplayer got\n  std::shared_ptr<const MapLayer> getLayer(int layer_id);\n\n  /// @brief get one maplayer\n  ///\n  /// @param type_name[in] such as ndt3_corner...\n  ///\n  /// @return map layer got\n  std::shared_ptr<const MapLayer> getLayer(const std::string& type_name, float grid_size, float tile_size);\n\n private:\n  static std::shared_ptr<LocalDatabase> database_;\n  static LocalDatabase::MODE database_operation_mode_;\n  static proto::map::MapInfo map_info_;\n\n  std::map<int, std::shared_ptr<MapLayer>> layers_;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h"
		}
	}
]
I0403 12:10:58.421845 27612 json_parser.cpp:18] 
[
	60,
	{
		"bufnr" : 7,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_online.h\"\n\nnamespace allride {\nnamespace mapping {\n\nvoid LidarMapOnline::setMapOrigin(const common::geometry::SE3& Tx_MP_map) { origin_ = Tx_MP_map; }\n\ncommon::geometry::SE3 LidarMapOnline::getMapOrigin() { return origin_; }\n\nvoid LidarMapOnline::resetMapRegion(const common::geometry::SE3& Tx_MP_V, double radius) {\n  common::geometry::SE3 Tx_delta /* = origin_.inverseCompose(Tx_MP_V) */;  // waiting for api\n\n  // first get all keys\n  std::vector<int> all_layer_ids;\n  for (const auto& pair : ndt3_pool_) {\n    all_layer_ids.emplace_back(pair.first);\n  }\n\n  // update ndt3 data of all layers\n  for (const auto& layer_id : all_layer_ids) {\n    std::shared_ptr<Ndt3Tile> new_ndt3 =\n        std::shared_ptr<Ndt3Tile>(new Ndt3Tile(map_layer_dict_.getGridSize(layer_id)));\n    ndt3_pool_[layer_id]->copyAndTransform(Tx_delta, radius, new_ndt3.get());\n    ndt3_pool_[layer_id] = new_ndt3;\n  }\n}\n\nbool LidarMapOnline::initializeLayer(int layer_id) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it != ndt3_pool_.end()) {\n    return false;  // re-initialize\n  }\n\n  float grid_size;\n  if (!map_layer_dict_.getInfoById(layer_id, nullptr, &grid_size, nullptr)) {\n    return false;\n  }\n\n  ndt3_pool_[layer_id] = std::shared_ptr<Ndt3Tile>(new Ndt3Tile(grid_size));\n\n  return true;\n}\n\nbool LidarMapOnline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  // add sample to ndt3\n  for (const auto& sample : pointcloud) {\n    ndt3_pool_it->second->addSample(sample);\n  }\n\n  return false;\n}\n\nbool LidarMapOnline::getMap(int layer_id, std::shared_ptr<Ndt3Interface>* ndt3) {\n  if (!ndt3) {\n    return false;\n  }\n\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  *ndt3 = ndt3_pool_it->second;\n  return true;\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp"
		}
	}
]
I0403 12:11:08.122596 27612 json_parser.cpp:18] 
[
	65,
	{
		"bufnr" : 7,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_online.h\"\n\nnamespace allride {\nnamespace mapping {\n\nvoid LidarMapOnline::setMapOrigin(const common::geometry::SE3& Tx_MP_map) { origin_ = Tx_MP_map; }\n\ncommon::geometry::SE3 LidarMapOnline::getMapOrigin() { return origin_; }\n\nvoid LidarMapOnline::restMapRegion(const common::geometry::SE3& Tx_MP_V, double radius) {\n  common::geometry::SE3 Tx_delta /* = origin_.inverseCompose(Tx_MP_V) */;  // waiting for api\n\n  // first get all keys\n  std::vector<int> all_layer_ids;\n  for (const auto& pair : ndt3_pool_) {\n    all_layer_ids.emplace_back(pair.first);\n  }\n\n  // update ndt3 data of all layers\n  for (const auto& layer_id : all_layer_ids) {\n    std::shared_ptr<Ndt3Tile> new_ndt3 =\n        std::shared_ptr<Ndt3Tile>(new Ndt3Tile(map_layer_dict_.getGridSize(layer_id)));\n    ndt3_pool_[layer_id]->copyAndTransform(Tx_delta, radius, new_ndt3.get());\n    ndt3_pool_[layer_id] = new_ndt3;\n  }\n}\n\nbool LidarMapOnline::initializeLayer(int layer_id) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it != ndt3_pool_.end()) {\n    return false;  // re-initialize\n  }\n\n  float grid_size;\n  if (!map_layer_dict_.getInfoById(layer_id, nullptr, &grid_size, nullptr)) {\n    return false;\n  }\n\n  ndt3_pool_[layer_id] = std::shared_ptr<Ndt3Tile>(new Ndt3Tile(grid_size));\n\n  return true;\n}\n\nbool LidarMapOnline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  // add sample to ndt3\n  for (const auto& sample : pointcloud) {\n    ndt3_pool_it->second->addSample(sample);\n  }\n\n  return false;\n}\n\nbool LidarMapOnline::getMap(int layer_id, std::shared_ptr<Ndt3Interface>* ndt3) {\n  if (!ndt3) {\n    return false;\n  }\n\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  *ndt3 = ndt3_pool_it->second;\n  return true;\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp"
		}
	}
]
I0403 12:11:10.445204 27612 json_parser.cpp:18] 
[
	66,
	{
		"bufnr" : 7,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_online.h\"\n\nnamespace allride {\nnamespace mapping {\n\nvoid LidarMapOnline::setMapOrigin(const common::geometry::SE3& Tx_MP_map) { origin_ = Tx_MP_map; }\n\ncommon::geometry::SE3 LidarMapOnline::getMapOrigin() { return origin_; }\n\nvoid LidarMapOnline::resetMapRegion(const common::geometry::SE3& Tx_MP_V, double radius) {\n  common::geometry::SE3 Tx_delta /* = origin_.inverseCompose(Tx_MP_V) */;  // waiting for api\n\n  // first get all keys\n  std::vector<int> all_layer_ids;\n  for (const auto& pair : ndt3_pool_) {\n    all_layer_ids.emplace_back(pair.first);\n  }\n\n  // update ndt3 data of all layers\n  for (const auto& layer_id : all_layer_ids) {\n    std::shared_ptr<Ndt3Tile> new_ndt3 =\n        std::shared_ptr<Ndt3Tile>(new Ndt3Tile(map_layer_dict_.getGridSize(layer_id)));\n    ndt3_pool_[layer_id]->copyAndTransform(Tx_delta, radius, new_ndt3.get());\n    ndt3_pool_[layer_id] = new_ndt3;\n  }\n}\n\nbool LidarMapOnline::initializeLayer(int layer_id) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it != ndt3_pool_.end()) {\n    return false;  // re-initialize\n  }\n\n  float grid_size;\n  if (!map_layer_dict_.getInfoById(layer_id, nullptr, &grid_size, nullptr)) {\n    return false;\n  }\n\n  ndt3_pool_[layer_id] = std::shared_ptr<Ndt3Tile>(new Ndt3Tile(grid_size));\n\n  return true;\n}\n\nbool LidarMapOnline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  // add sample to ndt3\n  for (const auto& sample : pointcloud) {\n    ndt3_pool_it->second->addSample(sample);\n  }\n\n  return false;\n}\n\nbool LidarMapOnline::getMap(int layer_id, std::shared_ptr<Ndt3Interface>* ndt3) {\n  if (!ndt3) {\n    return false;\n  }\n\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  *ndt3 = ndt3_pool_it->second;\n  return true;\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp"
		}
	}
]
I0403 12:11:11.773509 27612 json_parser.cpp:18] 
[
	67,
	{
		"bufnr" : 7,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_online.h\"\n\nnamespace allride {\nnamespace mapping {\n\nvoid LidarMapOnline::setMapOrigin(const common::geometry::SE3& Tx_MP_map) { origin_ = Tx_MP_map; }\n\ncommon::geometry::SE3 LidarMapOnline::getMapOrigin() { return origin_; }\n\nvoid LidarMapOnline:resetMapRegion(const common::geometry::SE3& Tx_MP_V, double radius) {\n  common::geometry::SE3 Tx_delta /* = origin_.inverseCompose(Tx_MP_V) */;  // waiting for api\n\n  // first get all keys\n  std::vector<int> all_layer_ids;\n  for (const auto& pair : ndt3_pool_) {\n    all_layer_ids.emplace_back(pair.first);\n  }\n\n  // update ndt3 data of all layers\n  for (const auto& layer_id : all_layer_ids) {\n    std::shared_ptr<Ndt3Tile> new_ndt3 =\n        std::shared_ptr<Ndt3Tile>(new Ndt3Tile(map_layer_dict_.getGridSize(layer_id)));\n    ndt3_pool_[layer_id]->copyAndTransform(Tx_delta, radius, new_ndt3.get());\n    ndt3_pool_[layer_id] = new_ndt3;\n  }\n}\n\nbool LidarMapOnline::initializeLayer(int layer_id) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it != ndt3_pool_.end()) {\n    return false;  // re-initialize\n  }\n\n  float grid_size;\n  if (!map_layer_dict_.getInfoById(layer_id, nullptr, &grid_size, nullptr)) {\n    return false;\n  }\n\n  ndt3_pool_[layer_id] = std::shared_ptr<Ndt3Tile>(new Ndt3Tile(grid_size));\n\n  return true;\n}\n\nbool LidarMapOnline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  // add sample to ndt3\n  for (const auto& sample : pointcloud) {\n    ndt3_pool_it->second->addSample(sample);\n  }\n\n  return false;\n}\n\nbool LidarMapOnline::getMap(int layer_id, std::shared_ptr<Ndt3Interface>* ndt3) {\n  if (!ndt3) {\n    return false;\n  }\n\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  *ndt3 = ndt3_pool_it->second;\n  return true;\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp"
		}
	}
]
I0403 12:11:14.874673 27612 json_parser.cpp:18] 
[
	68,
	{
		"bufnr" : 7,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/inclu