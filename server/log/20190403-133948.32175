Log file created at: 2019/04/03 13:39:48
Running on machine: mr-pc
Log line format: [IWEF]mmdd hh:mm:ss.uuuuuu threadid file:line] msg
I0403 13:39:48.796905 32175 json_parser.cpp:18] 
[
	1,
	{
		"bufnr" : 3,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All rights reserved.\n// Authors: Yongjian Zhao (yongjian.zhao@allride.ai)\n\n#include <fstream>\n#include <iostream>\n#include <sstream>\n#include <vector>\n\n#include \"common/io/proto_io.h\"\n#include \"common/proto/config/config_map.pb.h\"\n#include \"map_layer_dictionary_parser.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstatic const float grid_size_ratio = 1000.0f;  // convert from m to mm,\n\nbool MapLayerDictionaryParser::load(const std::string& dict_file) {\n  proto::config::MapLayerDictionary dict;\n  if (!common::ProtoIO::readProtoFromTextFile(dict_file, &dict)) {\n    std::cerr << \"MapLayerDictionaryParser: failed to load from dictionary file!\" << std::endl;\n    std::cerr << \"dict_file: \" << dict_file << std::endl;\n    return false;\n  }\n\n  for (const auto& item : dict.items()) {\n    int layer_id = item.layer_id();\n    std::string type_name = item.type_name();\n    float grid_size = item.grid_size();\n    float tile_size = item.tile_size();\n\n    // compose the key\n    std::string key;\n    composeKey(type_name, grid_size, tile_size, &key);\n\n    // set unordered_map\n    id_to_key_[layer_id] = key;\n    key_to_id_[key] = layer_id;\n  }\n\n  return true;\n}\n\nbool MapLayerDictionaryParser::getInfoById(const int layer_id, std::string* type_name,\n                                           float* grid_size, float* tile_size) {\n  if (id_to_key_.count(layer_id) == 0) {\n    return false;\n  }\n\n  analyseKey(id_to_key_[layer_id], type_name, grid_size, tile_size);\n  return true;\n}\n\nbool MapLayerDictionaryParser::getIdByInfo(const std::string& type_name, const float& grid_size,\n                                           const float& tile_size, int* layer_id) {\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 0) {\n    return false;\n  }\n\n  *layer_id = key_to_id_[key];\n  return true;\n}\n\nfloat MapLayerDictionaryParser::getGridSize(const int layer_id) {\n  float grid_size;\n  getInfoById(layer_id, nullptr, &grid_size, nullptr);\n  return grid_size;\n}\n\nfloat MapLayerDictionaryParser::getTileSize(const int layer_id) {\n  float tile_size;\n  getInfoById(layer_id, nullptr, nullptr, &tile_size);\n  return tile_size;\n}\n\nstd::string MapLayerDictionaryParser::getTypeName(const int layer_id) {\n  std::string type_name;\n  getInfoById(layer_id, &type_name, nullptr, nullptr);\n  return type_name;\n}\n\nbool MapLayerDictionaryParser::addItem(const int layer_id, const std::string& type_name,\n                                       const float grid_size, const float tile_size) {\n  if (id_to_key_.count(layer_id) == 1) {\n    std::cerr << \"failed to add item: layer_id \" << layer_id << \" has already exited in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 1) {\n    std::cerr << \"failed to add item: layer configuration has already existed in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  id_to_key_[layer_id] = key;\n  key_to_id_[key] = layer_id;\n  return true;\n}\n\nbool MapLayerDictionaryParser::save(const std::string& dict_file) {\n  // sort layer id\n  std::vector<int> layer_ids;\n  for (auto& pair : id_to_key_) {\n    layer_ids.emplace_back(pair.first);\n  }\n  std::sort(layer_ids.begin(), layer_ids.end());\n\n  // add item to dict\n  proto::config::MapLayerDictionary dict;\n  for (auto& id : layer_ids) {\n    // analyze key\n    std::string type_name;\n    float grid_size;\n    float tile_size;\n    analyseKey(id_to_key_[id], &type_name, &grid_size, &tile_size);\n\n    // add item\n    proto::config::MapLayerItem* item = dict.add_items();\n    item->set_layer_id(id);\n    item->set_type_name(type_name);\n    item->set_grid_size(grid_size);\n    item->set_tile_size(tile_size);\n  }\n\n  // write dict to file\n  return common::ProtoIO::writeProtoToTextFile(dict_file, dict);\n}\n\nvoid MapLayerDictionaryParser::composeKey(const std::string& type_name, const float& grid_size,\n                                          const float& tile_size, std::string* key) {\n  std::stringstream str_stream;\n  str_stream << type_name << \"_\" << static_cast<int>(grid_size * grid_size_ratio) << \"_\"\n             << static_cast<int>(tile_size);\n  *key = str_stream.str();\n}\n\nvoid MapLayerDictionaryParser::analyseKey(const std::string& key, std::string* type_name,\n                                          float* grid_size, float* tile_size) {\n  std::vector<std::string> substrs;\n  substrs.resize(3);\n\n  // achieve sub strings from key\n  size_t tail = key.size() - 1;\n  for (int i = 0; i < 2; i++) {\n    size_t pos = key.rfind('_', tail);\n    substrs[2 - i] = key.substr(pos + 1, tail - pos);\n    tail = pos - 1;\n  }\n  substrs[0] = key.substr(0, tail + 1);\n\n  // output\n  if (tile_size != nullptr) {\n    *tile_size = std::stof(substrs[2]);\n  }\n  if (grid_size != nullptr) {\n    *grid_size = std::stof(substrs[1]) / grid_size_ratio;\n  }\n  if (type_name != nullptr) {\n    *type_name = substrs[0];\n  }\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp"
		}
	}
]
I0403 13:40:14.578069 32175 json_parser.cpp:18] 
[
	2,
	{
		"bufnr" : 3,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All rights reserved.\n// Authors: Yongjian Zhao (yongjian.zhao@allride.ai)\n\n#include <fstream>\n#include <iostream>\n#include <sstream>\n#include <vector>\n\n#include \"common/io/proto_io.h\"\n#include \"common/proto/config/config_map.pb.h\"\n#include \"map_layer_dictionary_parser.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstatic const float grid_size_ratio = 1000.0f;  // convert from m to mm,\n\nbool MapLayerDictionaryParser::load(const std::string& dict_file) {\n  proto::config::MapLayerDictionary dict;\n  if (!common::ProtoIO::readProtoFromTextFile(dict_file, &dict)) {\n    std::cerr << \"MapLayerDictionaryParser: failed to load from dictionary file!\" << std::endl;\n    std::cerr << \"dict_file: \" << dict_file << std::endl;\n    return false;\n  }\n\n  for (const auto& item : dict.items()) {\n    int layer_id = item.layer_id();\n    std::string type_name = item.type_name();\n    float grid_size = item.grid_size();\n    float tile_size = item.tile_size();\n\n    // compose the key\n    std::string key;\n    composeKey(type_name, grid_size, tile_size, &key);\n\n    // set unordered_map\n    id_to_key_[layer_id] = key;\n    key_to_id_[key] = layer_id;\n  }\n\n  return true;\n}\n\nbool MapLayerDictionaryParser::getInfoById(const int layer_id, std::string* type_name,\n                                           float* grid_size, float* tile_size) {\n  if (id_to_key_.count(layer_id) == 0) {\n    return false;\n  }\n\n  analyseKey(id_to_key_[layer_id], type_name, grid_size, tile_size);\n  return true;\n}\n\nbool MapLayerDictionaryParser::getIdByInfo(const std::string& type_name, const float& grid_size,\n                                           const float& tile_size, int* layer_id) {\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 0) {\n    return false;\n  }\n\n  *layer_id = key_to_id_[key];\n  return true;\n}\n\nfloat MapLayerDictionaryParser::getGridSize(const int layer_id) {\n  float grid_size;\n  getInfoById(layer_id, nullptr, &grid_size, nullptr);\n  return grid_size;\n}\n\nfloat MapLayerDictionaryParser::getTileSize(const int layer_id) {\n  float tile_size;\n  getInfoById(layer_id, nullptr, nullptr, &tile_size);\n  return tile_size;\n}\n\nstd::string MapLayerDictionaryParser::getTypeName(const int layer_id) {\n  std::string type_name;\n  getInfoById(layer_id, &type_name, nullptr, nullptr);\n  return type_name;\n}\n\nbool MapLayerDictionaryParser::addItem(const int layer_id, const std::string& type_name,\n                                       const float grid_size, const float tile_size) {\n  if (id_to_key_.count(layer_id) == 1) {\n    std::cerr << \"failed to add item: layer_id \" << layer_id << \" has already exited in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 1) {\n    std::cerr << \"failed to add item: layer configuration has already existed in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  id_to_key_[layer_id] = key;\n  key_to_id_[key] = layer_id;\n  return true;\n}\n\nbool MapLayerDictionaryParser::save(const std::string& dict_file) {\n  // sort layer id\n  std::vector<int> layer_ids;\n  for (auto& pair : id_to_key_) {\n    layer_ids.emplace_back(pair.first);\n  }\n  std::sort(layer_ids.begin(), layer_ids.end());\n\n  // add item to dict\n  proto::config::MapLayerDictionary dict;\n  for (auto& id : layer_ids) {\n    // analyze key\n    std::string type_name;\n    float grid_size;\n    float tile_size;\n    analyseKey(id_to_key_[id], &type_name, &grid_size, &tile_size);\n\n    // add item\n    proto::config::MapLayerItem* item = dict.add_items();\n    item->set_layer_id(id);\n    item->set_type_name(type_name);\n    item->set_grid_size(grid_size);\n    item->set_tile_size(tile_size);\n  }\n\n  // write dict to file\n  return common::ProtoIO::writeProtoToTextFile(dict_file, dict);\n}\n\nvoid MapLayerDictionaryParser::composeKey(const std::string& type_name, const float& grid_size,\n                                          const float& tile_size, std::string* key) {\n  std::stringstream str_stream;\n  str_stream << type_name << \"_\" << static_cast<int>(grid_size * grid_size_ratio) << \"_\"\n             << static_cast<int>(tile_size);\n  *key = str_stream.str();\n}\n\nvoid MapLayerDictionaryParser::analyseKey(const std::string& key, std::string* type_name,\n                                          float* grid_size, float* tile_size) {\n  std::vector<std::string> substrs;\n  substrs.resize(3);\n\n  // achieve sub strings from key\n  size_t tail = key.size() - 1;\n  for (int i = 0; i < 2; i++) {\n    size_t pos = key.rfind('_', tail);\n    substrs[2 - i] = key.substr(pos + 1, tail - pos);\n    tail = pos - 1;\n  }\n  substrs[0] = key.substr(0, tail + 1);\n\n  // output\n  if (tile_size != nullptr) {\n    *tile_size = std::stof(substrs[2]);\n  }\n  if (grid_size != nullptr) {\n    *grid_size = std::stof(substrs[1]) / grid_size_ratio;\n  }\n  if (type_name != nullptr) {\n    *type_name = substrs[0];\n  }\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp"
		}
	}
]
I0403 13:40:15.692294 32175 json_parser.cpp:18] 
[
	3,
	{
		"bufnr" : 3,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All rights reserved.\n// Authors: Yongjian Zhao (yongjian.zhao@allride.ai)\n\n#include <fstream>\n#include <iostream>\n#include <sstream>\n#include <vector>\n\n#include \"common/io/proto_io.h\"\n#include \"common/proto/config/config_map.pb.h\"\n#include \"map_layer_dictionary_parser.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstatic const float grid_size_ratio = 1000.0f;  // convert from m to mm,\n\nbool MapLayerDictionaryParser::load(const std::string& dict_file) {\n  proto::config::MapLayerDictionary dict;\n  if (!common::ProtoIO::readProtoFromTextFile(dict_file, &dict)) {\n    std::cerr << \"MapLayerDictionaryParser: failed to load from dictionary file!\" << std::endl;\n    std::cerr << \"dict_file: \" << dict_file << std::endl;\n    return false;\n  }\n\n  for (const auto& item : dict.items()) {\n    int layer_id = item.layer_id();\n    std::string type_name = item.type_name();\n    float grid_size = item.grid_size();\n    float tile_size = item.tile_size();\n\n    // compose the key\n    std::string key;\n    composeKey(type_name, grid_size, tile_size, &key);\n\n    // set unordered_map\n    id_to_key_[layer_id] = key;\n    key_to_id_[key] = layer_id;\n  }\n\n  return true;\n}\n\nbool MapLayerDictionaryParser::getInfoById(const int layer_id, std::string* type_name,\n                                           float* grid_size, float* tile_size) {\n  if (id_to_key_.count(layer_id) == 0) {\n    return false;\n  }\n\n  analyseKey(id_to_key_[layer_id], type_name, grid_size, tile_size);\n  return true;\n}\n\nbool MapLayerDictionaryParser::getIdByInfo(const std::string& type_name, const float& grid_size,\n                                           const float& tile_size, int* layer_id) {\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 0) {\n    return false;\n  }\n\n  *layer_id = key_to_id_[key];\n  return true;\n}\n\nfloat MapLayerDictionaryParser::getGridSize(const int layer_id) {\n  float grid_size;\n  if(getInfoById(layer_id, nullptr, &grid_size, nullptr);\n  return grid_size;\n}\n\nfloat MapLayerDictionaryParser::getTileSize(const int layer_id) {\n  float tile_size;\n  getInfoById(layer_id, nullptr, nullptr, &tile_size);\n  return tile_size;\n}\n\nstd::string MapLayerDictionaryParser::getTypeName(const int layer_id) {\n  std::string type_name;\n  getInfoById(layer_id, &type_name, nullptr, nullptr);\n  return type_name;\n}\n\nbool MapLayerDictionaryParser::addItem(const int layer_id, const std::string& type_name,\n                                       const float grid_size, const float tile_size) {\n  if (id_to_key_.count(layer_id) == 1) {\n    std::cerr << \"failed to add item: layer_id \" << layer_id << \" has already exited in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 1) {\n    std::cerr << \"failed to add item: layer configuration has already existed in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  id_to_key_[layer_id] = key;\n  key_to_id_[key] = layer_id;\n  return true;\n}\n\nbool MapLayerDictionaryParser::save(const std::string& dict_file) {\n  // sort layer id\n  std::vector<int> layer_ids;\n  for (auto& pair : id_to_key_) {\n    layer_ids.emplace_back(pair.first);\n  }\n  std::sort(layer_ids.begin(), layer_ids.end());\n\n  // add item to dict\n  proto::config::MapLayerDictionary dict;\n  for (auto& id : layer_ids) {\n    // analyze key\n    std::string type_name;\n    float grid_size;\n    float tile_size;\n    analyseKey(id_to_key_[id], &type_name, &grid_size, &tile_size);\n\n    // add item\n    proto::config::MapLayerItem* item = dict.add_items();\n    item->set_layer_id(id);\n    item->set_type_name(type_name);\n    item->set_grid_size(grid_size);\n    item->set_tile_size(tile_size);\n  }\n\n  // write dict to file\n  return common::ProtoIO::writeProtoToTextFile(dict_file, dict);\n}\n\nvoid MapLayerDictionaryParser::composeKey(const std::string& type_name, const float& grid_size,\n                                          const float& tile_size, std::string* key) {\n  std::stringstream str_stream;\n  str_stream << type_name << \"_\" << static_cast<int>(grid_size * grid_size_ratio) << \"_\"\n             << static_cast<int>(tile_size);\n  *key = str_stream.str();\n}\n\nvoid MapLayerDictionaryParser::analyseKey(const std::string& key, std::string* type_name,\n                                          float* grid_size, float* tile_size) {\n  std::vector<std::string> substrs;\n  substrs.resize(3);\n\n  // achieve sub strings from key\n  size_t tail = key.size() - 1;\n  for (int i = 0; i < 2; i++) {\n    size_t pos = key.rfind('_', tail);\n    substrs[2 - i] = key.substr(pos + 1, tail - pos);\n    tail = pos - 1;\n  }\n  substrs[0] = key.substr(0, tail + 1);\n\n  // output\n  if (tile_size != nullptr) {\n    *tile_size = std::stof(substrs[2]);\n  }\n  if (grid_size != nullptr) {\n    *grid_size = std::stof(substrs[1]) / grid_size_ratio;\n  }\n  if (type_name != nullptr) {\n    *type_name = substrs[0];\n  }\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp"
		}
	}
]
I0403 13:40:16.161661 32175 json_parser.cpp:18] 
[
	4,
	{
		"bufnr" : 3,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All rights reserved.\n// Authors: Yongjian Zhao (yongjian.zhao@allride.ai)\n\n#include <fstream>\n#include <iostream>\n#include <sstream>\n#include <vector>\n\n#include \"common/io/proto_io.h\"\n#include \"common/proto/config/config_map.pb.h\"\n#include \"map_layer_dictionary_parser.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstatic const float grid_size_ratio = 1000.0f;  // convert from m to mm,\n\nbool MapLayerDictionaryParser::load(const std::string& dict_file) {\n  proto::config::MapLayerDictionary dict;\n  if (!common::ProtoIO::readProtoFromTextFile(dict_file, &dict)) {\n    std::cerr << \"MapLayerDictionaryParser: failed to load from dictionary file!\" << std::endl;\n    std::cerr << \"dict_file: \" << dict_file << std::endl;\n    return false;\n  }\n\n  for (const auto& item : dict.items()) {\n    int layer_id = item.layer_id();\n    std::string type_name = item.type_name();\n    float grid_size = item.grid_size();\n    float tile_size = item.tile_size();\n\n    // compose the key\n    std::string key;\n    composeKey(type_name, grid_size, tile_size, &key);\n\n    // set unordered_map\n    id_to_key_[layer_id] = key;\n    key_to_id_[key] = layer_id;\n  }\n\n  return true;\n}\n\nbool MapLayerDictionaryParser::getInfoById(const int layer_id, std::string* type_name,\n                                           float* grid_size, float* tile_size) {\n  if (id_to_key_.count(layer_id) == 0) {\n    return false;\n  }\n\n  analyseKey(id_to_key_[layer_id], type_name, grid_size, tile_size);\n  return true;\n}\n\nbool MapLayerDictionaryParser::getIdByInfo(const std::string& type_name, const float& grid_size,\n                                           const float& tile_size, int* layer_id) {\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 0) {\n    return false;\n  }\n\n  *layer_id = key_to_id_[key];\n  return true;\n}\n\nfloat MapLayerDictionaryParser::getGridSize(const int layer_id) {\n  float grid_size;\n  if(getInfoById(layer_id, nullptr, &grid_size, nullptr);\n  return grid_size;\n}\n\nfloat MapLayerDictionaryParser::getTileSize(const int layer_id) {\n  float tile_size;\n  getInfoById(layer_id, nullptr, nullptr, &tile_size);\n  return tile_size;\n}\n\nstd::string MapLayerDictionaryParser::getTypeName(const int layer_id) {\n  std::string type_name;\n  getInfoById(layer_id, &type_name, nullptr, nullptr);\n  return type_name;\n}\n\nbool MapLayerDictionaryParser::addItem(const int layer_id, const std::string& type_name,\n                                       const float grid_size, const float tile_size) {\n  if (id_to_key_.count(layer_id) == 1) {\n    std::cerr << \"failed to add item: layer_id \" << layer_id << \" has already exited in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 1) {\n    std::cerr << \"failed to add item: layer configuration has already existed in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  id_to_key_[layer_id] = key;\n  key_to_id_[key] = layer_id;\n  return true;\n}\n\nbool MapLayerDictionaryParser::save(const std::string& dict_file) {\n  // sort layer id\n  std::vector<int> layer_ids;\n  for (auto& pair : id_to_key_) {\n    layer_ids.emplace_back(pair.first);\n  }\n  std::sort(layer_ids.begin(), layer_ids.end());\n\n  // add item to dict\n  proto::config::MapLayerDictionary dict;\n  for (auto& id : layer_ids) {\n    // analyze key\n    std::string type_name;\n    float grid_size;\n    float tile_size;\n    analyseKey(id_to_key_[id], &type_name, &grid_size, &tile_size);\n\n    // add item\n    proto::config::MapLayerItem* item = dict.add_items();\n    item->set_layer_id(id);\n    item->set_type_name(type_name);\n    item->set_grid_size(grid_size);\n    item->set_tile_size(tile_size);\n  }\n\n  // write dict to file\n  return common::ProtoIO::writeProtoToTextFile(dict_file, dict);\n}\n\nvoid MapLayerDictionaryParser::composeKey(const std::string& type_name, const float& grid_size,\n                                          const float& tile_size, std::string* key) {\n  std::stringstream str_stream;\n  str_stream << type_name << \"_\" << static_cast<int>(grid_size * grid_size_ratio) << \"_\"\n             << static_cast<int>(tile_size);\n  *key = str_stream.str();\n}\n\nvoid MapLayerDictionaryParser::analyseKey(const std::string& key, std::string* type_name,\n                                          float* grid_size, float* tile_size) {\n  std::vector<std::string> substrs;\n  substrs.resize(3);\n\n  // achieve sub strings from key\n  size_t tail = key.size() - 1;\n  for (int i = 0; i < 2; i++) {\n    size_t pos = key.rfind('_', tail);\n    substrs[2 - i] = key.substr(pos + 1, tail - pos);\n    tail = pos - 1;\n  }\n  substrs[0] = key.substr(0, tail + 1);\n\n  // output\n  if (tile_size != nullptr) {\n    *tile_size = std::stof(substrs[2]);\n  }\n  if (grid_size != nullptr) {\n    *grid_size = std::stof(substrs[1]) / grid_size_ratio;\n  }\n  if (type_name != nullptr) {\n    *type_name = substrs[0];\n  }\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp"
		}
	}
]
I0403 13:40:17.481634 32175 json_parser.cpp:18] 
[
	5,
	{
		"bufnr" : 3,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All rights reserved.\n// Authors: Yongjian Zhao (yongjian.zhao@allride.ai)\n\n#include <fstream>\n#include <iostream>\n#include <sstream>\n#include <vector>\n\n#include \"common/io/proto_io.h\"\n#include \"common/proto/config/config_map.pb.h\"\n#include \"map_layer_dictionary_parser.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstatic const float grid_size_ratio = 1000.0f;  // convert from m to mm,\n\nbool MapLayerDictionaryParser::load(const std::string& dict_file) {\n  proto::config::MapLayerDictionary dict;\n  if (!common::ProtoIO::readProtoFromTextFile(dict_file, &dict)) {\n    std::cerr << \"MapLayerDictionaryParser: failed to load from dictionary file!\" << std::endl;\n    std::cerr << \"dict_file: \" << dict_file << std::endl;\n    return false;\n  }\n\n  for (const auto& item : dict.items()) {\n    int layer_id = item.layer_id();\n    std::string type_name = item.type_name();\n    float grid_size = item.grid_size();\n    float tile_size = item.tile_size();\n\n    // compose the key\n    std::string key;\n    composeKey(type_name, grid_size, tile_size, &key);\n\n    // set unordered_map\n    id_to_key_[layer_id] = key;\n    key_to_id_[key] = layer_id;\n  }\n\n  return true;\n}\n\nbool MapLayerDictionaryParser::getInfoById(const int layer_id, std::string* type_name,\n                                           float* grid_size, float* tile_size) {\n  if (id_to_key_.count(layer_id) == 0) {\n    return false;\n  }\n\n  analyseKey(id_to_key_[layer_id], type_name, grid_size, tile_size);\n  return true;\n}\n\nbool MapLayerDictionaryParser::getIdByInfo(const std::string& type_name, const float& grid_size,\n                                           const float& tile_size, int* layer_id) {\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 0) {\n    return false;\n  }\n\n  *layer_id = key_to_id_[key];\n  return true;\n}\n\nfloat MapLayerDictionaryParser::getGridSize(const int layer_id) {\n  float grid_size;\n  if(!getInfoById(layer_id, nullptr, &grid_size, nullptr);\n  return grid_size;\n}\n\nfloat MapLayerDictionaryParser::getTileSize(const int layer_id) {\n  float tile_size;\n  getInfoById(layer_id, nullptr, nullptr, &tile_size);\n  return tile_size;\n}\n\nstd::string MapLayerDictionaryParser::getTypeName(const int layer_id) {\n  std::string type_name;\n  getInfoById(layer_id, &type_name, nullptr, nullptr);\n  return type_name;\n}\n\nbool MapLayerDictionaryParser::addItem(const int layer_id, const std::string& type_name,\n                                       const float grid_size, const float tile_size) {\n  if (id_to_key_.count(layer_id) == 1) {\n    std::cerr << \"failed to add item: layer_id \" << layer_id << \" has already exited in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 1) {\n    std::cerr << \"failed to add item: layer configuration has already existed in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  id_to_key_[layer_id] = key;\n  key_to_id_[key] = layer_id;\n  return true;\n}\n\nbool MapLayerDictionaryParser::save(const std::string& dict_file) {\n  // sort layer id\n  std::vector<int> layer_ids;\n  for (auto& pair : id_to_key_) {\n    layer_ids.emplace_back(pair.first);\n  }\n  std::sort(layer_ids.begin(), layer_ids.end());\n\n  // add item to dict\n  proto::config::MapLayerDictionary dict;\n  for (auto& id : layer_ids) {\n    // analyze key\n    std::string type_name;\n    float grid_size;\n    float tile_size;\n    analyseKey(id_to_key_[id], &type_name, &grid_size, &tile_size);\n\n    // add item\n    proto::config::MapLayerItem* item = dict.add_items();\n    item->set_layer_id(id);\n    item->set_type_name(type_name);\n    item->set_grid_size(grid_size);\n    item->set_tile_size(tile_size);\n  }\n\n  // write dict to file\n  return common::ProtoIO::writeProtoToTextFile(dict_file, dict);\n}\n\nvoid MapLayerDictionaryParser::composeKey(const std::string& type_name, const float& grid_size,\n                                          const float& tile_size, std::string* key) {\n  std::stringstream str_stream;\n  str_stream << type_name << \"_\" << static_cast<int>(grid_size * grid_size_ratio) << \"_\"\n             << static_cast<int>(tile_size);\n  *key = str_stream.str();\n}\n\nvoid MapLayerDictionaryParser::analyseKey(const std::string& key, std::string* type_name,\n                                          float* grid_size, float* tile_size) {\n  std::vector<std::string> substrs;\n  substrs.resize(3);\n\n  // achieve sub strings from key\n  size_t tail = key.size() - 1;\n  for (int i = 0; i < 2; i++) {\n    size_t pos = key.rfind('_', tail);\n    substrs[2 - i] = key.substr(pos + 1, tail - pos);\n    tail = pos - 1;\n  }\n  substrs[0] = key.substr(0, tail + 1);\n\n  // output\n  if (tile_size != nullptr) {\n    *tile_size = std::stof(substrs[2]);\n  }\n  if (grid_size != nullptr) {\n    *grid_size = std::stof(substrs[1]) / grid_size_ratio;\n  }\n  if (type_name != nullptr) {\n    *type_name = substrs[0];\n  }\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp"
		}
	}
]
I0403 13:40:19.090204 32175 json_parser.cpp:18] 
[
	6,
	{
		"bufnr" : 3,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All rights reserved.\n// Authors: Yongjian Zhao (yongjian.zhao@allride.ai)\n\n#include <fstream>\n#include <iostream>\n#include <sstream>\n#include <vector>\n\n#include \"common/io/proto_io.h\"\n#include \"common/proto/config/config_map.pb.h\"\n#include \"map_layer_dictionary_parser.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstatic const float grid_size_ratio = 1000.0f;  // convert from m to mm,\n\nbool MapLayerDictionaryParser::load(const std::string& dict_file) {\n  proto::config::MapLayerDictionary dict;\n  if (!common::ProtoIO::readProtoFromTextFile(dict_file, &dict)) {\n    std::cerr << \"MapLayerDictionaryParser: failed to load from dictionary file!\" << std::endl;\n    std::cerr << \"dict_file: \" << dict_file << std::endl;\n    return false;\n  }\n\n  for (const auto& item : dict.items()) {\n    int layer_id = item.layer_id();\n    std::string type_name = item.type_name();\n    float grid_size = item.grid_size();\n    float tile_size = item.tile_size();\n\n    // compose the key\n    std::string key;\n    composeKey(type_name, grid_size, tile_size, &key);\n\n    // set unordered_map\n    id_to_key_[layer_id] = key;\n    key_to_id_[key] = layer_id;\n  }\n\n  return true;\n}\n\nbool MapLayerDictionaryParser::getInfoById(const int layer_id, std::string* type_name,\n                                           float* grid_size, float* tile_size) {\n  if (id_to_key_.count(layer_id) == 0) {\n    return false;\n  }\n\n  analyseKey(id_to_key_[layer_id], type_name, grid_size, tile_size);\n  return true;\n}\n\nbool MapLayerDictionaryParser::getIdByInfo(const std::string& type_name, const float& grid_size,\n                                           const float& tile_size, int* layer_id) {\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 0) {\n    return false;\n  }\n\n  *layer_id = key_to_id_[key];\n  return true;\n}\n\nfloat MapLayerDictionaryParser::getGridSize(const int layer_id) {\n  float grid_size;\n  if(!getInfoById(layer_id, nullptr, &grid_size, nullptr)\n  return grid_size;\n}\n\nfloat MapLayerDictionaryParser::getTileSize(const int layer_id) {\n  float tile_size;\n  getInfoById(layer_id, nullptr, nullptr, &tile_size);\n  return tile_size;\n}\n\nstd::string MapLayerDictionaryParser::getTypeName(const int layer_id) {\n  std::string type_name;\n  getInfoById(layer_id, &type_name, nullptr, nullptr);\n  return type_name;\n}\n\nbool MapLayerDictionaryParser::addItem(const int layer_id, const std::string& type_name,\n                                       const float grid_size, const float tile_size) {\n  if (id_to_key_.count(layer_id) == 1) {\n    std::cerr << \"failed to add item: layer_id \" << layer_id << \" has already exited in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 1) {\n    std::cerr << \"failed to add item: layer configuration has already existed in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  id_to_key_[layer_id] = key;\n  key_to_id_[key] = layer_id;\n  return true;\n}\n\nbool MapLayerDictionaryParser::save(const std::string& dict_file) {\n  // sort layer id\n  std::vector<int> layer_ids;\n  for (auto& pair : id_to_key_) {\n    layer_ids.emplace_back(pair.first);\n  }\n  std::sort(layer_ids.begin(), layer_ids.end());\n\n  // add item to dict\n  proto::config::MapLayerDictionary dict;\n  for (auto& id : layer_ids) {\n    // analyze key\n    std::string type_name;\n    float grid_size;\n    float tile_size;\n    analyseKey(id_to_key_[id], &type_name, &grid_size, &tile_size);\n\n    // add item\n    proto::config::MapLayerItem* item = dict.add_items();\n    item->set_layer_id(id);\n    item->set_type_name(type_name);\n    item->set_grid_size(grid_size);\n    item->set_tile_size(tile_size);\n  }\n\n  // write dict to file\n  return common::ProtoIO::writeProtoToTextFile(dict_file, dict);\n}\n\nvoid MapLayerDictionaryParser::composeKey(const std::string& type_name, const float& grid_size,\n                                          const float& tile_size, std::string* key) {\n  std::stringstream str_stream;\n  str_stream << type_name << \"_\" << static_cast<int>(grid_size * grid_size_ratio) << \"_\"\n             << static_cast<int>(tile_size);\n  *key = str_stream.str();\n}\n\nvoid MapLayerDictionaryParser::analyseKey(const std::string& key, std::string* type_name,\n                                          float* grid_size, float* tile_size) {\n  std::vector<std::string> substrs;\n  substrs.resize(3);\n\n  // achieve sub strings from key\n  size_t tail = key.size() - 1;\n  for (int i = 0; i < 2; i++) {\n    size_t pos = key.rfind('_', tail);\n    substrs[2 - i] = key.substr(pos + 1, tail - pos);\n    tail = pos - 1;\n  }\n  substrs[0] = key.substr(0, tail + 1);\n\n  // output\n  if (tile_size != nullptr) {\n    *tile_size = std::stof(substrs[2]);\n  }\n  if (grid_size != nullptr) {\n    *grid_size = std::stof(substrs[1]) / grid_size_ratio;\n  }\n  if (type_name != nullptr) {\n    *type_name = substrs[0];\n  }\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp"
		}
	}
]
I0403 13:40:19.273198 32175 json_parser.cpp:18] 
[
	7,
	{
		"bufnr" : 3,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All rights reserved.\n// Authors: Yongjian Zhao (yongjian.zhao@allride.ai)\n\n#include <fstream>\n#include <iostream>\n#include <sstream>\n#include <vector>\n\n#include \"common/io/proto_io.h\"\n#include \"common/proto/config/config_map.pb.h\"\n#include \"map_layer_dictionary_parser.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstatic const float grid_size_ratio = 1000.0f;  // convert from m to mm,\n\nbool MapLayerDictionaryParser::load(const std::string& dict_file) {\n  proto::config::MapLayerDictionary dict;\n  if (!common::ProtoIO::readProtoFromTextFile(dict_file, &dict)) {\n    std::cerr << \"MapLayerDictionaryParser: failed to load from dictionary file!\" << std::endl;\n    std::cerr << \"dict_file: \" << dict_file << std::endl;\n    return false;\n  }\n\n  for (const auto& item : dict.items()) {\n    int layer_id = item.layer_id();\n    std::string type_name = item.type_name();\n    float grid_size = item.grid_size();\n    float tile_size = item.tile_size();\n\n    // compose the key\n    std::string key;\n    composeKey(type_name, grid_size, tile_size, &key);\n\n    // set unordered_map\n    id_to_key_[layer_id] = key;\n    key_to_id_[key] = layer_id;\n  }\n\n  return true;\n}\n\nbool MapLayerDictionaryParser::getInfoById(const int layer_id, std::string* type_name,\n                                           float* grid_size, float* tile_size) {\n  if (id_to_key_.count(layer_id) == 0) {\n    return false;\n  }\n\n  analyseKey(id_to_key_[layer_id], type_name, grid_size, tile_size);\n  return true;\n}\n\nbool MapLayerDictionaryParser::getIdByInfo(const std::string& type_name, const float& grid_size,\n                                           const float& tile_size, int* layer_id) {\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 0) {\n    return false;\n  }\n\n  *layer_id = key_to_id_[key];\n  return true;\n}\n\nfloat MapLayerDictionaryParser::getGridSize(const int layer_id) {\n  float grid_size;\n  if(!getInfoById(layer_id, nullptr, &grid_size, nullptr)\n  return grid_size;\n}\n\nfloat MapLayerDictionaryParser::getTileSize(const int layer_id) {\n  float tile_size;\n  getInfoById(layer_id, nullptr, nullptr, &tile_size);\n  return tile_size;\n}\n\nstd::string MapLayerDictionaryParser::getTypeName(const int layer_id) {\n  std::string type_name;\n  getInfoById(layer_id, &type_name, nullptr, nullptr);\n  return type_name;\n}\n\nbool MapLayerDictionaryParser::addItem(const int layer_id, const std::string& type_name,\n                                       const float grid_size, const float tile_size) {\n  if (id_to_key_.count(layer_id) == 1) {\n    std::cerr << \"failed to add item: layer_id \" << layer_id << \" has already exited in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 1) {\n    std::cerr << \"failed to add item: layer configuration has already existed in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  id_to_key_[layer_id] = key;\n  key_to_id_[key] = layer_id;\n  return true;\n}\n\nbool MapLayerDictionaryParser::save(const std::string& dict_file) {\n  // sort layer id\n  std::vector<int> layer_ids;\n  for (auto& pair : id_to_key_) {\n    layer_ids.emplace_back(pair.first);\n  }\n  std::sort(layer_ids.begin(), layer_ids.end());\n\n  // add item to dict\n  proto::config::MapLayerDictionary dict;\n  for (auto& id : layer_ids) {\n    // analyze key\n    std::string type_name;\n    float grid_size;\n    float tile_size;\n    analyseKey(id_to_key_[id], &type_name, &grid_size, &tile_size);\n\n    // add item\n    proto::config::MapLayerItem* item = dict.add_items();\n    item->set_layer_id(id);\n    item->set_type_name(type_name);\n    item->set_grid_size(grid_size);\n    item->set_tile_size(tile_size);\n  }\n\n  // write dict to file\n  return common::ProtoIO::writeProtoToTextFile(dict_file, dict);\n}\n\nvoid MapLayerDictionaryParser::composeKey(const std::string& type_name, const float& grid_size,\n                                          const float& tile_size, std::string* key) {\n  std::stringstream str_stream;\n  str_stream << type_name << \"_\" << static_cast<int>(grid_size * grid_size_ratio) << \"_\"\n             << static_cast<int>(tile_size);\n  *key = str_stream.str();\n}\n\nvoid MapLayerDictionaryParser::analyseKey(const std::string& key, std::string* type_name,\n                                          float* grid_size, float* tile_size) {\n  std::vector<std::string> substrs;\n  substrs.resize(3);\n\n  // achieve sub strings from key\n  size_t tail = key.size() - 1;\n  for (int i = 0; i < 2; i++) {\n    size_t pos = key.rfind('_', tail);\n    substrs[2 - i] = key.substr(pos + 1, tail - pos);\n    tail = pos - 1;\n  }\n  substrs[0] = key.substr(0, tail + 1);\n\n  // output\n  if (tile_size != nullptr) {\n    *tile_size = std::stof(substrs[2]);\n  }\n  if (grid_size != nullptr) {\n    *grid_size = std::stof(substrs[1]) / grid_size_ratio;\n  }\n  if (type_name != nullptr) {\n    *type_name = substrs[0];\n  }\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp"
		}
	}
]
I0403 13:40:22.320600 32175 json_parser.cpp:18] 
[
	8,
	{
		"bufnr" : 3,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All rights reserved.\n// Authors: Yongjian Zhao (yongjian.zhao@allride.ai)\n\n#include <fstream>\n#include <iostream>\n#include <sstream>\n#include <vector>\n\n#include \"common/io/proto_io.h\"\n#include \"common/proto/config/config_map.pb.h\"\n#include \"map_layer_dictionary_parser.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstatic const float grid_size_ratio = 1000.0f;  // convert from m to mm,\n\nbool MapLayerDictionaryParser::load(const std::string& dict_file) {\n  proto::config::MapLayerDictionary dict;\n  if (!common::ProtoIO::readProtoFromTextFile(dict_file, &dict)) {\n    std::cerr << \"MapLayerDictionaryParser: failed to load from dictionary file!\" << std::endl;\n    std::cerr << \"dict_file: \" << dict_file << std::endl;\n    return false;\n  }\n\n  for (const auto& item : dict.items()) {\n    int layer_id = item.layer_id();\n    std::string type_name = item.type_name();\n    float grid_size = item.grid_size();\n    float tile_size = item.tile_size();\n\n    // compose the key\n    std::string key;\n    composeKey(type_name, grid_size, tile_size, &key);\n\n    // set unordered_map\n    id_to_key_[layer_id] = key;\n    key_to_id_[key] = layer_id;\n  }\n\n  return true;\n}\n\nbool MapLayerDictionaryParser::getInfoById(const int layer_id, std::string* type_name,\n                                           float* grid_size, float* tile_size) {\n  if (id_to_key_.count(layer_id) == 0) {\n    return false;\n  }\n\n  analyseKey(id_to_key_[layer_id], type_name, grid_size, tile_size);\n  return true;\n}\n\nbool MapLayerDictionaryParser::getIdByInfo(const std::string& type_name, const float& grid_size,\n                                           const float& tile_size, int* layer_id) {\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 0) {\n    return false;\n  }\n\n  *layer_id = key_to_id_[key];\n  return true;\n}\n\nfloat MapLayerDictionaryParser::getGridSize(const int layer_id) {\n  float grid_size;\n  if(!getInfoById(layer_id, nullptr, &grid_size, nullptr))\n\n  return grid_size;\n}\n\nfloat MapLayerDictionaryParser::getTileSize(const int layer_id) {\n  float tile_size;\n  getInfoById(layer_id, nullptr, nullptr, &tile_size);\n  return tile_size;\n}\n\nstd::string MapLayerDictionaryParser::getTypeName(const int layer_id) {\n  std::string type_name;\n  getInfoById(layer_id, &type_name, nullptr, nullptr);\n  return type_name;\n}\n\nbool MapLayerDictionaryParser::addItem(const int layer_id, const std::string& type_name,\n                                       const float grid_size, const float tile_size) {\n  if (id_to_key_.count(layer_id) == 1) {\n    std::cerr << \"failed to add item: layer_id \" << layer_id << \" has already exited in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 1) {\n    std::cerr << \"failed to add item: layer configuration has already existed in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  id_to_key_[layer_id] = key;\n  key_to_id_[key] = layer_id;\n  return true;\n}\n\nbool MapLayerDictionaryParser::save(const std::string& dict_file) {\n  // sort layer id\n  std::vector<int> layer_ids;\n  for (auto& pair : id_to_key_) {\n    layer_ids.emplace_back(pair.first);\n  }\n  std::sort(layer_ids.begin(), layer_ids.end());\n\n  // add item to dict\n  proto::config::MapLayerDictionary dict;\n  for (auto& id : layer_ids) {\n    // analyze key\n    std::string type_name;\n    float grid_size;\n    float tile_size;\n    analyseKey(id_to_key_[id], &type_name, &grid_size, &tile_size);\n\n    // add item\n    proto::config::MapLayerItem* item = dict.add_items();\n    item->set_layer_id(id);\n    item->set_type_name(type_name);\n    item->set_grid_size(grid_size);\n    item->set_tile_size(tile_size);\n  }\n\n  // write dict to file\n  return common::ProtoIO::writeProtoToTextFile(dict_file, dict);\n}\n\nvoid MapLayerDictionaryParser::composeKey(const std::string& type_name, const float& grid_size,\n                                          const float& tile_size, std::string* key) {\n  std::stringstream str_stream;\n  str_stream << type_name << \"_\" << static_cast<int>(grid_size * grid_size_ratio) << \"_\"\n             << static_cast<int>(tile_size);\n  *key = str_stream.str();\n}\n\nvoid MapLayerDictionaryParser::analyseKey(const std::string& key, std::string* type_name,\n                                          float* grid_size, float* tile_size) {\n  std::vector<std::string> substrs;\n  substrs.resize(3);\n\n  // achieve sub strings from key\n  size_t tail = key.size() - 1;\n  for (int i = 0; i < 2; i++) {\n    size_t pos = key.rfind('_', tail);\n    substrs[2 - i] = key.substr(pos + 1, tail - pos);\n    tail = pos - 1;\n  }\n  substrs[0] = key.substr(0, tail + 1);\n\n  // output\n  if (tile_size != nullptr) {\n    *tile_size = std::stof(substrs[2]);\n  }\n  if (grid_size != nullptr) {\n    *grid_size = std::stof(substrs[1]) / grid_size_ratio;\n  }\n  if (type_name != nullptr) {\n    *type_name = substrs[0];\n  }\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp"
		}
	}
]
I0403 13:40:23.544953 32175 json_parser.cpp:18] 
[
	9,
	{
		"bufnr" : 3,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All rights reserved.\n// Authors: Yongjian Zhao (yongjian.zhao@allride.ai)\n\n#include <fstream>\n#include <iostream>\n#include <sstream>\n#include <vector>\n\n#include \"common/io/proto_io.h\"\n#include \"common/proto/config/config_map.pb.h\"\n#include \"map_layer_dictionary_parser.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstatic const float grid_size_ratio = 1000.0f;  // convert from m to mm,\n\nbool MapLayerDictionaryParser::load(const std::string& dict_file) {\n  proto::config::MapLayerDictionary dict;\n  if (!common::ProtoIO::readProtoFromTextFile(dict_file, &dict)) {\n    std::cerr << \"MapLayerDictionaryParser: failed to load from dictionary file!\" << std::endl;\n    std::cerr << \"dict_file: \" << dict_file << std::endl;\n    return false;\n  }\n\n  for (const auto& item : dict.items()) {\n    int layer_id = item.layer_id();\n    std::string type_name = item.type_name();\n    float grid_size = item.grid_size();\n    float tile_size = item.tile_size();\n\n    // compose the key\n    std::string key;\n    composeKey(type_name, grid_size, tile_size, &key);\n\n    // set unordered_map\n    id_to_key_[layer_id] = key;\n    key_to_id_[key] = layer_id;\n  }\n\n  return true;\n}\n\nbool MapLayerDictionaryParser::getInfoById(const int layer_id, std::string* type_name,\n                                           float* grid_size, float* tile_size) {\n  if (id_to_key_.count(layer_id) == 0) {\n    return false;\n  }\n\n  analyseKey(id_to_key_[layer_id], type_name, grid_size, tile_size);\n  return true;\n}\n\nbool MapLayerDictionaryParser::getIdByInfo(const std::string& type_name, const float& grid_size,\n                                           const float& tile_size, int* layer_id) {\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 0) {\n    return false;\n  }\n\n  *layer_id = key_to_id_[key];\n  return true;\n}\n\nfloat MapLayerDictionaryParser::getGridSize(const int layer_id) {\n  float grid_size;\n  if(!getInfoById(layer_id, nullptr, &grid_size, nullptr))\n\n  return grid_size;\n}\n\nfloat MapLayerDictionaryParser::getTileSize(const int layer_id) {\n  float tile_size;\n  getInfoById(layer_id, nullptr, nullptr, &tile_size);\n  return tile_size;\n}\n\nstd::string MapLayerDictionaryParser::getTypeName(const int layer_id) {\n  std::string type_name;\n  getInfoById(layer_id, &type_name, nullptr, nullptr);\n  return type_name;\n}\n\nbool MapLayerDictionaryParser::addItem(const int layer_id, const std::string& type_name,\n                                       const float grid_size, const float tile_size) {\n  if (id_to_key_.count(layer_id) == 1) {\n    std::cerr << \"failed to add item: layer_id \" << layer_id << \" has already exited in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 1) {\n    std::cerr << \"failed to add item: layer configuration has already existed in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  id_to_key_[layer_id] = key;\n  key_to_id_[key] = layer_id;\n  return true;\n}\n\nbool MapLayerDictionaryParser::save(const std::string& dict_file) {\n  // sort layer id\n  std::vector<int> layer_ids;\n  for (auto& pair : id_to_key_) {\n    layer_ids.emplace_back(pair.first);\n  }\n  std::sort(layer_ids.begin(), layer_ids.end());\n\n  // add item to dict\n  proto::config::MapLayerDictionary dict;\n  for (auto& id : layer_ids) {\n    // analyze key\n    std::string type_name;\n    float grid_size;\n    float tile_size;\n    analyseKey(id_to_key_[id], &type_name, &grid_size, &tile_size);\n\n    // add item\n    proto::config::MapLayerItem* item = dict.add_items();\n    item->set_layer_id(id);\n    item->set_type_name(type_name);\n    item->set_grid_size(grid_size);\n    item->set_tile_size(tile_size);\n  }\n\n  // write dict to file\n  return common::ProtoIO::writeProtoToTextFile(dict_file, dict);\n}\n\nvoid MapLayerDictionaryParser::composeKey(const std::string& type_name, const float& grid_size,\n                                          const float& tile_size, std::string* key) {\n  std::stringstream str_stream;\n  str_stream << type_name << \"_\" << static_cast<int>(grid_size * grid_size_ratio) << \"_\"\n             << static_cast<int>(tile_size);\n  *key = str_stream.str();\n}\n\nvoid MapLayerDictionaryParser::analyseKey(const std::string& key, std::string* type_name,\n                                          float* grid_size, float* tile_size) {\n  std::vector<std::string> substrs;\n  substrs.resize(3);\n\n  // achieve sub strings from key\n  size_t tail = key.size() - 1;\n  for (int i = 0; i < 2; i++) {\n    size_t pos = key.rfind('_', tail);\n    substrs[2 - i] = key.substr(pos + 1, tail - pos);\n    tail = pos - 1;\n  }\n  substrs[0] = key.substr(0, tail + 1);\n\n  // output\n  if (tile_size != nullptr) {\n    *tile_size = std::stof(substrs[2]);\n  }\n  if (grid_size != nullptr) {\n    *grid_size = std::stof(substrs[1]) / grid_size_ratio;\n  }\n  if (type_name != nullptr) {\n    *type_name = substrs[0];\n  }\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp"
		}
	}
]
I0403 13:40:25.478415 32175 json_parser.cpp:18] 
[
	10,
	{
		"bufnr" : 3,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All rights reserved.\n// Authors: Yongjian Zhao (yongjian.zhao@allride.ai)\n\n#include <fstream>\n#include <iostream>\n#include <sstream>\n#include <vector>\n\n#include \"common/io/proto_io.h\"\n#include \"common/proto/config/config_map.pb.h\"\n#include \"map_layer_dictionary_parser.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstatic const float grid_size_ratio = 1000.0f;  // convert from m to mm,\n\nbool MapLayerDictionaryParser::load(const std::string& dict_file) {\n  proto::config::MapLayerDictionary dict;\n  if (!common::ProtoIO::readProtoFromTextFile(dict_file, &dict)) {\n    std::cerr << \"MapLayerDictionaryParser: failed to load from dictionary file!\" << std::endl;\n    std::cerr << \"dict_file: \" << dict_file << std::endl;\n    return false;\n  }\n\n  for (const auto& item : dict.items()) {\n    int layer_id = item.layer_id();\n    std::string type_name = item.type_name();\n    float grid_size = item.grid_size();\n    float tile_size = item.tile_size();\n\n    // compose the key\n    std::string key;\n    composeKey(type_name, grid_size, tile_size, &key);\n\n    // set unordered_map\n    id_to_key_[layer_id] = key;\n    key_to_id_[key] = layer_id;\n  }\n\n  return true;\n}\n\nbool MapLayerDictionaryParser::getInfoById(const int layer_id, std::string* type_name,\n                                           float* grid_size, float* tile_size) {\n  if (id_to_key_.count(layer_id) == 0) {\n    return false;\n  }\n\n  analyseKey(id_to_key_[layer_id], type_name, grid_size, tile_size);\n  return true;\n}\n\nbool MapLayerDictionaryParser::getIdByInfo(const std::string& type_name, const float& grid_size,\n                                           const float& tile_size, int* layer_id) {\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 0) {\n    return false;\n  }\n\n  *layer_id = key_to_id_[key];\n  return true;\n}\n\nfloat MapLayerDictionaryParser::getGridSize(const int layer_id) {\n  float grid_size;\n  if(!getInfoById(layer_id, nullptr, &grid_size, nullptr)){\n  }\n\n  return grid_size;\n}\n\nfloat MapLayerDictionaryParser::getTileSize(const int layer_id) {\n  float tile_size;\n  getInfoById(layer_id, nullptr, nullptr, &tile_size);\n  return tile_size;\n}\n\nstd::string MapLayerDictionaryParser::getTypeName(const int layer_id) {\n  std::string type_name;\n  getInfoById(layer_id, &type_name, nullptr, nullptr);\n  return type_name;\n}\n\nbool MapLayerDictionaryParser::addItem(const int layer_id, const std::string& type_name,\n                                       const float grid_size, const float tile_size) {\n  if (id_to_key_.count(layer_id) == 1) {\n    std::cerr << \"failed to add item: layer_id \" << layer_id << \" has already exited in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 1) {\n    std::cerr << \"failed to add item: layer configuration has already existed in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  id_to_key_[layer_id] = key;\n  key_to_id_[key] = layer_id;\n  return true;\n}\n\nbool MapLayerDictionaryParser::save(const std::string& dict_file) {\n  // sort layer id\n  std::vector<int> layer_ids;\n  for (auto& pair : id_to_key_) {\n    layer_ids.emplace_back(pair.first);\n  }\n  std::sort(layer_ids.begin(), layer_ids.end());\n\n  // add item to dict\n  proto::config::MapLayerDictionary dict;\n  for (auto& id : layer_ids) {\n    // analyze key\n    std::string type_name;\n    float grid_size;\n    float tile_size;\n    analyseKey(id_to_key_[id], &type_name, &grid_size, &tile_size);\n\n    // add item\n    proto::config::MapLayerItem* item = dict.add_items();\n    item->set_layer_id(id);\n    item->set_type_name(type_name);\n    item->set_grid_size(grid_size);\n    item->set_tile_size(tile_size);\n  }\n\n  // write dict to file\n  return common::ProtoIO::writeProtoToTextFile(dict_file, dict);\n}\n\nvoid MapLayerDictionaryParser::composeKey(const std::string& type_name, const float& grid_size,\n                                          const float& tile_size, std::string* key) {\n  std::stringstream str_stream;\n  str_stream << type_name << \"_\" << static_cast<int>(grid_size * grid_size_ratio) << \"_\"\n             << static_cast<int>(tile_size);\n  *key = str_stream.str();\n}\n\nvoid MapLayerDictionaryParser::analyseKey(const std::string& key, std::string* type_name,\n                                          float* grid_size, float* tile_size) {\n  std::vector<std::string> substrs;\n  substrs.resize(3);\n\n  // achieve sub strings from key\n  size_t tail = key.size() - 1;\n  for (int i = 0; i < 2; i++) {\n    size_t pos = key.rfind('_', tail);\n    substrs[2 - i] = key.substr(pos + 1, tail - pos);\n    tail = pos - 1;\n  }\n  substrs[0] = key.substr(0, tail + 1);\n\n  // output\n  if (tile_size != nullptr) {\n    *tile_size = std::stof(substrs[2]);\n  }\n  if (grid_size != nullptr) {\n    *grid_size = std::stof(substrs[1]) / grid_size_ratio;\n  }\n  if (type_name != nullptr) {\n    *type_name = substrs[0];\n  }\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp"
		}
	}
]
I0403 13:40:29.815775 32175 json_parser.cpp:18] 
[
	11,
	{
		"bufnr" : 3,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All rights reserved.\n// Authors: Yongjian Zhao (yongjian.zhao@allride.ai)\n\n#include <fstream>\n#include <iostream>\n#include <sstream>\n#include <vector>\n\n#include \"common/io/proto_io.h\"\n#include \"common/proto/config/config_map.pb.h\"\n#include \"map_layer_dictionary_parser.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstatic const float grid_size_ratio = 1000.0f;  // convert from m to mm,\n\nbool MapLayerDictionaryParser::load(const std::string& dict_file) {\n  proto::config::MapLayerDictionary dict;\n  if (!common::ProtoIO::readProtoFromTextFile(dict_file, &dict)) {\n    std::cerr << \"MapLayerDictionaryParser: failed to load from dictionary file!\" << std::endl;\n    std::cerr << \"dict_file: \" << dict_file << std::endl;\n    return false;\n  }\n\n  for (const auto& item : dict.items()) {\n    int layer_id = item.layer_id();\n    std::string type_name = item.type_name();\n    float grid_size = item.grid_size();\n    float tile_size = item.tile_size();\n\n    // compose the key\n    std::string key;\n    composeKey(type_name, grid_size, tile_size, &key);\n\n    // set unordered_map\n    id_to_key_[layer_id] = key;\n    key_to_id_[key] = layer_id;\n  }\n\n  return true;\n}\n\nbool MapLayerDictionaryParser::getInfoById(const int layer_id, std::string* type_name,\n                                           float* grid_size, float* tile_size) {\n  if (id_to_key_.count(layer_id) == 0) {\n    return false;\n  }\n\n  analyseKey(id_to_key_[layer_id], type_name, grid_size, tile_size);\n  return true;\n}\n\nbool MapLayerDictionaryParser::getIdByInfo(const std::string& type_name, const float& grid_size,\n                                           const float& tile_size, int* layer_id) {\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 0) {\n    return false;\n  }\n\n  *layer_id = key_to_id_[key];\n  return true;\n}\n\nfloat MapLayerDictionaryParser::getGridSize(const int layer_id) {\n  float grid_size;\n  if(!getInfoById(layer_id, nullptr, &grid_size, nullptr)){\n    return -1;\n  }\n\n  return grid_size;\n}\n\nfloat MapLayerDictionaryParser::getTileSize(const int layer_id) {\n  float tile_size;\n  getInfoById(layer_id, nullptr, nullptr, &tile_size);\n  return tile_size;\n}\n\nstd::string MapLayerDictionaryParser::getTypeName(const int layer_id) {\n  std::string type_name;\n  getInfoById(layer_id, &type_name, nullptr, nullptr);\n  return type_name;\n}\n\nbool MapLayerDictionaryParser::addItem(const int layer_id, const std::string& type_name,\n                                       const float grid_size, const float tile_size) {\n  if (id_to_key_.count(layer_id) == 1) {\n    std::cerr << \"failed to add item: layer_id \" << layer_id << \" has already exited in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 1) {\n    std::cerr << \"failed to add item: layer configuration has already existed in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  id_to_key_[layer_id] = key;\n  key_to_id_[key] = layer_id;\n  return true;\n}\n\nbool MapLayerDictionaryParser::save(const std::string& dict_file) {\n  // sort layer id\n  std::vector<int> layer_ids;\n  for (auto& pair : id_to_key_) {\n    layer_ids.emplace_back(pair.first);\n  }\n  std::sort(layer_ids.begin(), layer_ids.end());\n\n  // add item to dict\n  proto::config::MapLayerDictionary dict;\n  for (auto& id : layer_ids) {\n    // analyze key\n    std::string type_name;\n    float grid_size;\n    float tile_size;\n    analyseKey(id_to_key_[id], &type_name, &grid_size, &tile_size);\n\n    // add item\n    proto::config::MapLayerItem* item = dict.add_items();\n    item->set_layer_id(id);\n    item->set_type_name(type_name);\n    item->set_grid_size(grid_size);\n    item->set_tile_size(tile_size);\n  }\n\n  // write dict to file\n  return common::ProtoIO::writeProtoToTextFile(dict_file, dict);\n}\n\nvoid MapLayerDictionaryParser::composeKey(const std::string& type_name, const float& grid_size,\n                                          const float& tile_size, std::string* key) {\n  std::stringstream str_stream;\n  str_stream << type_name << \"_\" << static_cast<int>(grid_size * grid_size_ratio) << \"_\"\n             << static_cast<int>(tile_size);\n  *key = str_stream.str();\n}\n\nvoid MapLayerDictionaryParser::analyseKey(const std::string& key, std::string* type_name,\n                                          float* grid_size, float* tile_size) {\n  std::vector<std::string> substrs;\n  substrs.resize(3);\n\n  // achieve sub strings from key\n  size_t tail = key.size() - 1;\n  for (int i = 0; i < 2; i++) {\n    size_t pos = key.rfind('_', tail);\n    substrs[2 - i] = key.substr(pos + 1, tail - pos);\n    tail = pos - 1;\n  }\n  substrs[0] = key.substr(0, tail + 1);\n\n  // output\n  if (tile_size != nullptr) {\n    *tile_size = std::stof(substrs[2]);\n  }\n  if (grid_size != nullptr) {\n    *grid_size = std::stof(substrs[1]) / grid_size_ratio;\n  }\n  if (type_name != nullptr) {\n    *type_name = substrs[0];\n  }\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp"
		}
	}
]
I0403 13:40:33.991394 32175 json_parser.cpp:18] 
[
	12,
	{
		"bufnr" : 3,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All rights reserved.\n// Authors: Yongjian Zhao (yongjian.zhao@allride.ai)\n\n#include <fstream>\n#include <iostream>\n#include <sstream>\n#include <vector>\n\n#include \"common/io/proto_io.h\"\n#include \"common/proto/config/config_map.pb.h\"\n#include \"map_layer_dictionary_parser.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstatic const float grid_size_ratio = 1000.0f;  // convert from m to mm,\n\nbool MapLayerDictionaryParser::load(const std::string& dict_file) {\n  proto::config::MapLayerDictionary dict;\n  if (!common::ProtoIO::readProtoFromTextFile(dict_file, &dict)) {\n    std::cerr << \"MapLayerDictionaryParser: failed to load from dictionary file!\" << std::endl;\n    std::cerr << \"dict_file: \" << dict_file << std::endl;\n    return false;\n  }\n\n  for (const auto& item : dict.items()) {\n    int layer_id = item.layer_id();\n    std::string type_name = item.type_name();\n    float grid_size = item.grid_size();\n    float tile_size = item.tile_size();\n\n    // compose the key\n    std::string key;\n    composeKey(type_name, grid_size, tile_size, &key);\n\n    // set unordered_map\n    id_to_key_[layer_id] = key;\n    key_to_id_[key] = layer_id;\n  }\n\n  return true;\n}\n\nbool MapLayerDictionaryParser::getInfoById(const int layer_id, std::string* type_name,\n                                           float* grid_size, float* tile_size) {\n  if (id_to_key_.count(layer_id) == 0) {\n    return false;\n  }\n\n  analyseKey(id_to_key_[layer_id], type_name, grid_size, tile_size);\n  return true;\n}\n\nbool MapLayerDictionaryParser::getIdByInfo(const std::string& type_name, const float& grid_size,\n                                           const float& tile_size, int* layer_id) {\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 0) {\n    return false;\n  }\n\n  *layer_id = key_to_id_[key];\n  return true;\n}\n\nfloat MapLayerDictionaryParser::getGridSize(const int layer_id) {\n  float grid_size;\n  if(!getInfoById(layer_id, nullptr, &grid_size, nullptr)){\n    return -1;\n  }\n\n  return grid_size;\n}\n\nfloat MapLayerDictionaryParser::getTileSize(const int layer_id) {\n  float tile_size;\n  getInfoById(layer_id, nullptr, nullptr, &tile_size);\n  return tile_size;\n}\n\nstd::string MapLayerDictionaryParser::getTypeName(const int layer_id) {\n  std::string type_name;\n  getInfoById(layer_id, &type_name, nullptr, nullptr);\n  return type_name;\n}\n\nbool MapLayerDictionaryParser::addItem(const int layer_id, const std::string& type_name,\n                                       const float grid_size, const float tile_size) {\n  if (id_to_key_.count(layer_id) == 1) {\n    std::cerr << \"failed to add item: layer_id \" << layer_id << \" has already exited in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 1) {\n    std::cerr << \"failed to add item: layer configuration has already existed in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  id_to_key_[layer_id] = key;\n  key_to_id_[key] = layer_id;\n  return true;\n}\n\nbool MapLayerDictionaryParser::save(const std::string& dict_file) {\n  // sort layer id\n  std::vector<int> layer_ids;\n  for (auto& pair : id_to_key_) {\n    layer_ids.emplace_back(pair.first);\n  }\n  std::sort(layer_ids.begin(), layer_ids.end());\n\n  // add item to dict\n  proto::config::MapLayerDictionary dict;\n  for (auto& id : layer_ids) {\n    // analyze key\n    std::string type_name;\n    float grid_size;\n    float tile_size;\n    analyseKey(id_to_key_[id], &type_name, &grid_size, &tile_size);\n\n    // add item\n    proto::config::MapLayerItem* item = dict.add_items();\n    item->set_layer_id(id);\n    item->set_type_name(type_name);\n    item->set_grid_size(grid_size);\n    item->set_tile_size(tile_size);\n  }\n\n  // write dict to file\n  return common::ProtoIO::writeProtoToTextFile(dict_file, dict);\n}\n\nvoid MapLayerDictionaryParser::composeKey(const std::string& type_name, const float& grid_size,\n                                          const float& tile_size, std::string* key) {\n  std::stringstream str_stream;\n  str_stream << type_name << \"_\" << static_cast<int>(grid_size * grid_size_ratio) << \"_\"\n             << static_cast<int>(tile_size);\n  *key = str_stream.str();\n}\n\nvoid MapLayerDictionaryParser::analyseKey(const std::string& key, std::string* type_name,\n                                          float* grid_size, float* tile_size) {\n  std::vector<std::string> substrs;\n  substrs.resize(3);\n\n  // achieve sub strings from key\n  size_t tail = key.size() - 1;\n  for (int i = 0; i < 2; i++) {\n    size_t pos = key.rfind('_', tail);\n    substrs[2 - i] = key.substr(pos + 1, tail - pos);\n    tail = pos - 1;\n  }\n  substrs[0] = key.substr(0, tail + 1);\n\n  // output\n  if (tile_size != nullptr) {\n    *tile_size = std::stof(substrs[2]);\n  }\n  if (grid_size != nullptr) {\n    *grid_size = std::stof(substrs[1]) / grid_size_ratio;\n  }\n  if (type_name != nullptr) {\n    *type_name = substrs[0];\n  }\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp"
		}
	}
]
I0403 13:40:54.037561 32175 json_parser.cpp:18] 
[
	13,
	{
		"bufnr" : 3,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All rights reserved.\n// Authors: Yongjian Zhao (yongjian.zhao@allride.ai)\n\n#include <fstream>\n#include <iostream>\n#include <sstream>\n#include <vector>\n\n#include \"common/io/proto_io.h\"\n#include \"common/proto/config/config_map.pb.h\"\n#include \"map_layer_dictionary_parser.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstatic const float grid_size_ratio = 1000.0f;  // convert from m to mm,\n\nbool MapLayerDictionaryParser::load(const std::string& dict_file) {\n  proto::config::MapLayerDictionary dict;\n  if (!common::ProtoIO::readProtoFromTextFile(dict_file, &dict)) {\n    std::cerr << \"MapLayerDictionaryParser: failed to load from dictionary file!\" << std::endl;\n    std::cerr << \"dict_file: \" << dict_file << std::endl;\n    return false;\n  }\n\n  for (const auto& item : dict.items()) {\n    int layer_id = item.layer_id();\n    std::string type_name = item.type_name();\n    float grid_size = item.grid_size();\n    float tile_size = item.tile_size();\n\n    // compose the key\n    std::string key;\n    composeKey(type_name, grid_size, tile_size, &key);\n\n    // set unordered_map\n    id_to_key_[layer_id] = key;\n    key_to_id_[key] = layer_id;\n  }\n\n  return true;\n}\n\nbool MapLayerDictionaryParser::getInfoById(const int layer_id, std::string* type_name,\n                                           float* grid_size, float* tile_size) {\n  if (id_to_key_.count(layer_id) == 0) {\n    return false;\n  }\n\n  analyseKey(id_to_key_[layer_id], type_name, grid_size, tile_size);\n  return true;\n}\n\nbool MapLayerDictionaryParser::getIdByInfo(const std::string& type_name, const float& grid_size,\n                                           const float& tile_size, int* layer_id) {\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 0) {\n    return false;\n  }\n\n  *layer_id = key_to_id_[key];\n  return true;\n}\n\nfloat MapLayerDictionaryParser::getGridSize(const int layer_id) {\n  float grid_size;\n  if(!getInfoById(layer_id, nullptr, &grid_size, nullptr)){\n    return -1; // return a negtive value for invalid layer_id\n  }\n\n  return grid_size;\n}\n\nfloat MapLayerDictionaryParser::getTileSize(const int layer_id) {\n  float tile_size;\n  getInfoById(layer_id, nullptr, nullptr, &tile_size);\n  return tile_size;\n}\n\nstd::string MapLayerDictionaryParser::getTypeName(const int layer_id) {\n  std::string type_name;\n  getInfoById(layer_id, &type_name, nullptr, nullptr);\n  return type_name;\n}\n\nbool MapLayerDictionaryParser::addItem(const int layer_id, const std::string& type_name,\n                                       const float grid_size, const float tile_size) {\n  if (id_to_key_.count(layer_id) == 1) {\n    std::cerr << \"failed to add item: layer_id \" << layer_id << \" has already exited in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 1) {\n    std::cerr << \"failed to add item: layer configuration has already existed in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  id_to_key_[layer_id] = key;\n  key_to_id_[key] = layer_id;\n  return true;\n}\n\nbool MapLayerDictionaryParser::save(const std::string& dict_file) {\n  // sort layer id\n  std::vector<int> layer_ids;\n  for (auto& pair : id_to_key_) {\n    layer_ids.emplace_back(pair.first);\n  }\n  std::sort(layer_ids.begin(), layer_ids.end());\n\n  // add item to dict\n  proto::config::MapLayerDictionary dict;\n  for (auto& id : layer_ids) {\n    // analyze key\n    std::string type_name;\n    float grid_size;\n    float tile_size;\n    analyseKey(id_to_key_[id], &type_name, &grid_size, &tile_size);\n\n    // add item\n    proto::config::MapLayerItem* item = dict.add_items();\n    item->set_layer_id(id);\n    item->set_type_name(type_name);\n    item->set_grid_size(grid_size);\n    item->set_tile_size(tile_size);\n  }\n\n  // write dict to file\n  return common::ProtoIO::writeProtoToTextFile(dict_file, dict);\n}\n\nvoid MapLayerDictionaryParser::composeKey(const std::string& type_name, const float& grid_size,\n                                          const float& tile_size, std::string* key) {\n  std::stringstream str_stream;\n  str_stream << type_name << \"_\" << static_cast<int>(grid_size * grid_size_ratio) << \"_\"\n             << static_cast<int>(tile_size);\n  *key = str_stream.str();\n}\n\nvoid MapLayerDictionaryParser::analyseKey(const std::string& key, std::string* type_name,\n                                          float* grid_size, float* tile_size) {\n  std::vector<std::string> substrs;\n  substrs.resize(3);\n\n  // achieve sub strings from key\n  size_t tail = key.size() - 1;\n  for (int i = 0; i < 2; i++) {\n    size_t pos = key.rfind('_', tail);\n    substrs[2 - i] = key.substr(pos + 1, tail - pos);\n    tail = pos - 1;\n  }\n  substrs[0] = key.substr(0, tail + 1);\n\n  // output\n  if (tile_size != nullptr) {\n    *tile_size = std::stof(substrs[2]);\n  }\n  if (grid_size != nullptr) {\n    *grid_size = std::stof(substrs[1]) / grid_size_ratio;\n  }\n  if (type_name != nullptr) {\n    *type_name = substrs[0];\n  }\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp"
		}
	}
]
I0403 13:41:01.134368 32175 json_parser.cpp:18] 
[
	14,
	{
		"bufnr" : 3,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All rights reserved.\n// Authors: Yongjian Zhao (yongjian.zhao@allride.ai)\n\n#include <fstream>\n#include <iostream>\n#include <sstream>\n#include <vector>\n\n#include \"common/io/proto_io.h\"\n#include \"common/proto/config/config_map.pb.h\"\n#include \"map_layer_dictionary_parser.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstatic const float grid_size_ratio = 1000.0f;  // convert from m to mm,\n\nbool MapLayerDictionaryParser::load(const std::string& dict_file) {\n  proto::config::MapLayerDictionary dict;\n  if (!common::ProtoIO::readProtoFromTextFile(dict_file, &dict)) {\n    std::cerr << \"MapLayerDictionaryParser: failed to load from dictionary file!\" << std::endl;\n    std::cerr << \"dict_file: \" << dict_file << std::endl;\n    return false;\n  }\n\n  for (const auto& item : dict.items()) {\n    int layer_id = item.layer_id();\n    std::string type_name = item.type_name();\n    float grid_size = item.grid_size();\n    float tile_size = item.tile_size();\n\n    // compose the key\n    std::string key;\n    composeKey(type_name, grid_size, tile_size, &key);\n\n    // set unordered_map\n    id_to_key_[layer_id] = key;\n    key_to_id_[key] = layer_id;\n  }\n\n  return true;\n}\n\nbool MapLayerDictionaryParser::getInfoById(const int layer_id, std::string* type_name,\n                                           float* grid_size, float* tile_size) {\n  if (id_to_key_.count(layer_id) == 0) {\n    return false;\n  }\n\n  analyseKey(id_to_key_[layer_id], type_name, grid_size, tile_size);\n  return true;\n}\n\nbool MapLayerDictionaryParser::getIdByInfo(const std::string& type_name, const float& grid_size,\n                                           const float& tile_size, int* layer_id) {\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 0) {\n    return false;\n  }\n\n  *layer_id = key_to_id_[key];\n  return true;\n}\n\nfloat MapLayerDictionaryParser::getGridSize(const int layer_id) {\n  float grid_size;\n  if(!getInfoById(layer_id, nullptr, &grid_size, nullptr)){\n    return -1; // return a negtive value for invalid layer_id\n  }\n\n  return grid_size;\n}\n\nfloat MapLayerDictionaryParser::getTileSize(const int layer_id) {\n  float tile_size;\n  \n  getInfoById(layer_id, nullptr, nullptr, &tile_size);\n  return tile_size;\n}\n\nstd::string MapLayerDictionaryParser::getTypeName(const int layer_id) {\n  std::string type_name;\n  getInfoById(layer_id, &type_name, nullptr, nullptr);\n  return type_name;\n}\n\nbool MapLayerDictionaryParser::addItem(const int layer_id, const std::string& type_name,\n                                       const float grid_size, const float tile_size) {\n  if (id_to_key_.count(layer_id) == 1) {\n    std::cerr << \"failed to add item: layer_id \" << layer_id << \" has already exited in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 1) {\n    std::cerr << \"failed to add item: layer configuration has already existed in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  id_to_key_[layer_id] = key;\n  key_to_id_[key] = layer_id;\n  return true;\n}\n\nbool MapLayerDictionaryParser::save(const std::string& dict_file) {\n  // sort layer id\n  std::vector<int> layer_ids;\n  for (auto& pair : id_to_key_) {\n    layer_ids.emplace_back(pair.first);\n  }\n  std::sort(layer_ids.begin(), layer_ids.end());\n\n  // add item to dict\n  proto::config::MapLayerDictionary dict;\n  for (auto& id : layer_ids) {\n    // analyze key\n    std::string type_name;\n    float grid_size;\n    float tile_size;\n    analyseKey(id_to_key_[id], &type_name, &grid_size, &tile_size);\n\n    // add item\n    proto::config::MapLayerItem* item = dict.add_items();\n    item->set_layer_id(id);\n    item->set_type_name(type_name);\n    item->set_grid_size(grid_size);\n    item->set_tile_size(tile_size);\n  }\n\n  // write dict to file\n  return common::ProtoIO::writeProtoToTextFile(dict_file, dict);\n}\n\nvoid MapLayerDictionaryParser::composeKey(const std::string& type_name, const float& grid_size,\n                                          const float& tile_size, std::string* key) {\n  std::stringstream str_stream;\n  str_stream << type_name << \"_\" << static_cast<int>(grid_size * grid_size_ratio) << \"_\"\n             << static_cast<int>(tile_size);\n  *key = str_stream.str();\n}\n\nvoid MapLayerDictionaryParser::analyseKey(const std::string& key, std::string* type_name,\n                                          float* grid_size, float* tile_size) {\n  std::vector<std::string> substrs;\n  substrs.resize(3);\n\n  // achieve sub strings from key\n  size_t tail = key.size() - 1;\n  for (int i = 0; i < 2; i++) {\n    size_t pos = key.rfind('_', tail);\n    substrs[2 - i] = key.substr(pos + 1, tail - pos);\n    tail = pos - 1;\n  }\n  substrs[0] = key.substr(0, tail + 1);\n\n  // output\n  if (tile_size != nullptr) {\n    *tile_size = std::stof(substrs[2]);\n  }\n  if (grid_size != nullptr) {\n    *grid_size = std::stof(substrs[1]) / grid_size_ratio;\n  }\n  if (type_name != nullptr) {\n    *type_name = substrs[0];\n  }\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp"
		}
	}
]
I0403 13:41:02.325091 32175 json_parser.cpp:18] 
[
	15,
	{
		"bufnr" : 3,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All rights reserved.\n// Authors: Yongjian Zhao (yongjian.zhao@allride.ai)\n\n#include <fstream>\n#include <iostream>\n#include <sstream>\n#include <vector>\n\n#include \"common/io/proto_io.h\"\n#include \"common/proto/config/config_map.pb.h\"\n#include \"map_layer_dictionary_parser.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstatic const float grid_size_ratio = 1000.0f;  // convert from m to mm,\n\nbool MapLayerDictionaryParser::load(const std::string& dict_file) {\n  proto::config::MapLayerDictionary dict;\n  if (!common::ProtoIO::readProtoFromTextFile(dict_file, &dict)) {\n    std::cerr << \"MapLayerDictionaryParser: failed to load from dictionary file!\" << std::endl;\n    std::cerr << \"dict_file: \" << dict_file << std::endl;\n    return false;\n  }\n\n  for (const auto& item : dict.items()) {\n    int layer_id = item.layer_id();\n    std::string type_name = item.type_name();\n    float grid_size = item.grid_size();\n    float tile_size = item.tile_size();\n\n    // compose the key\n    std::string key;\n    composeKey(type_name, grid_size, tile_size, &key);\n\n    // set unordered_map\n    id_to_key_[layer_id] = key;\n    key_to_id_[key] = layer_id;\n  }\n\n  return true;\n}\n\nbool MapLayerDictionaryParser::getInfoById(const int layer_id, std::string* type_name,\n                                           float* grid_size, float* tile_size) {\n  if (id_to_key_.count(layer_id) == 0) {\n    return false;\n  }\n\n  analyseKey(id_to_key_[layer_id], type_name, grid_size, tile_size);\n  return true;\n}\n\nbool MapLayerDictionaryParser::getIdByInfo(const std::string& type_name, const float& grid_size,\n                                           const float& tile_size, int* layer_id) {\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 0) {\n    return false;\n  }\n\n  *layer_id = key_to_id_[key];\n  return true;\n}\n\nfloat MapLayerDictionaryParser::getGridSize(const int layer_id) {\n  float grid_size;\n  if(!getInfoById(layer_id, nullptr, &grid_size, nullptr)){\n    return -1; // return a negtive value for invalid layer_id\n  }\n\n  return grid_size;\n}\n\nfloat MapLayerDictionaryParser::getTileSize(const int layer_id) {\n  float tile_size;\n  if()\n  getInfoById(layer_id, nullptr, nullptr, &tile_size);\n  return tile_size;\n}\n\nstd::string MapLayerDictionaryParser::getTypeName(const int layer_id) {\n  std::string type_name;\n  getInfoById(layer_id, &type_name, nullptr, nullptr);\n  return type_name;\n}\n\nbool MapLayerDictionaryParser::addItem(const int layer_id, const std::string& type_name,\n                                       const float grid_size, const float tile_size) {\n  if (id_to_key_.count(layer_id) == 1) {\n    std::cerr << \"failed to add item: layer_id \" << layer_id << \" has already exited in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 1) {\n    std::cerr << \"failed to add item: layer configuration has already existed in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  id_to_key_[layer_id] = key;\n  key_to_id_[key] = layer_id;\n  return true;\n}\n\nbool MapLayerDictionaryParser::save(const std::string& dict_file) {\n  // sort layer id\n  std::vector<int> layer_ids;\n  for (auto& pair : id_to_key_) {\n    layer_ids.emplace_back(pair.first);\n  }\n  std::sort(layer_ids.begin(), layer_ids.end());\n\n  // add item to dict\n  proto::config::MapLayerDictionary dict;\n  for (auto& id : layer_ids) {\n    // analyze key\n    std::string type_name;\n    float grid_size;\n    float tile_size;\n    analyseKey(id_to_key_[id], &type_name, &grid_size, &tile_size);\n\n    // add item\n    proto::config::MapLayerItem* item = dict.add_items();\n    item->set_layer_id(id);\n    item->set_type_name(type_name);\n    item->set_grid_size(grid_size);\n    item->set_tile_size(tile_size);\n  }\n\n  // write dict to file\n  return common::ProtoIO::writeProtoToTextFile(dict_file, dict);\n}\n\nvoid MapLayerDictionaryParser::composeKey(const std::string& type_name, const float& grid_size,\n                                          const float& tile_size, std::string* key) {\n  std::stringstream str_stream;\n  str_stream << type_name << \"_\" << static_cast<int>(grid_size * grid_size_ratio) << \"_\"\n             << static_cast<int>(tile_size);\n  *key = str_stream.str();\n}\n\nvoid MapLayerDictionaryParser::analyseKey(const std::string& key, std::string* type_name,\n                                          float* grid_size, float* tile_size) {\n  std::vector<std::string> substrs;\n  substrs.resize(3);\n\n  // achieve sub strings from key\n  size_t tail = key.size() - 1;\n  for (int i = 0; i < 2; i++) {\n    size_t pos = key.rfind('_', tail);\n    substrs[2 - i] = key.substr(pos + 1, tail - pos);\n    tail = pos - 1;\n  }\n  substrs[0] = key.substr(0, tail + 1);\n\n  // output\n  if (tile_size != nullptr) {\n    *tile_size = std::stof(substrs[2]);\n  }\n  if (grid_size != nullptr) {\n    *grid_size = std::stof(substrs[1]) / grid_size_ratio;\n  }\n  if (type_name != nullptr) {\n    *type_name = substrs[0];\n  }\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp"
		}
	}
]
I0403 13:41:03.283568 32175 json_parser.cpp:18] 
[
	16,
	{
		"bufnr" : 3,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All rights reserved.\n// Authors: Yongjian Zhao (yongjian.zhao@allride.ai)\n\n#include <fstream>\n#include <iostream>\n#include <sstream>\n#include <vector>\n\n#include \"common/io/proto_io.h\"\n#include \"common/proto/config/config_map.pb.h\"\n#include \"map_layer_dictionary_parser.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstatic const float grid_size_ratio = 1000.0f;  // convert from m to mm,\n\nbool MapLayerDictionaryParser::load(const std::string& dict_file) {\n  proto::config::MapLayerDictionary dict;\n  if (!common::ProtoIO::readProtoFromTextFile(dict_file, &dict)) {\n    std::cerr << \"MapLayerDictionaryParser: failed to load from dictionary file!\" << std::endl;\n    std::cerr << \"dict_file: \" << dict_file << std::endl;\n    return false;\n  }\n\n  for (const auto& item : dict.items()) {\n    int layer_id = item.layer_id();\n    std::string type_name = item.type_name();\n    float grid_size = item.grid_size();\n    float tile_size = item.tile_size();\n\n    // compose the key\n    std::string key;\n    composeKey(type_name, grid_size, tile_size, &key);\n\n    // set unordered_map\n    id_to_key_[layer_id] = key;\n    key_to_id_[key] = layer_id;\n  }\n\n  return true;\n}\n\nbool MapLayerDictionaryParser::getInfoById(const int layer_id, std::string* type_name,\n                                           float* grid_size, float* tile_size) {\n  if (id_to_key_.count(layer_id) == 0) {\n    return false;\n  }\n\n  analyseKey(id_to_key_[layer_id], type_name, grid_size, tile_size);\n  return true;\n}\n\nbool MapLayerDictionaryParser::getIdByInfo(const std::string& type_name, const float& grid_size,\n                                           const float& tile_size, int* layer_id) {\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 0) {\n    return false;\n  }\n\n  *layer_id = key_to_id_[key];\n  return true;\n}\n\nfloat MapLayerDictionaryParser::getGridSize(const int layer_id) {\n  float grid_size;\n  if(!getInfoById(layer_id, nullptr, &grid_size, nullptr)){\n    return -1; // return a negtive value for invalid layer_id\n  }\n\n  return grid_size;\n}\n\nfloat MapLayerDictionaryParser::getTileSize(const int layer_id) {\n  float tile_size;\n  getInfoById(layer_id, nullptr, nullptr, &tile_size);\n  return tile_size;\n}\n\nstd::string MapLayerDictionaryParser::getTypeName(const int layer_id) {\n  std::string type_name;\n  getInfoById(layer_id, &type_name, nullptr, nullptr);\n  return type_name;\n}\n\nbool MapLayerDictionaryParser::addItem(const int layer_id, const std::string& type_name,\n                                       const float grid_size, const float tile_size) {\n  if (id_to_key_.count(layer_id) == 1) {\n    std::cerr << \"failed to add item: layer_id \" << layer_id << \" has already exited in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 1) {\n    std::cerr << \"failed to add item: layer configuration has already existed in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  id_to_key_[layer_id] = key;\n  key_to_id_[key] = layer_id;\n  return true;\n}\n\nbool MapLayerDictionaryParser::save(const std::string& dict_file) {\n  // sort layer id\n  std::vector<int> layer_ids;\n  for (auto& pair : id_to_key_) {\n    layer_ids.emplace_back(pair.first);\n  }\n  std::sort(layer_ids.begin(), layer_ids.end());\n\n  // add item to dict\n  proto::config::MapLayerDictionary dict;\n  for (auto& id : layer_ids) {\n    // analyze key\n    std::string type_name;\n    float grid_size;\n    float tile_size;\n    analyseKey(id_to_key_[id], &type_name, &grid_size, &tile_size);\n\n    // add item\n    proto::config::MapLayerItem* item = dict.add_items();\n    item->set_layer_id(id);\n    item->set_type_name(type_name);\n    item->set_grid_size(grid_size);\n    item->set_tile_size(tile_size);\n  }\n\n  // write dict to file\n  return common::ProtoIO::writeProtoToTextFile(dict_file, dict);\n}\n\nvoid MapLayerDictionaryParser::composeKey(const std::string& type_name, const float& grid_size,\n                                          const float& tile_size, std::string* key) {\n  std::stringstream str_stream;\n  str_stream << type_name << \"_\" << static_cast<int>(grid_size * grid_size_ratio) << \"_\"\n             << static_cast<int>(tile_size);\n  *key = str_stream.str();\n}\n\nvoid MapLayerDictionaryParser::analyseKey(const std::string& key, std::string* type_name,\n                                          float* grid_size, float* tile_size) {\n  std::vector<std::string> substrs;\n  substrs.resize(3);\n\n  // achieve sub strings from key\n  size_t tail = key.size() - 1;\n  for (int i = 0; i < 2; i++) {\n    size_t pos = key.rfind('_', tail);\n    substrs[2 - i] = key.substr(pos + 1, tail - pos);\n    tail = pos - 1;\n  }\n  substrs[0] = key.substr(0, tail + 1);\n\n  // output\n  if (tile_size != nullptr) {\n    *tile_size = std::stof(substrs[2]);\n  }\n  if (grid_size != nullptr) {\n    *grid_size = std::stof(substrs[1]) / grid_size_ratio;\n  }\n  if (type_name != nullptr) {\n    *type_name = substrs[0];\n  }\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp"
		}
	}
]
I0403 13:41:03.789599 32175 json_parser.cpp:18] 
[
	17,
	{
		"bufnr" : 3,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All rights reserved.\n// Authors: Yongjian Zhao (yongjian.zhao@allride.ai)\n\n#include <fstream>\n#include <iostream>\n#include <sstream>\n#include <vector>\n\n#include \"common/io/proto_io.h\"\n#include \"common/proto/config/config_map.pb.h\"\n#include \"map_layer_dictionary_parser.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstatic const float grid_size_ratio = 1000.0f;  // convert from m to mm,\n\nbool MapLayerDictionaryParser::load(const std::string& dict_file) {\n  proto::config::MapLayerDictionary dict;\n  if (!common::ProtoIO::readProtoFromTextFile(dict_file, &dict)) {\n    std::cerr << \"MapLayerDictionaryParser: failed to load from dictionary file!\" << std::endl;\n    std::cerr << \"dict_file: \" << dict_file << std::endl;\n    return false;\n  }\n\n  for (const auto& item : dict.items()) {\n    int layer_id = item.layer_id();\n    std::string type_name = item.type_name();\n    float grid_size = item.grid_size();\n    float tile_size = item.tile_size();\n\n    // compose the key\n    std::string key;\n    composeKey(type_name, grid_size, tile_size, &key);\n\n    // set unordered_map\n    id_to_key_[layer_id] = key;\n    key_to_id_[key] = layer_id;\n  }\n\n  return true;\n}\n\nbool MapLayerDictionaryParser::getInfoById(const int layer_id, std::string* type_name,\n                                           float* grid_size, float* tile_size) {\n  if (id_to_key_.count(layer_id) == 0) {\n    return false;\n  }\n\n  analyseKey(id_to_key_[layer_id], type_name, grid_size, tile_size);\n  return true;\n}\n\nbool MapLayerDictionaryParser::getIdByInfo(const std::string& type_name, const float& grid_size,\n                                           const float& tile_size, int* layer_id) {\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 0) {\n    return false;\n  }\n\n  *layer_id = key_to_id_[key];\n  return true;\n}\n\nfloat MapLayerDictionaryParser::getGridSize(const int layer_id) {\n  float grid_size;\n  if(!getInfoById(layer_id, nullptr, &grid_size, nullptr)){\n    return -1; // return a negtive value for invalid layer_id\n  }\n\n  return grid_size;\n}\n\nfloat MapLayerDictionaryParser::getTileSize(const int layer_id) {\n  float tile_size;\n  getInfoById(layer_id, nullptr, nullptr, &tile_size);\n  return tile_size;\n}\n\nstd::string MapLayerDictionaryParser::getTypeName(const int layer_id) {\n  std::string type_name;\n  getInfoById(layer_id, &type_name, nullptr, nullptr);\n  return type_name;\n}\n\nbool MapLayerDictionaryParser::addItem(const int layer_id, const std::string& type_name,\n                                       const float grid_size, const float tile_size) {\n  if (id_to_key_.count(layer_id) == 1) {\n    std::cerr << \"failed to add item: layer_id \" << layer_id << \" has already exited in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 1) {\n    std::cerr << \"failed to add item: layer configuration has already existed in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  id_to_key_[layer_id] = key;\n  key_to_id_[key] = layer_id;\n  return true;\n}\n\nbool MapLayerDictionaryParser::save(const std::string& dict_file) {\n  // sort layer id\n  std::vector<int> layer_ids;\n  for (auto& pair : id_to_key_) {\n    layer_ids.emplace_back(pair.first);\n  }\n  std::sort(layer_ids.begin(), layer_ids.end());\n\n  // add item to dict\n  proto::config::MapLayerDictionary dict;\n  for (auto& id : layer_ids) {\n    // analyze key\n    std::string type_name;\n    float grid_size;\n    float tile_size;\n    analyseKey(id_to_key_[id], &type_name, &grid_size, &tile_size);\n\n    // add item\n    proto::config::MapLayerItem* item = dict.add_items();\n    item->set_layer_id(id);\n    item->set_type_name(type_name);\n    item->set_grid_size(grid_size);\n    item->set_tile_size(tile_size);\n  }\n\n  // write dict to file\n  return common::ProtoIO::writeProtoToTextFile(dict_file, dict);\n}\n\nvoid MapLayerDictionaryParser::composeKey(const std::string& type_name, const float& grid_size,\n                                          const float& tile_size, std::string* key) {\n  std::stringstream str_stream;\n  str_stream << type_name << \"_\" << static_cast<int>(grid_size * grid_size_ratio) << \"_\"\n             << static_cast<int>(tile_size);\n  *key = str_stream.str();\n}\n\nvoid MapLayerDictionaryParser::analyseKey(const std::string& key, std::string* type_name,\n                                          float* grid_size, float* tile_size) {\n  std::vector<std::string> substrs;\n  substrs.resize(3);\n\n  // achieve sub strings from key\n  size_t tail = key.size() - 1;\n  for (int i = 0; i < 2; i++) {\n    size_t pos = key.rfind('_', tail);\n    substrs[2 - i] = key.substr(pos + 1, tail - pos);\n    tail = pos - 1;\n  }\n  substrs[0] = key.substr(0, tail + 1);\n\n  // output\n  if (tile_size != nullptr) {\n    *tile_size = std::stof(substrs[2]);\n  }\n  if (grid_size != nullptr) {\n    *grid_size = std::stof(substrs[1]) / grid_size_ratio;\n  }\n  if (type_name != nullptr) {\n    *type_name = substrs[0];\n  }\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp"
		}
	}
]
I0403 13:41:06.548130 32175 json_parser.cpp:18] 
[
	18,
	{
		"bufnr" : 3,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All rights reserved.\n// Authors: Yongjian Zhao (yongjian.zhao@allride.ai)\n\n#include <fstream>\n#include <iostream>\n#include <sstream>\n#include <vector>\n\n#include \"common/io/proto_io.h\"\n#include \"common/proto/config/config_map.pb.h\"\n#include \"map_layer_dictionary_parser.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstatic const float grid_size_ratio = 1000.0f;  // convert from m to mm,\n\nbool MapLayerDictionaryParser::load(const std::string& dict_file) {\n  proto::config::MapLayerDictionary dict;\n  if (!common::ProtoIO::readProtoFromTextFile(dict_file, &dict)) {\n    std::cerr << \"MapLayerDictionaryParser: failed to load from dictionary file!\" << std::endl;\n    std::cerr << \"dict_file: \" << dict_file << std::endl;\n    return false;\n  }\n\n  for (const auto& item : dict.items()) {\n    int layer_id = item.layer_id();\n    std::string type_name = item.type_name();\n    float grid_size = item.grid_size();\n    float tile_size = item.tile_size();\n\n    // compose the key\n    std::string key;\n    composeKey(type_name, grid_size, tile_size, &key);\n\n    // set unordered_map\n    id_to_key_[layer_id] = key;\n    key_to_id_[key] = layer_id;\n  }\n\n  return true;\n}\n\nbool MapLayerDictionaryParser::getInfoById(const int layer_id, std::string* type_name,\n                                           float* grid_size, float* tile_size) {\n  if (id_to_key_.count(layer_id) == 0) {\n    return false;\n  }\n\n  analyseKey(id_to_key_[layer_id], type_name, grid_size, tile_size);\n  return true;\n}\n\nbool MapLayerDictionaryParser::getIdByInfo(const std::string& type_name, const float& grid_size,\n                                           const float& tile_size, int* layer_id) {\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 0) {\n    return false;\n  }\n\n  *layer_id = key_to_id_[key];\n  return true;\n}\n\nfloat MapLayerDictionaryParser::getGridSize(const int layer_id) {\n  float grid_size;\n  if(!getInfoById(layer_id, nullptr, &grid_size, nullptr)){\n    return -1; // return a negtive value for invalid layer_id\n  }\n\n  return grid_size;\n}\n\nfloat MapLayerDictionaryParser::getTileSize(const int layer_id) {\n  float tile_size;\n  if(!getInfoById(layer_id, nullptr, nullptr, &tile_size);\n  return tile_size;\n}\n\nstd::string MapLayerDictionaryParser::getTypeName(const int layer_id) {\n  std::string type_name;\n  getInfoById(layer_id, &type_name, nullptr, nullptr);\n  return type_name;\n}\n\nbool MapLayerDictionaryParser::addItem(const int layer_id, const std::string& type_name,\n                                       const float grid_size, const float tile_size) {\n  if (id_to_key_.count(layer_id) == 1) {\n    std::cerr << \"failed to add item: layer_id \" << layer_id << \" has already exited in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 1) {\n    std::cerr << \"failed to add item: layer configuration has already existed in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  id_to_key_[layer_id] = key;\n  key_to_id_[key] = layer_id;\n  return true;\n}\n\nbool MapLayerDictionaryParser::save(const std::string& dict_file) {\n  // sort layer id\n  std::vector<int> layer_ids;\n  for (auto& pair : id_to_key_) {\n    layer_ids.emplace_back(pair.first);\n  }\n  std::sort(layer_ids.begin(), layer_ids.end());\n\n  // add item to dict\n  proto::config::MapLayerDictionary dict;\n  for (auto& id : layer_ids) {\n    // analyze key\n    std::string type_name;\n    float grid_size;\n    float tile_size;\n    analyseKey(id_to_key_[id], &type_name, &grid_size, &tile_size);\n\n    // add item\n    proto::config::MapLayerItem* item = dict.add_items();\n    item->set_layer_id(id);\n    item->set_type_name(type_name);\n    item->set_grid_size(grid_size);\n    item->set_tile_size(tile_size);\n  }\n\n  // write dict to file\n  return common::ProtoIO::writeProtoToTextFile(dict_file, dict);\n}\n\nvoid MapLayerDictionaryParser::composeKey(const std::string& type_name, const float& grid_size,\n                                          const float& tile_size, std::string* key) {\n  std::stringstream str_stream;\n  str_stream << type_name << \"_\" << static_cast<int>(grid_size * grid_size_ratio) << \"_\"\n             << static_cast<int>(tile_size);\n  *key = str_stream.str();\n}\n\nvoid MapLayerDictionaryParser::analyseKey(const std::string& key, std::string* type_name,\n                                          float* grid_size, float* tile_size) {\n  std::vector<std::string> substrs;\n  substrs.resize(3);\n\n  // achieve sub strings from key\n  size_t tail = key.size() - 1;\n  for (int i = 0; i < 2; i++) {\n    size_t pos = key.rfind('_', tail);\n    substrs[2 - i] = key.substr(pos + 1, tail - pos);\n    tail = pos - 1;\n  }\n  substrs[0] = key.substr(0, tail + 1);\n\n  // output\n  if (tile_size != nullptr) {\n    *tile_size = std::stof(substrs[2]);\n  }\n  if (grid_size != nullptr) {\n    *grid_size = std::stof(substrs[1]) / grid_size_ratio;\n  }\n  if (type_name != nullptr) {\n    *type_name = substrs[0];\n  }\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp"
		}
	}
]
I0403 13:41:07.757380 32175 json_parser.cpp:18] 
[
	19,
	{
		"bufnr" : 3,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All rights reserved.\n// Authors: Yongjian Zhao (yongjian.zhao@allride.ai)\n\n#include <fstream>\n#include <iostream>\n#include <sstream>\n#include <vector>\n\n#include \"common/io/proto_io.h\"\n#include \"common/proto/config/config_map.pb.h\"\n#include \"map_layer_dictionary_parser.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstatic const float grid_size_ratio = 1000.0f;  // convert from m to mm,\n\nbool MapLayerDictionaryParser::load(const std::string& dict_file) {\n  proto::config::MapLayerDictionary dict;\n  if (!common::ProtoIO::readProtoFromTextFile(dict_file, &dict)) {\n    std::cerr << \"MapLayerDictionaryParser: failed to load from dictionary file!\" << std::endl;\n    std::cerr << \"dict_file: \" << dict_file << std::endl;\n    return false;\n  }\n\n  for (const auto& item : dict.items()) {\n    int layer_id = item.layer_id();\n    std::string type_name = item.type_name();\n    float grid_size = item.grid_size();\n    float tile_size = item.tile_size();\n\n    // compose the key\n    std::string key;\n    composeKey(type_name, grid_size, tile_size, &key);\n\n    // set unordered_map\n    id_to_key_[layer_id] = key;\n    key_to_id_[key] = layer_id;\n  }\n\n  return true;\n}\n\nbool MapLayerDictionaryParser::getInfoById(const int layer_id, std::string* type_name,\n                                           float* grid_size, float* tile_size) {\n  if (id_to_key_.count(layer_id) == 0) {\n    return false;\n  }\n\n  analyseKey(id_to_key_[layer_id], type_name, grid_size, tile_size);\n  return true;\n}\n\nbool MapLayerDictionaryParser::getIdByInfo(const std::string& type_name, const float& grid_size,\n                                           const float& tile_size, int* layer_id) {\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 0) {\n    return false;\n  }\n\n  *layer_id = key_to_id_[key];\n  return true;\n}\n\nfloat MapLayerDictionaryParser::getGridSize(const int layer_id) {\n  float grid_size;\n  if(!getInfoById(layer_id, nullptr, &grid_size, nullptr)){\n    return -1; // return a negtive value for invalid layer_id\n  }\n\n  return grid_size;\n}\n\nfloat MapLayerDictionaryParser::getTileSize(const int layer_id) {\n  float tile_size;\n  if(!getInfoById(layer_id, nullptr, nullptr, &tile_size)\n  return tile_size;\n}\n\nstd::string MapLayerDictionaryParser::getTypeName(const int layer_id) {\n  std::string type_name;\n  getInfoById(layer_id, &type_name, nullptr, nullptr);\n  return type_name;\n}\n\nbool MapLayerDictionaryParser::addItem(const int layer_id, const std::string& type_name,\n                                       const float grid_size, const float tile_size) {\n  if (id_to_key_.count(layer_id) == 1) {\n    std::cerr << \"failed to add item: layer_id \" << layer_id << \" has already exited in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 1) {\n    std::cerr << \"failed to add item: layer configuration has already existed in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  id_to_key_[layer_id] = key;\n  key_to_id_[key] = layer_id;\n  return true;\n}\n\nbool MapLayerDictionaryParser::save(const std::string& dict_file) {\n  // sort layer id\n  std::vector<int> layer_ids;\n  for (auto& pair : id_to_key_) {\n    layer_ids.emplace_back(pair.first);\n  }\n  std::sort(layer_ids.begin(), layer_ids.end());\n\n  // add item to dict\n  proto::config::MapLayerDictionary dict;\n  for (auto& id : layer_ids) {\n    // analyze key\n    std::string type_name;\n    float grid_size;\n    float tile_size;\n    analyseKey(id_to_key_[id], &type_name, &grid_size, &tile_size);\n\n    // add item\n    proto::config::MapLayerItem* item = dict.add_items();\n    item->set_layer_id(id);\n    item->set_type_name(type_name);\n    item->set_grid_size(grid_size);\n    item->set_tile_size(tile_size);\n  }\n\n  // write dict to file\n  return common::ProtoIO::writeProtoToTextFile(dict_file, dict);\n}\n\nvoid MapLayerDictionaryParser::composeKey(const std::string& type_name, const float& grid_size,\n                                          const float& tile_size, std::string* key) {\n  std::stringstream str_stream;\n  str_stream << type_name << \"_\" << static_cast<int>(grid_size * grid_size_ratio) << \"_\"\n             << static_cast<int>(tile_size);\n  *key = str_stream.str();\n}\n\nvoid MapLayerDictionaryParser::analyseKey(const std::string& key, std::string* type_name,\n                                          float* grid_size, float* tile_size) {\n  std::vector<std::string> substrs;\n  substrs.resize(3);\n\n  // achieve sub strings from key\n  size_t tail = key.size() - 1;\n  for (int i = 0; i < 2; i++) {\n    size_t pos = key.rfind('_', tail);\n    substrs[2 - i] = key.substr(pos + 1, tail - pos);\n    tail = pos - 1;\n  }\n  substrs[0] = key.substr(0, tail + 1);\n\n  // output\n  if (tile_size != nullptr) {\n    *tile_size = std::stof(substrs[2]);\n  }\n  if (grid_size != nullptr) {\n    *grid_size = std::stof(substrs[1]) / grid_size_ratio;\n  }\n  if (type_name != nullptr) {\n    *type_name = substrs[0];\n  }\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp"
		}
	}
]
I0403 13:41:08.149143 32175 json_parser.cpp:18] 
[
	20,
	{
		"bufnr" : 3,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All rights reserved.\n// Authors: Yongjian Zhao (yongjian.zhao@allride.ai)\n\n#include <fstream>\n#include <iostream>\n#include <sstream>\n#include <vector>\n\n#include \"common/io/proto_io.h\"\n#include \"common/proto/config/config_map.pb.h\"\n#include \"map_layer_dictionary_parser.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstatic const float grid_size_ratio = 1000.0f;  // convert from m to mm,\n\nbool MapLayerDictionaryParser::load(const std::string& dict_file) {\n  proto::config::MapLayerDictionary dict;\n  if (!common::ProtoIO::readProtoFromTextFile(dict_file, &dict)) {\n    std::cerr << \"MapLayerDictionaryParser: failed to load from dictionary file!\" << std::endl;\n    std::cerr << \"dict_file: \" << dict_file << std::endl;\n    return false;\n  }\n\n  for (const auto& item : dict.items()) {\n    int layer_id = item.layer_id();\n    std::string type_name = item.type_name();\n    float grid_size = item.grid_size();\n    float tile_size = item.tile_size();\n\n    // compose the key\n    std::string key;\n    composeKey(type_name, grid_size, tile_size, &key);\n\n    // set unordered_map\n    id_to_key_[layer_id] = key;\n    key_to_id_[key] = layer_id;\n  }\n\n  return true;\n}\n\nbool MapLayerDictionaryParser::getInfoById(const int layer_id, std::string* type_name,\n                                           float* grid_size, float* tile_size) {\n  if (id_to_key_.count(layer_id) == 0) {\n    return false;\n  }\n\n  analyseKey(id_to_key_[layer_id], type_name, grid_size, tile_size);\n  return true;\n}\n\nbool MapLayerDictionaryParser::getIdByInfo(const std::string& type_name, const float& grid_size,\n                                           const float& tile_size, int* layer_id) {\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 0) {\n    return false;\n  }\n\n  *layer_id = key_to_id_[key];\n  return true;\n}\n\nfloat MapLayerDictionaryParser::getGridSize(const int layer_id) {\n  float grid_size;\n  if(!getInfoById(layer_id, nullptr, &grid_size, nullptr)){\n    return -1; // return a negtive value for invalid layer_id\n  }\n\n  return grid_size;\n}\n\nfloat MapLayerDictionaryParser::getTileSize(const int layer_id) {\n  float tile_size;\n  if(!getInfoById(layer_id, nullptr, nullptr, &tile_size)\n  return tile_size;\n}\n\nstd::string MapLayerDictionaryParser::getTypeName(const int layer_id) {\n  std::string type_name;\n  getInfoById(layer_id, &type_name, nullptr, nullptr);\n  return type_name;\n}\n\nbool MapLayerDictionaryParser::addItem(const int layer_id, const std::string& type_name,\n                                       const float grid_size, const float tile_size) {\n  if (id_to_key_.count(layer_id) == 1) {\n    std::cerr << \"failed to add item: layer_id \" << layer_id << \" has already exited in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 1) {\n    std::cerr << \"failed to add item: layer configuration has already existed in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  id_to_key_[layer_id] = key;\n  key_to_id_[key] = layer_id;\n  return true;\n}\n\nbool MapLayerDictionaryParser::save(const std::string& dict_file) {\n  // sort layer id\n  std::vector<int> layer_ids;\n  for (auto& pair : id_to_key_) {\n    layer_ids.emplace_back(pair.first);\n  }\n  std::sort(layer_ids.begin(), layer_ids.end());\n\n  // add item to dict\n  proto::config::MapLayerDictionary dict;\n  for (auto& id : layer_ids) {\n    // analyze key\n    std::string type_name;\n    float grid_size;\n    float tile_size;\n    analyseKey(id_to_key_[id], &type_name, &grid_size, &tile_size);\n\n    // add item\n    proto::config::MapLayerItem* item = dict.add_items();\n    item->set_layer_id(id);\n    item->set_type_name(type_name);\n    item->set_grid_size(grid_size);\n    item->set_tile_size(tile_size);\n  }\n\n  // write dict to file\n  return common::ProtoIO::writeProtoToTextFile(dict_file, dict);\n}\n\nvoid MapLayerDictionaryParser::composeKey(const std::string& type_name, const float& grid_size,\n                                          const float& tile_size, std::string* key) {\n  std::stringstream str_stream;\n  str_stream << type_name << \"_\" << static_cast<int>(grid_size * grid_size_ratio) << \"_\"\n             << static_cast<int>(tile_size);\n  *key = str_stream.str();\n}\n\nvoid MapLayerDictionaryParser::analyseKey(const std::string& key, std::string* type_name,\n                                          float* grid_size, float* tile_size) {\n  std::vector<std::string> substrs;\n  substrs.resize(3);\n\n  // achieve sub strings from key\n  size_t tail = key.size() - 1;\n  for (int i = 0; i < 2; i++) {\n    size_t pos = key.rfind('_', tail);\n    substrs[2 - i] = key.substr(pos + 1, tail - pos);\n    tail = pos - 1;\n  }\n  substrs[0] = key.substr(0, tail + 1);\n\n  // output\n  if (tile_size != nullptr) {\n    *tile_size = std::stof(substrs[2]);\n  }\n  if (grid_size != nullptr) {\n    *grid_size = std::stof(substrs[1]) / grid_size_ratio;\n  }\n  if (type_name != nullptr) {\n    *type_name = substrs[0];\n  }\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp"
		}
	}
]
I0403 13:41:09.810250 32175 json_parser.cpp:18] 
[
	21,
	{
		"bufnr" : 3,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All rights reserved.\n// Authors: Yongjian Zhao (yongjian.zhao@allride.ai)\n\n#include <fstream>\n#include <iostream>\n#include <sstream>\n#include <vector>\n\n#include \"common/io/proto_io.h\"\n#include \"common/proto/config/config_map.pb.h\"\n#include \"map_layer_dictionary_parser.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstatic const float grid_size_ratio = 1000.0f;  // convert from m to mm,\n\nbool MapLayerDictionaryParser::load(const std::string& dict_file) {\n  proto::config::MapLayerDictionary dict;\n  if (!common::ProtoIO::readProtoFromTextFile(dict_file, &dict)) {\n    std::cerr << \"MapLayerDictionaryParser: failed to load from dictionary file!\" << std::endl;\n    std::cerr << \"dict_file: \" << dict_file << std::endl;\n    return false;\n  }\n\n  for (const auto& item : dict.items()) {\n    int layer_id = item.layer_id();\n    std::string type_name = item.type_name();\n    float grid_size = item.grid_size();\n    float tile_size = item.tile_size();\n\n    // compose the key\n    std::string key;\n    composeKey(type_name, grid_size, tile_size, &key);\n\n    // set unordered_map\n    id_to_key_[layer_id] = key;\n    key_to_id_[key] = layer_id;\n  }\n\n  return true;\n}\n\nbool MapLayerDictionaryParser::getInfoById(const int layer_id, std::string* type_name,\n                                           float* grid_size, float* tile_size) {\n  if (id_to_key_.count(layer_id) == 0) {\n    return false;\n  }\n\n  analyseKey(id_to_key_[layer_id], type_name, grid_size, tile_size);\n  return true;\n}\n\nbool MapLayerDictionaryParser::getIdByInfo(const std::string& type_name, const float& grid_size,\n                                           const float& tile_size, int* layer_id) {\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 0) {\n    return false;\n  }\n\n  *layer_id = key_to_id_[key];\n  return true;\n}\n\nfloat MapLayerDictionaryParser::getGridSize(const int layer_id) {\n  float grid_size;\n  if(!getInfoById(layer_id, nullptr, &grid_size, nullptr)){\n    return -1; // return a negtive value for invalid layer_id\n  }\n\n  return grid_size;\n}\n\nfloat MapLayerDictionaryParser::getTileSize(const int layer_id) {\n  float tile_size;\n  if(!getInfoById(layer_id, nullptr, nullptr, &tile_size)){\n  }\n  return tile_size;\n}\n\nstd::string MapLayerDictionaryParser::getTypeName(const int layer_id) {\n  std::string type_name;\n  getInfoById(layer_id, &type_name, nullptr, nullptr);\n  return type_name;\n}\n\nbool MapLayerDictionaryParser::addItem(const int layer_id, const std::string& type_name,\n                                       const float grid_size, const float tile_size) {\n  if (id_to_key_.count(layer_id) == 1) {\n    std::cerr << \"failed to add item: layer_id \" << layer_id << \" has already exited in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 1) {\n    std::cerr << \"failed to add item: layer configuration has already existed in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  id_to_key_[layer_id] = key;\n  key_to_id_[key] = layer_id;\n  return true;\n}\n\nbool MapLayerDictionaryParser::save(const std::string& dict_file) {\n  // sort layer id\n  std::vector<int> layer_ids;\n  for (auto& pair : id_to_key_) {\n    layer_ids.emplace_back(pair.first);\n  }\n  std::sort(layer_ids.begin(), layer_ids.end());\n\n  // add item to dict\n  proto::config::MapLayerDictionary dict;\n  for (auto& id : layer_ids) {\n    // analyze key\n    std::string type_name;\n    float grid_size;\n    float tile_size;\n    analyseKey(id_to_key_[id], &type_name, &grid_size, &tile_size);\n\n    // add item\n    proto::config::MapLayerItem* item = dict.add_items();\n    item->set_layer_id(id);\n    item->set_type_name(type_name);\n    item->set_grid_size(grid_size);\n    item->set_tile_size(tile_size);\n  }\n\n  // write dict to file\n  return common::ProtoIO::writeProtoToTextFile(dict_file, dict);\n}\n\nvoid MapLayerDictionaryParser::composeKey(const std::string& type_name, const float& grid_size,\n                                          const float& tile_size, std::string* key) {\n  std::stringstream str_stream;\n  str_stream << type_name << \"_\" << static_cast<int>(grid_size * grid_size_ratio) << \"_\"\n             << static_cast<int>(tile_size);\n  *key = str_stream.str();\n}\n\nvoid MapLayerDictionaryParser::analyseKey(const std::string& key, std::string* type_name,\n                                          float* grid_size, float* tile_size) {\n  std::vector<std::string> substrs;\n  substrs.resize(3);\n\n  // achieve sub strings from key\n  size_t tail = key.size() - 1;\n  for (int i = 0; i < 2; i++) {\n    size_t pos = key.rfind('_', tail);\n    substrs[2 - i] = key.substr(pos + 1, tail - pos);\n    tail = pos - 1;\n  }\n  substrs[0] = key.substr(0, tail + 1);\n\n  // output\n  if (tile_size != nullptr) {\n    *tile_size = std::stof(substrs[2]);\n  }\n  if (grid_size != nullptr) {\n    *grid_size = std::stof(substrs[1]) / grid_size_ratio;\n  }\n  if (type_name != nullptr) {\n    *type_name = substrs[0];\n  }\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp"
		}
	}
]
I0403 13:41:13.754289 32175 json_parser.cpp:18] 
[
	22,
	{
		"bufnr" : 3,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All rights reserved.\n// Authors: Yongjian Zhao (yongjian.zhao@allride.ai)\n\n#include <fstream>\n#include <iostream>\n#include <sstream>\n#include <vector>\n\n#include \"common/io/proto_io.h\"\n#include \"common/proto/config/config_map.pb.h\"\n#include \"map_layer_dictionary_parser.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstatic const float grid_size_ratio = 1000.0f;  // convert from m to mm,\n\nbool MapLayerDictionaryParser::load(const std::string& dict_file) {\n  proto::config::MapLayerDictionary dict;\n  if (!common::ProtoIO::readProtoFromTextFile(dict_file, &dict)) {\n    std::cerr << \"MapLayerDictionaryParser: failed to load from dictionary file!\" << std::endl;\n    std::cerr << \"dict_file: \" << dict_file << std::endl;\n    return false;\n  }\n\n  for (const auto& item : dict.items()) {\n    int layer_id = item.layer_id();\n    std::string type_name = item.type_name();\n    float grid_size = item.grid_size();\n    float tile_size = item.tile_size();\n\n    // compose the key\n    std::string key;\n    composeKey(type_name, grid_size, tile_size, &key);\n\n    // set unordered_map\n    id_to_key_[layer_id] = key;\n    key_to_id_[key] = layer_id;\n  }\n\n  return true;\n}\n\nbool MapLayerDictionaryParser::getInfoById(const int layer_id, std::string* type_name,\n                                           float* grid_size, float* tile_size) {\n  if (id_to_key_.count(layer_id) == 0) {\n    return false;\n  }\n\n  analyseKey(id_to_key_[layer_id], type_name, grid_size, tile_size);\n  return true;\n}\n\nbool MapLayerDictionaryParser::getIdByInfo(const std::string& type_name, const float& grid_size,\n                                           const float& tile_size, int* layer_id) {\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 0) {\n    return false;\n  }\n\n  *layer_id = key_to_id_[key];\n  return true;\n}\n\nfloat MapLayerDictionaryParser::getGridSize(const int layer_id) {\n  float grid_size;\n  if(!getInfoById(layer_id, nullptr, &grid_size, nullptr)){\n    return -1; // return a negtive value for invalid layer_id\n  }\n\n  return grid_size;\n}\n\nfloat MapLayerDictionaryParser::getTileSize(const int layer_id) {\n  float tile_size;\n  if(!getInfoById(layer_id, nullptr, nullptr, &tile_size)){\n    return -1;\n  }\n  return tile_size;\n}\n\nstd::string MapLayerDictionaryParser::getTypeName(const int layer_id) {\n  std::string type_name;\n  getInfoById(layer_id, &type_name, nullptr, nullptr);\n  return type_name;\n}\n\nbool MapLayerDictionaryParser::addItem(const int layer_id, const std::string& type_name,\n                                       const float grid_size, const float tile_size) {\n  if (id_to_key_.count(layer_id) == 1) {\n    std::cerr << \"failed to add item: layer_id \" << layer_id << \" has already exited in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 1) {\n    std::cerr << \"failed to add item: layer configuration has already existed in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  id_to_key_[layer_id] = key;\n  key_to_id_[key] = layer_id;\n  return true;\n}\n\nbool MapLayerDictionaryParser::save(const std::string& dict_file) {\n  // sort layer id\n  std::vector<int> layer_ids;\n  for (auto& pair : id_to_key_) {\n    layer_ids.emplace_back(pair.first);\n  }\n  std::sort(layer_ids.begin(), layer_ids.end());\n\n  // add item to dict\n  proto::config::MapLayerDictionary dict;\n  for (auto& id : layer_ids) {\n    // analyze key\n    std::string type_name;\n    float grid_size;\n    float tile_size;\n    analyseKey(id_to_key_[id], &type_name, &grid_size, &tile_size);\n\n    // add item\n    proto::config::MapLayerItem* item = dict.add_items();\n    item->set_layer_id(id);\n    item->set_type_name(type_name);\n    item->set_grid_size(grid_size);\n    item->set_tile_size(tile_size);\n  }\n\n  // write dict to file\n  return common::ProtoIO::writeProtoToTextFile(dict_file, dict);\n}\n\nvoid MapLayerDictionaryParser::composeKey(const std::string& type_name, const float& grid_size,\n                                          const float& tile_size, std::string* key) {\n  std::stringstream str_stream;\n  str_stream << type_name << \"_\" << static_cast<int>(grid_size * grid_size_ratio) << \"_\"\n             << static_cast<int>(tile_size);\n  *key = str_stream.str();\n}\n\nvoid MapLayerDictionaryParser::analyseKey(const std::string& key, std::string* type_name,\n                                          float* grid_size, float* tile_size) {\n  std::vector<std::string> substrs;\n  substrs.resize(3);\n\n  // achieve sub strings from key\n  size_t tail = key.size() - 1;\n  for (int i = 0; i < 2; i++) {\n    size_t pos = key.rfind('_', tail);\n    substrs[2 - i] = key.substr(pos + 1, tail - pos);\n    tail = pos - 1;\n  }\n  substrs[0] = key.substr(0, tail + 1);\n\n  // output\n  if (tile_size != nullptr) {\n    *tile_size = std::stof(substrs[2]);\n  }\n  if (grid_size != nullptr) {\n    *grid_size = std::stof(substrs[1]) / grid_size_ratio;\n  }\n  if (type_name != nullptr) {\n    *type_name = substrs[0];\n  }\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp"
		}
	}
]
I0403 13:41:14.172565 32175 json_parser.cpp:18] 
[
	23,
	{
		"bufnr" : 3,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All rights reserved.\n// Authors: Yongjian Zhao (yongjian.zhao@allride.ai)\n\n#include <fstream>\n#include <iostream>\n#include <sstream>\n#include <vector>\n\n#include \"common/io/proto_io.h\"\n#include \"common/proto/config/config_map.pb.h\"\n#include \"map_layer_dictionary_parser.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstatic const float grid_size_ratio = 1000.0f;  // convert from m to mm,\n\nbool MapLayerDictionaryParser::load(const std::string& dict_file) {\n  proto::config::MapLayerDictionary dict;\n  if (!common::ProtoIO::readProtoFromTextFile(dict_file, &dict)) {\n    std::cerr << \"MapLayerDictionaryParser: failed to load from dictionary file!\" << std::endl;\n    std::cerr << \"dict_file: \" << dict_file << std::endl;\n    return false;\n  }\n\n  for (const auto& item : dict.items()) {\n    int layer_id = item.layer_id();\n    std::string type_name = item.type_name();\n    float grid_size = item.grid_size();\n    float tile_size = item.tile_size();\n\n    // compose the key\n    std::string key;\n    composeKey(type_name, grid_size, tile_size, &key);\n\n    // set unordered_map\n    id_to_key_[layer_id] = key;\n    key_to_id_[key] = layer_id;\n  }\n\n  return true;\n}\n\nbool MapLayerDictionaryParser::getInfoById(const int layer_id, std::string* type_name,\n                                           float* grid_size, float* tile_size) {\n  if (id_to_key_.count(layer_id) == 0) {\n    return false;\n  }\n\n  analyseKey(id_to_key_[layer_id], type_name, grid_size, tile_size);\n  return true;\n}\n\nbool MapLayerDictionaryParser::getIdByInfo(const std::string& type_name, const float& grid_size,\n                                           const float& tile_size, int* layer_id) {\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 0) {\n    return false;\n  }\n\n  *layer_id = key_to_id_[key];\n  return true;\n}\n\nfloat MapLayerDictionaryParser::getGridSize(const int layer_id) {\n  float grid_size;\n  if(!getInfoById(layer_id, nullptr, &grid_size, nullptr)){\n    return -1; // return a negtive value for invalid layer_id\n  }\n\n  return grid_size;\n}\n\nfloat MapLayerDictionaryParser::getTileSize(const int layer_id) {\n  float tile_size;\n  if(!getInfoById(layer_id, nullptr, nullptr, &tile_size)){\n    return -1;\n  }\n  return tile_size;\n}\n\nstd::string MapLayerDictionaryParser::getTypeName(const int layer_id) {\n  std::string type_name;\n  getInfoById(layer_id, &type_name, nullptr, nullptr);\n  return type_name;\n}\n\nbool MapLayerDictionaryParser::addItem(const int layer_id, const std::string& type_name,\n                                       const float grid_size, const float tile_size) {\n  if (id_to_key_.count(layer_id) == 1) {\n    std::cerr << \"failed to add item: layer_id \" << layer_id << \" has already exited in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 1) {\n    std::cerr << \"failed to add item: layer configuration has already existed in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  id_to_key_[layer_id] = key;\n  key_to_id_[key] = layer_id;\n  return true;\n}\n\nbool MapLayerDictionaryParser::save(const std::string& dict_file) {\n  // sort layer id\n  std::vector<int> layer_ids;\n  for (auto& pair : id_to_key_) {\n    layer_ids.emplace_back(pair.first);\n  }\n  std::sort(layer_ids.begin(), layer_ids.end());\n\n  // add item to dict\n  proto::config::MapLayerDictionary dict;\n  for (auto& id : layer_ids) {\n    // analyze key\n    std::string type_name;\n    float grid_size;\n    float tile_size;\n    analyseKey(id_to_key_[id], &type_name, &grid_size, &tile_size);\n\n    // add item\n    proto::config::MapLayerItem* item = dict.add_items();\n    item->set_layer_id(id);\n    item->set_type_name(type_name);\n    item->set_grid_size(grid_size);\n    item->set_tile_size(tile_size);\n  }\n\n  // write dict to file\n  return common::ProtoIO::writeProtoToTextFile(dict_file, dict);\n}\n\nvoid MapLayerDictionaryParser::composeKey(const std::string& type_name, const float& grid_size,\n                                          const float& tile_size, std::string* key) {\n  std::stringstream str_stream;\n  str_stream << type_name << \"_\" << static_cast<int>(grid_size * grid_size_ratio) << \"_\"\n             << static_cast<int>(tile_size);\n  *key = str_stream.str();\n}\n\nvoid MapLayerDictionaryParser::analyseKey(const std::string& key, std::string* type_name,\n                                          float* grid_size, float* tile_size) {\n  std::vector<std::string> substrs;\n  substrs.resize(3);\n\n  // achieve sub strings from key\n  size_t tail = key.size() - 1;\n  for (int i = 0; i < 2; i++) {\n    size_t pos = key.rfind('_', tail);\n    substrs[2 - i] = key.substr(pos + 1, tail - pos);\n    tail = pos - 1;\n  }\n  substrs[0] = key.substr(0, tail + 1);\n\n  // output\n  if (tile_size != nullptr) {\n    *tile_size = std::stof(substrs[2]);\n  }\n  if (grid_size != nullptr) {\n    *grid_size = std::stof(substrs[1]) / grid_size_ratio;\n  }\n  if (type_name != nullptr) {\n    *type_name = substrs[0];\n  }\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp"
		}
	}
]
I0403 13:41:26.201714 32175 json_parser.cpp:18] 
[
	24,
	{
		"bufnr" : 3,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All rights reserved.\n// Authors: Yongjian Zhao (yongjian.zhao@allride.ai)\n\n#include <fstream>\n#include <iostream>\n#include <sstream>\n#include <vector>\n\n#include \"common/io/proto_io.h\"\n#include \"common/proto/config/config_map.pb.h\"\n#include \"map_layer_dictionary_parser.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstatic const float grid_size_ratio = 1000.0f;  // convert from m to mm,\n\nbool MapLayerDictionaryParser::load(const std::string& dict_file) {\n  proto::config::MapLayerDictionary dict;\n  if (!common::ProtoIO::readProtoFromTextFile(dict_file, &dict)) {\n    std::cerr << \"MapLayerDictionaryParser: failed to load from dictionary file!\" << std::endl;\n    std::cerr << \"dict_file: \" << dict_file << std::endl;\n    return false;\n  }\n\n  for (const auto& item : dict.items()) {\n    int layer_id = item.layer_id();\n    std::string type_name = item.type_name();\n    float grid_size = item.grid_size();\n    float tile_size = item.tile_size();\n\n    // compose the key\n    std::string key;\n    composeKey(type_name, grid_size, tile_size, &key);\n\n    // set unordered_map\n    id_to_key_[layer_id] = key;\n    key_to_id_[key] = layer_id;\n  }\n\n  return true;\n}\n\nbool MapLayerDictionaryParser::getInfoById(const int layer_id, std::string* type_name,\n                                           float* grid_size, float* tile_size) {\n  if (id_to_key_.count(layer_id) == 0) {\n    return false;\n  }\n\n  analyseKey(id_to_key_[layer_id], type_name, grid_size, tile_size);\n  return true;\n}\n\nbool MapLayerDictionaryParser::getIdByInfo(const std::string& type_name, const float& grid_size,\n                                           const float& tile_size, int* layer_id) {\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 0) {\n    return false;\n  }\n\n  *layer_id = key_to_id_[key];\n  return true;\n}\n\nfloat MapLayerDictionaryParser::getGridSize(const int layer_id) {\n  float grid_size;\n  if(!getInfoById(layer_id, nullptr, &grid_size, nullptr)){\n    return -1; // return a negtive value for invalid layer_id\n  }\n\n  return grid_size;\n}\n\nfloat MapLayerDictionaryParser::getTileSize(const int layer_id) {\n  float tile_size;\n  if(!getInfoById(layer_id, nullptr, nullptr, &tile_size)){\n    return -1; // return a negtive value for invalid layer_id\n  }\n  return tile_size;\n}\n\nstd::string MapLayerDictionaryParser::getTypeName(const int layer_id) {\n  std::string type_name;\n  getInfoById(layer_id, &type_name, nullptr, nullptr);\n  return type_name;\n}\n\nbool MapLayerDictionaryParser::addItem(const int layer_id, const std::string& type_name,\n                                       const float grid_size, const float tile_size) {\n  if (id_to_key_.count(layer_id) == 1) {\n    std::cerr << \"failed to add item: layer_id \" << layer_id << \" has already exited in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 1) {\n    std::cerr << \"failed to add item: layer configuration has already existed in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  id_to_key_[layer_id] = key;\n  key_to_id_[key] = layer_id;\n  return true;\n}\n\nbool MapLayerDictionaryParser::save(const std::string& dict_file) {\n  // sort layer id\n  std::vector<int> layer_ids;\n  for (auto& pair : id_to_key_) {\n    layer_ids.emplace_back(pair.first);\n  }\n  std::sort(layer_ids.begin(), layer_ids.end());\n\n  // add item to dict\n  proto::config::MapLayerDictionary dict;\n  for (auto& id : layer_ids) {\n    // analyze key\n    std::string type_name;\n    float grid_size;\n    float tile_size;\n    analyseKey(id_to_key_[id], &type_name, &grid_size, &tile_size);\n\n    // add item\n    proto::config::MapLayerItem* item = dict.add_items();\n    item->set_layer_id(id);\n    item->set_type_name(type_name);\n    item->set_grid_size(grid_size);\n    item->set_tile_size(tile_size);\n  }\n\n  // write dict to file\n  return common::ProtoIO::writeProtoToTextFile(dict_file, dict);\n}\n\nvoid MapLayerDictionaryParser::composeKey(const std::string& type_name, const float& grid_size,\n                                          const float& tile_size, std::string* key) {\n  std::stringstream str_stream;\n  str_stream << type_name << \"_\" << static_cast<int>(grid_size * grid_size_ratio) << \"_\"\n             << static_cast<int>(tile_size);\n  *key = str_stream.str();\n}\n\nvoid MapLayerDictionaryParser::analyseKey(const std::string& key, std::string* type_name,\n                                          float* grid_size, float* tile_size) {\n  std::vector<std::string> substrs;\n  substrs.resize(3);\n\n  // achieve sub strings from key\n  size_t tail = key.size() - 1;\n  for (int i = 0; i < 2; i++) {\n    size_t pos = key.rfind('_', tail);\n    substrs[2 - i] = key.substr(pos + 1, tail - pos);\n    tail = pos - 1;\n  }\n  substrs[0] = key.substr(0, tail + 1);\n\n  // output\n  if (tile_size != nullptr) {\n    *tile_size = std::stof(substrs[2]);\n  }\n  if (grid_size != nullptr) {\n    *grid_size = std::stof(substrs[1]) / grid_size_ratio;\n  }\n  if (type_name != nullptr) {\n    *type_name = substrs[0];\n  }\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp"
		}
	}
]
I0403 13:41:30.955899 32175 json_parser.cpp:18] 
[
	25,
	{
		"bufnr" : 3,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All rights reserved.\n// Authors: Yongjian Zhao (yongjian.zhao@allride.ai)\n\n#include <fstream>\n#include <iostream>\n#include <sstream>\n#include <vector>\n\n#include \"common/io/proto_io.h\"\n#include \"common/proto/config/config_map.pb.h\"\n#include \"map_layer_dictionary_parser.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstatic const float grid_size_ratio = 1000.0f;  // convert from m to mm,\n\nbool MapLayerDictionaryParser::load(const std::string& dict_file) {\n  proto::config::MapLayerDictionary dict;\n  if (!common::ProtoIO::readProtoFromTextFile(dict_file, &dict)) {\n    std::cerr << \"MapLayerDictionaryParser: failed to load from dictionary file!\" << std::endl;\n    std::cerr << \"dict_file: \" << dict_file << std::endl;\n    return false;\n  }\n\n  for (const auto& item : dict.items()) {\n    int layer_id = item.layer_id();\n    std::string type_name = item.type_name();\n    float grid_size = item.grid_size();\n    float tile_size = item.tile_size();\n\n    // compose the key\n    std::string key;\n    composeKey(type_name, grid_size, tile_size, &key);\n\n    // set unordered_map\n    id_to_key_[layer_id] = key;\n    key_to_id_[key] = layer_id;\n  }\n\n  return true;\n}\n\nbool MapLayerDictionaryParser::getInfoById(const int layer_id, std::string* type_name,\n                                           float* grid_size, float* tile_size) {\n  if (id_to_key_.count(layer_id) == 0) {\n    return false;\n  }\n\n  analyseKey(id_to_key_[layer_id], type_name, grid_size, tile_size);\n  return true;\n}\n\nbool MapLayerDictionaryParser::getIdByInfo(const std::string& type_name, const float& grid_size,\n                                           const float& tile_size, int* layer_id) {\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 0) {\n    return false;\n  }\n\n  *layer_id = key_to_id_[key];\n  return true;\n}\n\nfloat MapLayerDictionaryParser::getGridSize(const int layer_id) {\n  float grid_size;\n  if(!getInfoById(layer_id, nullptr, &grid_size, nullptr)){\n    return -1; // return a negtive value for invalid layer_id\n  }\n\n  return grid_size;\n}\n\nfloat MapLayerDictionaryParser::getTileSize(const int layer_id) {\n  float tile_size;\n  if(!getInfoById(layer_id, nullptr, nullptr, &tile_size)){\n    return -1; // return a negtive value for invalid layer_id\n  }\n  \n  return tile_size;\n}\n\nstd::string MapLayerDictionaryParser::getTypeName(const int layer_id) {\n  std::string type_name;\n  getInfoById(layer_id, &type_name, nullptr, nullptr);\n  return type_name;\n}\n\nbool MapLayerDictionaryParser::addItem(const int layer_id, const std::string& type_name,\n                                       const float grid_size, const float tile_size) {\n  if (id_to_key_.count(layer_id) == 1) {\n    std::cerr << \"failed to add item: layer_id \" << layer_id << \" has already exited in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 1) {\n    std::cerr << \"failed to add item: layer configuration has already existed in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  id_to_key_[layer_id] = key;\n  key_to_id_[key] = layer_id;\n  return true;\n}\n\nbool MapLayerDictionaryParser::save(const std::string& dict_file) {\n  // sort layer id\n  std::vector<int> layer_ids;\n  for (auto& pair : id_to_key_) {\n    layer_ids.emplace_back(pair.first);\n  }\n  std::sort(layer_ids.begin(), layer_ids.end());\n\n  // add item to dict\n  proto::config::MapLayerDictionary dict;\n  for (auto& id : layer_ids) {\n    // analyze key\n    std::string type_name;\n    float grid_size;\n    float tile_size;\n    analyseKey(id_to_key_[id], &type_name, &grid_size, &tile_size);\n\n    // add item\n    proto::config::MapLayerItem* item = dict.add_items();\n    item->set_layer_id(id);\n    item->set_type_name(type_name);\n    item->set_grid_size(grid_size);\n    item->set_tile_size(tile_size);\n  }\n\n  // write dict to file\n  return common::ProtoIO::writeProtoToTextFile(dict_file, dict);\n}\n\nvoid MapLayerDictionaryParser::composeKey(const std::string& type_name, const float& grid_size,\n                                          const float& tile_size, std::string* key) {\n  std::stringstream str_stream;\n  str_stream << type_name << \"_\" << static_cast<int>(grid_size * grid_size_ratio) << \"_\"\n             << static_cast<int>(tile_size);\n  *key = str_stream.str();\n}\n\nvoid MapLayerDictionaryParser::analyseKey(const std::string& key, std::string* type_name,\n                                          float* grid_size, float* tile_size) {\n  std::vector<std::string> substrs;\n  substrs.resize(3);\n\n  // achieve sub strings from key\n  size_t tail = key.size() - 1;\n  for (int i = 0; i < 2; i++) {\n    size_t pos = key.rfind('_', tail);\n    substrs[2 - i] = key.substr(pos + 1, tail - pos);\n    tail = pos - 1;\n  }\n  substrs[0] = key.substr(0, tail + 1);\n\n  // output\n  if (tile_size != nullptr) {\n    *tile_size = std::stof(substrs[2]);\n  }\n  if (grid_size != nullptr) {\n    *grid_size = std::stof(substrs[1]) / grid_size_ratio;\n  }\n  if (type_name != nullptr) {\n    *type_name = substrs[0];\n  }\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp"
		}
	}
]
I0403 13:41:32.034294 32175 json_parser.cpp:18] 
[
	26,
	{
		"bufnr" : 3,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All rights reserved.\n// Authors: Yongjian Zhao (yongjian.zhao@allride.ai)\n\n#include <fstream>\n#include <iostream>\n#include <sstream>\n#include <vector>\n\n#include \"common/io/proto_io.h\"\n#include \"common/proto/config/config_map.pb.h\"\n#include \"map_layer_dictionary_parser.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstatic const float grid_size_ratio = 1000.0f;  // convert from m to mm,\n\nbool MapLayerDictionaryParser::load(const std::string& dict_file) {\n  proto::config::MapLayerDictionary dict;\n  if (!common::ProtoIO::readProtoFromTextFile(dict_file, &dict)) {\n    std::cerr << \"MapLayerDictionaryParser: failed to load from dictionary file!\" << std::endl;\n    std::cerr << \"dict_file: \" << dict_file << std::endl;\n    return false;\n  }\n\n  for (const auto& item : dict.items()) {\n    int layer_id = item.layer_id();\n    std::string type_name = item.type_name();\n    float grid_size = item.grid_size();\n    float tile_size = item.tile_size();\n\n    // compose the key\n    std::string key;\n    composeKey(type_name, grid_size, tile_size, &key);\n\n    // set unordered_map\n    id_to_key_[layer_id] = key;\n    key_to_id_[key] = layer_id;\n  }\n\n  return true;\n}\n\nbool MapLayerDictionaryParser::getInfoById(const int layer_id, std::string* type_name,\n                                           float* grid_size, float* tile_size) {\n  if (id_to_key_.count(layer_id) == 0) {\n    return false;\n  }\n\n  analyseKey(id_to_key_[layer_id], type_name, grid_size, tile_size);\n  return true;\n}\n\nbool MapLayerDictionaryParser::getIdByInfo(const std::string& type_name, const float& grid_size,\n                                           const float& tile_size, int* layer_id) {\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 0) {\n    return false;\n  }\n\n  *layer_id = key_to_id_[key];\n  return true;\n}\n\nfloat MapLayerDictionaryParser::getGridSize(const int layer_id) {\n  float grid_size;\n  if(!getInfoById(layer_id, nullptr, &grid_size, nullptr)){\n    return -1; // return a negtive value for invalid layer_id\n  }\n\n  return grid_size;\n}\n\nfloat MapLayerDictionaryParser::getTileSize(const int layer_id) {\n  float tile_size;\n  if(!getInfoById(layer_id, nullptr, nullptr, &tile_size)){\n    return -1; // return a negtive value for invalid layer_id\n  }\n\n  return tile_size;\n}\n\nstd::string MapLayerDictionaryParser::getTypeName(const int layer_id) {\n  std::string type_name;\n  getInfoById(layer_id, &type_name, nullptr, nullptr);\n  return type_name;\n}\n\nbool MapLayerDictionaryParser::addItem(const int layer_id, const std::string& type_name,\n                                       const float grid_size, const float tile_size) {\n  if (id_to_key_.count(layer_id) == 1) {\n    std::cerr << \"failed to add item: layer_id \" << layer_id << \" has already exited in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 1) {\n    std::cerr << \"failed to add item: layer configuration has already existed in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  id_to_key_[layer_id] = key;\n  key_to_id_[key] = layer_id;\n  return true;\n}\n\nbool MapLayerDictionaryParser::save(const std::string& dict_file) {\n  // sort layer id\n  std::vector<int> layer_ids;\n  for (auto& pair : id_to_key_) {\n    layer_ids.emplace_back(pair.first);\n  }\n  std::sort(layer_ids.begin(), layer_ids.end());\n\n  // add item to dict\n  proto::config::MapLayerDictionary dict;\n  for (auto& id : layer_ids) {\n    // analyze key\n    std::string type_name;\n    float grid_size;\n    float tile_size;\n    analyseKey(id_to_key_[id], &type_name, &grid_size, &tile_size);\n\n    // add item\n    proto::config::MapLayerItem* item = dict.add_items();\n    item->set_layer_id(id);\n    item->set_type_name(type_name);\n    item->set_grid_size(grid_size);\n    item->set_tile_size(tile_size);\n  }\n\n  // write dict to file\n  return common::ProtoIO::writeProtoToTextFile(dict_file, dict);\n}\n\nvoid MapLayerDictionaryParser::composeKey(const std::string& type_name, const float& grid_size,\n                                          const float& tile_size, std::string* key) {\n  std::stringstream str_stream;\n  str_stream << type_name << \"_\" << static_cast<int>(grid_size * grid_size_ratio) << \"_\"\n             << static_cast<int>(tile_size);\n  *key = str_stream.str();\n}\n\nvoid MapLayerDictionaryParser::analyseKey(const std::string& key, std::string* type_name,\n                                          float* grid_size, float* tile_size) {\n  std::vector<std::string> substrs;\n  substrs.resize(3);\n\n  // achieve sub strings from key\n  size_t tail = key.size() - 1;\n  for (int i = 0; i < 2; i++) {\n    size_t pos = key.rfind('_', tail);\n    substrs[2 - i] = key.substr(pos + 1, tail - pos);\n    tail = pos - 1;\n  }\n  substrs[0] = key.substr(0, tail + 1);\n\n  // output\n  if (tile_size != nullptr) {\n    *tile_size = std::stof(substrs[2]);\n  }\n  if (grid_size != nullptr) {\n    *grid_size = std::stof(substrs[1]) / grid_size_ratio;\n  }\n  if (type_name != nullptr) {\n    *type_name = substrs[0];\n  }\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp"
		}
	}
]
I0403 13:41:50.833425 32175 json_parser.cpp:18] 
[
	27,
	{
		"bufnr" : 3,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All rights reserved.\n// Authors: Yongjian Zhao (yongjian.zhao@allride.ai)\n\n#include <fstream>\n#include <iostream>\n#include <sstream>\n#include <vector>\n\n#include \"common/io/proto_io.h\"\n#include \"common/proto/config/config_map.pb.h\"\n#include \"map_layer_dictionary_parser.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstatic const float grid_size_ratio = 1000.0f;  // convert from m to mm,\n\nbool MapLayerDictionaryParser::load(const std::string& dict_file) {\n  proto::config::MapLayerDictionary dict;\n  if (!common::ProtoIO::readProtoFromTextFile(dict_file, &dict)) {\n    std::cerr << \"MapLayerDictionaryParser: failed to load from dictionary file!\" << std::endl;\n    std::cerr << \"dict_file: \" << dict_file << std::endl;\n    return false;\n  }\n\n  for (const auto& item : dict.items()) {\n    int layer_id = item.layer_id();\n    std::string type_name = item.type_name();\n    float grid_size = item.grid_size();\n    float tile_size = item.tile_size();\n\n    // compose the key\n    std::string key;\n    composeKey(type_name, grid_size, tile_size, &key);\n\n    // set unordered_map\n    id_to_key_[layer_id] = key;\n    key_to_id_[key] = layer_id;\n  }\n\n  return true;\n}\n\nbool MapLayerDictionaryParser::getInfoById(const int layer_id, std::string* type_name,\n                                           float* grid_size, float* tile_size) {\n  if (id_to_key_.count(layer_id) == 0) {\n    return false;\n  }\n\n  analyseKey(id_to_key_[layer_id], type_name, grid_size, tile_size);\n  return true;\n}\n\nbool MapLayerDictionaryParser::getIdByInfo(const std::string& type_name, const float& grid_size,\n                                           const float& tile_size, int* layer_id) {\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 0) {\n    return false;\n  }\n\n  *layer_id = key_to_id_[key];\n  return true;\n}\n\nfloat MapLayerDictionaryParser::getGridSize(const int layer_id) {\n  float grid_size;\n  if(!getInfoById(layer_id, nullptr, &grid_size, nullptr)){\n    return -1; // return a negtive value for invalid layer_id\n  }\n\n  return grid_size;\n}\n\nfloat MapLayerDictionaryParser::getTileSize(const int layer_id) {\n  float tile_size;\n  if(!getInfoById(layer_id, nullptr, nullptr, &tile_size)){\n    return -1; // return a negtive value for invalid layer_id\n  }\n\n  return tile_size;\n}\n\nstd::string MapLayerDictionaryParser::getTypeName(const int layer_id) {\n  std::string type_name;\n  getInfoById(layer_id, &type_name, nullptr, nullptr);\n  return type_name;\n}\n\nbool MapLayerDictionaryParser::addItem(const int layer_id, const std::string& type_name,\n                                       const float grid_size, const float tile_size) {\n  if (id_to_key_.count(layer_id) == 1) {\n    std::cerr << \"failed to add item: layer_id \" << layer_id << \" has already exited in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 1) {\n    std::cerr << \"failed to add item: layer configuration has already existed in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  id_to_key_[layer_id] = key;\n  key_to_id_[key] = layer_id;\n  return true;\n}\n\nbool MapLayerDictionaryParser::save(const std::string& dict_file) {\n  // sort layer id\n  std::vector<int> layer_ids;\n  for (auto& pair : id_to_key_) {\n    layer_ids.emplace_back(pair.first);\n  }\n  std::sort(layer_ids.begin(), layer_ids.end());\n\n  // add item to dict\n  proto::config::MapLayerDictionary dict;\n  for (auto& id : layer_ids) {\n    // analyze key\n    std::string type_name;\n    float grid_size;\n    float tile_size;\n    analyseKey(id_to_key_[id], &type_name, &grid_size, &tile_size);\n\n    // add item\n    proto::config::MapLayerItem* item = dict.add_items();\n    item->set_layer_id(id);\n    item->set_type_name(type_name);\n    item->set_grid_size(grid_size);\n    item->set_tile_size(tile_size);\n  }\n\n  // write dict to file\n  return common::ProtoIO::writeProtoToTextFile(dict_file, dict);\n}\n\nvoid MapLayerDictionaryParser::composeKey(const std::string& type_name, const float& grid_size,\n                                          const float& tile_size, std::string* key) {\n  std::stringstream str_stream;\n  str_stream << type_name << \"_\" << static_cast<int>(grid_size * grid_size_ratio) << \"_\"\n             << static_cast<int>(tile_size);\n  *key = str_stream.str();\n}\n\nvoid MapLayerDictionaryParser::analyseKey(const std::string& key, std::string* type_name,\n                                          float* grid_size, float* tile_size) {\n  std::vector<std::string> substrs;\n  substrs.resize(3);\n\n  // achieve sub strings from key\n  size_t tail = key.size() - 1;\n  for (int i = 0; i < 2; i++) {\n    size_t pos = key.rfind('_', tail);\n    substrs[2 - i] = key.substr(pos + 1, tail - pos);\n    tail = pos - 1;\n  }\n  substrs[0] = key.substr(0, tail + 1);\n\n  // output\n  if (tile_size != nullptr) {\n    *tile_size = std::stof(substrs[2]);\n  }\n  if (grid_size != nullptr) {\n    *grid_size = std::stof(substrs[1]) / grid_size_ratio;\n  }\n  if (type_name != nullptr) {\n    *type_name = substrs[0];\n  }\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp"
		}
	}
]
I0403 13:41:53.273102 32175 json_parser.cpp:18] 
[
	28,
	{
		"bufnr" : 3,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All rights reserved.\n// Authors: Yongjian Zhao (yongjian.zhao@allride.ai)\n\n#include <fstream>\n#include <iostream>\n#include <sstream>\n#include <vector>\n\n#include \"common/io/proto_io.h\"\n#include \"common/proto/config/config_map.pb.h\"\n#include \"map_layer_dictionary_parser.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstatic const float grid_size_ratio = 1000.0f;  // convert from m to mm,\n\nbool MapLayerDictionaryParser::load(const std::string& dict_file) {\n  proto::config::MapLayerDictionary dict;\n  if (!common::ProtoIO::readProtoFromTextFile(dict_file, &dict)) {\n    std::cerr << \"MapLayerDictionaryParser: failed to load from dictionary file!\" << std::endl;\n    std::cerr << \"dict_file: \" << dict_file << std::endl;\n    return false;\n  }\n\n  for (const auto& item : dict.items()) {\n    int layer_id = item.layer_id();\n    std::string type_name = item.type_name();\n    float grid_size = item.grid_size();\n    float tile_size = item.tile_size();\n\n    // compose the key\n    std::string key;\n    composeKey(type_name, grid_size, tile_size, &key);\n\n    // set unordered_map\n    id_to_key_[layer_id] = key;\n    key_to_id_[key] = layer_id;\n  }\n\n  return true;\n}\n\nbool MapLayerDictionaryParser::getInfoById(const int layer_id, std::string* type_name,\n                                           float* grid_size, float* tile_size) {\n  if (id_to_key_.count(layer_id) == 0) {\n    return false;\n  }\n\n  analyseKey(id_to_key_[layer_id], type_name, grid_size, tile_size);\n  return true;\n}\n\nbool MapLayerDictionaryParser::getIdByInfo(const std::string& type_name, const float& grid_size,\n                                           const float& tile_size, int* layer_id) {\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 0) {\n    return false;\n  }\n\n  *layer_id = key_to_id_[key];\n  return true;\n}\n\nfloat MapLayerDictionaryParser::getGridSize(const int layer_id) {\n  float grid_size;\n  if(!getInfoById(layer_id, nullptr, &grid_size, nullptr)){\n    return -1; // return a negtive value for invalid layer_id\n  }\n\n  return grid_size;\n}\n\nfloat MapLayerDictionaryParser::getTileSize(const int layer_id) {\n  float tile_size;\n  if(!getInfoById(layer_id, nullptr, nullptr, &tile_size)){\n    return -1; // return a negtive value for invalid layer_id\n  }\n\n  return tile_size;\n}\n\nstd::string MapLayerDictionaryParser::getTypeName(const int layer_id) {\n  std::string type_name;\n  if(!getInfoById(layer_id, &type_name, nullptr, nullptr);\n  return type_name;\n}\n\nbool MapLayerDictionaryParser::addItem(const int layer_id, const std::string& type_name,\n                                       const float grid_size, const float tile_size) {\n  if (id_to_key_.count(layer_id) == 1) {\n    std::cerr << \"failed to add item: layer_id \" << layer_id << \" has already exited in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 1) {\n    std::cerr << \"failed to add item: layer configuration has already existed in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  id_to_key_[layer_id] = key;\n  key_to_id_[key] = layer_id;\n  return true;\n}\n\nbool MapLayerDictionaryParser::save(const std::string& dict_file) {\n  // sort layer id\n  std::vector<int> layer_ids;\n  for (auto& pair : id_to_key_) {\n    layer_ids.emplace_back(pair.first);\n  }\n  std::sort(layer_ids.begin(), layer_ids.end());\n\n  // add item to dict\n  proto::config::MapLayerDictionary dict;\n  for (auto& id : layer_ids) {\n    // analyze key\n    std::string type_name;\n    float grid_size;\n    float tile_size;\n    analyseKey(id_to_key_[id], &type_name, &grid_size, &tile_size);\n\n    // add item\n    proto::config::MapLayerItem* item = dict.add_items();\n    item->set_layer_id(id);\n    item->set_type_name(type_name);\n    item->set_grid_size(grid_size);\n    item->set_tile_size(tile_size);\n  }\n\n  // write dict to file\n  return common::ProtoIO::writeProtoToTextFile(dict_file, dict);\n}\n\nvoid MapLayerDictionaryParser::composeKey(const std::string& type_name, const float& grid_size,\n                                          const float& tile_size, std::string* key) {\n  std::stringstream str_stream;\n  str_stream << type_name << \"_\" << static_cast<int>(grid_size * grid_size_ratio) << \"_\"\n             << static_cast<int>(tile_size);\n  *key = str_stream.str();\n}\n\nvoid MapLayerDictionaryParser::analyseKey(const std::string& key, std::string* type_name,\n                                          float* grid_size, float* tile_size) {\n  std::vector<std::string> substrs;\n  substrs.resize(3);\n\n  // achieve sub strings from key\n  size_t tail = key.size() - 1;\n  for (int i = 0; i < 2; i++) {\n    size_t pos = key.rfind('_', tail);\n    substrs[2 - i] = key.substr(pos + 1, tail - pos);\n    tail = pos - 1;\n  }\n  substrs[0] = key.substr(0, tail + 1);\n\n  // output\n  if (tile_size != nullptr) {\n    *tile_size = std::stof(substrs[2]);\n  }\n  if (grid_size != nullptr) {\n    *grid_size = std::stof(substrs[1]) / grid_size_ratio;\n  }\n  if (type_name != nullptr) {\n    *type_name = substrs[0];\n  }\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp"
		}
	}
]
I0403 13:41:54.905396 32175 json_parser.cpp:18] 
[
	29,
	{
		"bufnr" : 3,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All rights reserved.\n// Authors: Yongjian Zhao (yongjian.zhao@allride.ai)\n\n#include <fstream>\n#include <iostream>\n#include <sstream>\n#include <vector>\n\n#include \"common/io/proto_io.h\"\n#include \"common/proto/config/config_map.pb.h\"\n#include \"map_layer_dictionary_parser.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstatic const float grid_size_ratio = 1000.0f;  // convert from m to mm,\n\nbool MapLayerDictionaryParser::load(const std::string& dict_file) {\n  proto::config::MapLayerDictionary dict;\n  if (!common::ProtoIO::readProtoFromTextFile(dict_file, &dict)) {\n    std::cerr << \"MapLayerDictionaryParser: failed to load from dictionary file!\" << std::endl;\n    std::cerr << \"dict_file: \" << dict_file << std::endl;\n    return false;\n  }\n\n  for (const auto& item : dict.items()) {\n    int layer_id = item.layer_id();\n    std::string type_name = item.type_name();\n    float grid_size = item.grid_size();\n    float tile_size = item.tile_size();\n\n    // compose the key\n    std::string key;\n    composeKey(type_name, grid_size, tile_size, &key);\n\n    // set unordered_map\n    id_to_key_[layer_id] = key;\n    key_to_id_[key] = layer_id;\n  }\n\n  return true;\n}\n\nbool MapLayerDictionaryParser::getInfoById(const int layer_id, std::string* type_name,\n                                           float* grid_size, float* tile_size) {\n  if (id_to_key_.count(layer_id) == 0) {\n    return false;\n  }\n\n  analyseKey(id_to_key_[layer_id], type_name, grid_size, tile_size);\n  return true;\n}\n\nbool MapLayerDictionaryParser::getIdByInfo(const std::string& type_name, const float& grid_size,\n                                           const float& tile_size, int* layer_id) {\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 0) {\n    return false;\n  }\n\n  *layer_id = key_to_id_[key];\n  return true;\n}\n\nfloat MapLayerDictionaryParser::getGridSize(const int layer_id) {\n  float grid_size;\n  if(!getInfoById(layer_id, nullptr, &grid_size, nullptr)){\n    return -1; // return a negtive value for invalid layer_id\n  }\n\n  return grid_size;\n}\n\nfloat MapLayerDictionaryParser::getTileSize(const int layer_id) {\n  float tile_size;\n  if(!getInfoById(layer_id, nullptr, nullptr, &tile_size)){\n    return -1; // return a negtive value for invalid layer_id\n  }\n\n  return tile_size;\n}\n\nstd::string MapLayerDictionaryParser::getTypeName(const int layer_id) {\n  std::string type_name;\n  if(!getInfoById(layer_id, &type_name, nullptr, nullptr);\n  return type_name;\n}\n\nbool MapLayerDictionaryParser::addItem(const int layer_id, const std::string& type_name,\n                                       const float grid_size, const float tile_size) {\n  if (id_to_key_.count(layer_id) == 1) {\n    std::cerr << \"failed to add item: layer_id \" << layer_id << \" has already exited in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 1) {\n    std::cerr << \"failed to add item: layer configuration has already existed in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  id_to_key_[layer_id] = key;\n  key_to_id_[key] = layer_id;\n  return true;\n}\n\nbool MapLayerDictionaryParser::save(const std::string& dict_file) {\n  // sort layer id\n  std::vector<int> layer_ids;\n  for (auto& pair : id_to_key_) {\n    layer_ids.emplace_back(pair.first);\n  }\n  std::sort(layer_ids.begin(), layer_ids.end());\n\n  // add item to dict\n  proto::config::MapLayerDictionary dict;\n  for (auto& id : layer_ids) {\n    // analyze key\n    std::string type_name;\n    float grid_size;\n    float tile_size;\n    analyseKey(id_to_key_[id], &type_name, &grid_size, &tile_size);\n\n    // add item\n    proto::config::MapLayerItem* item = dict.add_items();\n    item->set_layer_id(id);\n    item->set_type_name(type_name);\n    item->set_grid_size(grid_size);\n    item->set_tile_size(tile_size);\n  }\n\n  // write dict to file\n  return common::ProtoIO::writeProtoToTextFile(dict_file, dict);\n}\n\nvoid MapLayerDictionaryParser::composeKey(const std::string& type_name, const float& grid_size,\n                                          const float& tile_size, std::string* key) {\n  std::stringstream str_stream;\n  str_stream << type_name << \"_\" << static_cast<int>(grid_size * grid_size_ratio) << \"_\"\n             << static_cast<int>(tile_size);\n  *key = str_stream.str();\n}\n\nvoid MapLayerDictionaryParser::analyseKey(const std::string& key, std::string* type_name,\n                                          float* grid_size, float* tile_size) {\n  std::vector<std::string> substrs;\n  substrs.resize(3);\n\n  // achieve sub strings from key\n  size_t tail = key.size() - 1;\n  for (int i = 0; i < 2; i++) {\n    size_t pos = key.rfind('_', tail);\n    substrs[2 - i] = key.substr(pos + 1, tail - pos);\n    tail = pos - 1;\n  }\n  substrs[0] = key.substr(0, tail + 1);\n\n  // output\n  if (tile_size != nullptr) {\n    *tile_size = std::stof(substrs[2]);\n  }\n  if (grid_size != nullptr) {\n    *grid_size = std::stof(substrs[1]) / grid_size_ratio;\n  }\n  if (type_name != nullptr) {\n    *type_name = substrs[0];\n  }\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp"
		}
	}
]
I0403 13:41:57.368577 32175 json_parser.cpp:18] 
[
	30,
	{
		"bufnr" : 3,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All rights reserved.\n// Authors: Yongjian Zhao (yongjian.zhao@allride.ai)\n\n#include <fstream>\n#include <iostream>\n#include <sstream>\n#include <vector>\n\n#include \"common/io/proto_io.h\"\n#include \"common/proto/config/config_map.pb.h\"\n#include \"map_layer_dictionary_parser.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstatic const float grid_size_ratio = 1000.0f;  // convert from m to mm,\n\nbool MapLayerDictionaryParser::load(const std::string& dict_file) {\n  proto::config::MapLayerDictionary dict;\n  if (!common::ProtoIO::readProtoFromTextFile(dict_file, &dict)) {\n    std::cerr << \"MapLayerDictionaryParser: failed to load from dictionary file!\" << std::endl;\n    std::cerr << \"dict_file: \" << dict_file << std::endl;\n    return false;\n  }\n\n  for (const auto& item : dict.items()) {\n    int layer_id = item.layer_id();\n    std::string type_name = item.type_name();\n    float grid_size = item.grid_size();\n    float tile_size = item.tile_size();\n\n    // compose the key\n    std::string key;\n    composeKey(type_name, grid_size, tile_size, &key);\n\n    // set unordered_map\n    id_to_key_[layer_id] = key;\n    key_to_id_[key] = layer_id;\n  }\n\n  return true;\n}\n\nbool MapLayerDictionaryParser::getInfoById(const int layer_id, std::string* type_name,\n                                           float* grid_size, float* tile_size) {\n  if (id_to_key_.count(layer_id) == 0) {\n    return false;\n  }\n\n  analyseKey(id_to_key_[layer_id], type_name, grid_size, tile_size);\n  return true;\n}\n\nbool MapLayerDictionaryParser::getIdByInfo(const std::string& type_name, const float& grid_size,\n                                           const float& tile_size, int* layer_id) {\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 0) {\n    return false;\n  }\n\n  *layer_id = key_to_id_[key];\n  return true;\n}\n\nfloat MapLayerDictionaryParser::getGridSize(const int layer_id) {\n  float grid_size;\n  if(!getInfoById(layer_id, nullptr, &grid_size, nullptr)){\n    return -1; // return a negtive value for invalid layer_id\n  }\n\n  return grid_size;\n}\n\nfloat MapLayerDictionaryParser::getTileSize(const int layer_id) {\n  float tile_size;\n  if(!getInfoById(layer_id, nullptr, nullptr, &tile_size)){\n    return -1; // return a negtive value for invalid layer_id\n  }\n\n  return tile_size;\n}\n\nstd::string MapLayerDictionaryParser::getTypeName(const int layer_id) {\n  std::string type_name;\n  if(!getInfoById(layer_id, &type_name, nullptr, nullptr)){\n  }\n  return type_name;\n}\n\nbool MapLayerDictionaryParser::addItem(const int layer_id, const std::string& type_name,\n                                       const float grid_size, const float tile_size) {\n  if (id_to_key_.count(layer_id) == 1) {\n    std::cerr << \"failed to add item: layer_id \" << layer_id << \" has already exited in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 1) {\n    std::cerr << \"failed to add item: layer configuration has already existed in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  id_to_key_[layer_id] = key;\n  key_to_id_[key] = layer_id;\n  return true;\n}\n\nbool MapLayerDictionaryParser::save(const std::string& dict_file) {\n  // sort layer id\n  std::vector<int> layer_ids;\n  for (auto& pair : id_to_key_) {\n    layer_ids.emplace_back(pair.first);\n  }\n  std::sort(layer_ids.begin(), layer_ids.end());\n\n  // add item to dict\n  proto::config::MapLayerDictionary dict;\n  for (auto& id : layer_ids) {\n    // analyze key\n    std::string type_name;\n    float grid_size;\n    float tile_size;\n    analyseKey(id_to_key_[id], &type_name, &grid_size, &tile_size);\n\n    // add item\n    proto::config::MapLayerItem* item = dict.add_items();\n    item->set_layer_id(id);\n    item->set_type_name(type_name);\n    item->set_grid_size(grid_size);\n    item->set_tile_size(tile_size);\n  }\n\n  // write dict to file\n  return common::ProtoIO::writeProtoToTextFile(dict_file, dict);\n}\n\nvoid MapLayerDictionaryParser::composeKey(const std::string& type_name, const float& grid_size,\n                                          const float& tile_size, std::string* key) {\n  std::stringstream str_stream;\n  str_stream << type_name << \"_\" << static_cast<int>(grid_size * grid_size_ratio) << \"_\"\n             << static_cast<int>(tile_size);\n  *key = str_stream.str();\n}\n\nvoid MapLayerDictionaryParser::analyseKey(const std::string& key, std::string* type_name,\n                                          float* grid_size, float* tile_size) {\n  std::vector<std::string> substrs;\n  substrs.resize(3);\n\n  // achieve sub strings from key\n  size_t tail = key.size() - 1;\n  for (int i = 0; i < 2; i++) {\n    size_t pos = key.rfind('_', tail);\n    substrs[2 - i] = key.substr(pos + 1, tail - pos);\n    tail = pos - 1;\n  }\n  substrs[0] = key.substr(0, tail + 1);\n\n  // output\n  if (tile_size != nullptr) {\n    *tile_size = std::stof(substrs[2]);\n  }\n  if (grid_size != nullptr) {\n    *grid_size = std::stof(substrs[1]) / grid_size_ratio;\n  }\n  if (type_name != nullptr) {\n    *type_name = substrs[0];\n  }\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp"
		}
	}
]
I0403 13:41:57.832320 32175 json_parser.cpp:18] 
[
	31,
	{
		"bufnr" : 3,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All rights reserved.\n// Authors: Yongjian Zhao (yongjian.zhao@allride.ai)\n\n#include <fstream>\n#include <iostream>\n#include <sstream>\n#include <vector>\n\n#include \"common/io/proto_io.h\"\n#include \"common/proto/config/config_map.pb.h\"\n#include \"map_layer_dictionary_parser.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstatic const float grid_size_ratio = 1000.0f;  // convert from m to mm,\n\nbool MapLayerDictionaryParser::load(const std::string& dict_file) {\n  proto::config::MapLayerDictionary dict;\n  if (!common::ProtoIO::readProtoFromTextFile(dict_file, &dict)) {\n    std::cerr << \"MapLayerDictionaryParser: failed to load from dictionary file!\" << std::endl;\n    std::cerr << \"dict_file: \" << dict_file << std::endl;\n    return false;\n  }\n\n  for (const auto& item : dict.items()) {\n    int layer_id = item.layer_id();\n    std::string type_name = item.type_name();\n    float grid_size = item.grid_size();\n    float tile_size = item.tile_size();\n\n    // compose the key\n    std::string key;\n    composeKey(type_name, grid_size, tile_size, &key);\n\n    // set unordered_map\n    id_to_key_[layer_id] = key;\n    key_to_id_[key] = layer_id;\n  }\n\n  return true;\n}\n\nbool MapLayerDictionaryParser::getInfoById(const int layer_id, std::string* type_name,\n                                           float* grid_size, float* tile_size) {\n  if (id_to_key_.count(layer_id) == 0) {\n    return false;\n  }\n\n  analyseKey(id_to_key_[layer_id], type_name, grid_size, tile_size);\n  return true;\n}\n\nbool MapLayerDictionaryParser::getIdByInfo(const std::string& type_name, const float& grid_size,\n                                           const float& tile_size, int* layer_id) {\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 0) {\n    return false;\n  }\n\n  *layer_id = key_to_id_[key];\n  return true;\n}\n\nfloat MapLayerDictionaryParser::getGridSize(const int layer_id) {\n  float grid_size;\n  if(!getInfoById(layer_id, nullptr, &grid_size, nullptr)){\n    return -1; // return a negtive value for invalid layer_id\n  }\n\n  return grid_size;\n}\n\nfloat MapLayerDictionaryParser::getTileSize(const int layer_id) {\n  float tile_size;\n  if(!getInfoById(layer_id, nullptr, nullptr, &tile_size)){\n    return -1; // return a negtive value for invalid layer_id\n  }\n\n  return tile_size;\n}\n\nstd::string MapLayerDictionaryParser::getTypeName(const int layer_id) {\n  std::string type_name;\n  if(!getInfoById(layer_id, &type_name, nullptr, nullptr)){\n\n  }\n  return type_name;\n}\n\nbool MapLayerDictionaryParser::addItem(const int layer_id, const std::string& type_name,\n                                       const float grid_size, const float tile_size) {\n  if (id_to_key_.count(layer_id) == 1) {\n    std::cerr << \"failed to add item: layer_id \" << layer_id << \" has already exited in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 1) {\n    std::cerr << \"failed to add item: layer configuration has already existed in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  id_to_key_[layer_id] = key;\n  key_to_id_[key] = layer_id;\n  return true;\n}\n\nbool MapLayerDictionaryParser::save(const std::string& dict_file) {\n  // sort layer id\n  std::vector<int> layer_ids;\n  for (auto& pair : id_to_key_) {\n    layer_ids.emplace_back(pair.first);\n  }\n  std::sort(layer_ids.begin(), layer_ids.end());\n\n  // add item to dict\n  proto::config::MapLayerDictionary dict;\n  for (auto& id : layer_ids) {\n    // analyze key\n    std::string type_name;\n    float grid_size;\n    float tile_size;\n    analyseKey(id_to_key_[id], &type_name, &grid_size, &tile_size);\n\n    // add item\n    proto::config::MapLayerItem* item = dict.add_items();\n    item->set_layer_id(id);\n    item->set_type_name(type_name);\n    item->set_grid_size(grid_size);\n    item->set_tile_size(tile_size);\n  }\n\n  // write dict to file\n  return common::ProtoIO::writeProtoToTextFile(dict_file, dict);\n}\n\nvoid MapLayerDictionaryParser::composeKey(const std::string& type_name, const float& grid_size,\n                                          const float& tile_size, std::string* key) {\n  std::stringstream str_stream;\n  str_stream << type_name << \"_\" << static_cast<int>(grid_size * grid_size_ratio) << \"_\"\n             << static_cast<int>(tile_size);\n  *key = str_stream.str();\n}\n\nvoid MapLayerDictionaryParser::analyseKey(const std::string& key, std::string* type_name,\n                                          float* grid_size, float* tile_size) {\n  std::vector<std::string> substrs;\n  substrs.resize(3);\n\n  // achieve sub strings from key\n  size_t tail = key.size() - 1;\n  for (int i = 0; i < 2; i++) {\n    size_t pos = key.rfind('_', tail);\n    substrs[2 - i] = key.substr(pos + 1, tail - pos);\n    tail = pos - 1;\n  }\n  substrs[0] = key.substr(0, tail + 1);\n\n  // output\n  if (tile_size != nullptr) {\n    *tile_size = std::stof(substrs[2]);\n  }\n  if (grid_size != nullptr) {\n    *grid_size = std::stof(substrs[1]) / grid_size_ratio;\n  }\n  if (type_name != nullptr) {\n    *type_name = substrs[0];\n  }\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp"
		}
	}
]
I0403 13:41:58.758066 32175 json_parser.cpp:18] 
[
	32,
	{
		"bufnr" : 3,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All rights reserved.\n// Authors: Yongjian Zhao (yongjian.zhao@allride.ai)\n\n#include <fstream>\n#include <iostream>\n#include <sstream>\n#include <vector>\n\n#include \"common/io/proto_io.h\"\n#include \"common/proto/config/config_map.pb.h\"\n#include \"map_layer_dictionary_parser.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstatic const float grid_size_ratio = 1000.0f;  // convert from m to mm,\n\nbool MapLayerDictionaryParser::load(const std::string& dict_file) {\n  proto::config::MapLayerDictionary dict;\n  if (!common::ProtoIO::readProtoFromTextFile(dict_file, &dict)) {\n    std::cerr << \"MapLayerDictionaryParser: failed to load from dictionary file!\" << std::endl;\n    std::cerr << \"dict_file: \" << dict_file << std::endl;\n    return false;\n  }\n\n  for (const auto& item : dict.items()) {\n    int layer_id = item.layer_id();\n    std::string type_name = item.type_name();\n    float grid_size = item.grid_size();\n    float tile_size = item.tile_size();\n\n    // compose the key\n    std::string key;\n    composeKey(type_name, grid_size, tile_size, &key);\n\n    // set unordered_map\n    id_to_key_[layer_id] = key;\n    key_to_id_[key] = layer_id;\n  }\n\n  return true;\n}\n\nbool MapLayerDictionaryParser::getInfoById(const int layer_id, std::string* type_name,\n                                           float* grid_size, float* tile_size) {\n  if (id_to_key_.count(layer_id) == 0) {\n    return false;\n  }\n\n  analyseKey(id_to_key_[layer_id], type_name, grid_size, tile_size);\n  return true;\n}\n\nbool MapLayerDictionaryParser::getIdByInfo(const std::string& type_name, const float& grid_size,\n                                           const float& tile_size, int* layer_id) {\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 0) {\n    return false;\n  }\n\n  *layer_id = key_to_id_[key];\n  return true;\n}\n\nfloat MapLayerDictionaryParser::getGridSize(const int layer_id) {\n  float grid_size;\n  if(!getInfoById(layer_id, nullptr, &grid_size, nullptr)){\n    return -1; // return a negtive value for invalid layer_id\n  }\n\n  return grid_size;\n}\n\nfloat MapLayerDictionaryParser::getTileSize(const int layer_id) {\n  float tile_size;\n  if(!getInfoById(layer_id, nullptr, nullptr, &tile_size)){\n    return -1; // return a negtive value for invalid layer_id\n  }\n\n  return tile_size;\n}\n\nstd::string MapLayerDictionaryParser::getTypeName(const int layer_id) {\n  std::string type_name;\n  if(!getInfoById(layer_id, &type_name, nullptr, nullptr)){\n  }\n  return type_name;\n}\n\nbool MapLayerDictionaryParser::addItem(const int layer_id, const std::string& type_name,\n                                       const float grid_size, const float tile_size) {\n  if (id_to_key_.count(layer_id) == 1) {\n    std::cerr << \"failed to add item: layer_id \" << layer_id << \" has already exited in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 1) {\n    std::cerr << \"failed to add item: layer configuration has already existed in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  id_to_key_[layer_id] = key;\n  key_to_id_[key] = layer_id;\n  return true;\n}\n\nbool MapLayerDictionaryParser::save(const std::string& dict_file) {\n  // sort layer id\n  std::vector<int> layer_ids;\n  for (auto& pair : id_to_key_) {\n    layer_ids.emplace_back(pair.first);\n  }\n  std::sort(layer_ids.begin(), layer_ids.end());\n\n  // add item to dict\n  proto::config::MapLayerDictionary dict;\n  for (auto& id : layer_ids) {\n    // analyze key\n    std::string type_name;\n    float grid_size;\n    float tile_size;\n    analyseKey(id_to_key_[id], &type_name, &grid_size, &tile_size);\n\n    // add item\n    proto::config::MapLayerItem* item = dict.add_items();\n    item->set_layer_id(id);\n    item->set_type_name(type_name);\n    item->set_grid_size(grid_size);\n    item->set_tile_size(tile_size);\n  }\n\n  // write dict to file\n  return common::ProtoIO::writeProtoToTextFile(dict_file, dict);\n}\n\nvoid MapLayerDictionaryParser::composeKey(const std::string& type_name, const float& grid_size,\n                                          const float& tile_size, std::string* key) {\n  std::stringstream str_stream;\n  str_stream << type_name << \"_\" << static_cast<int>(grid_size * grid_size_ratio) << \"_\"\n             << static_cast<int>(tile_size);\n  *key = str_stream.str();\n}\n\nvoid MapLayerDictionaryParser::analyseKey(const std::string& key, std::string* type_name,\n                                          float* grid_size, float* tile_size) {\n  std::vector<std::string> substrs;\n  substrs.resize(3);\n\n  // achieve sub strings from key\n  size_t tail = key.size() - 1;\n  for (int i = 0; i < 2; i++) {\n    size_t pos = key.rfind('_', tail);\n    substrs[2 - i] = key.substr(pos + 1, tail - pos);\n    tail = pos - 1;\n  }\n  substrs[0] = key.substr(0, tail + 1);\n\n  // output\n  if (tile_size != nullptr) {\n    *tile_size = std::stof(substrs[2]);\n  }\n  if (grid_size != nullptr) {\n    *grid_size = std::stof(substrs[1]) / grid_size_ratio;\n  }\n  if (type_name != nullptr) {\n    *type_name = substrs[0];\n  }\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp"
		}
	}
]
I0403 13:41:59.040907 32175 json_parser.cpp:18] 
[
	33,
	{
		"bufnr" : 3,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All rights reserved.\n// Authors: Yongjian Zhao (yongjian.zhao@allride.ai)\n\n#include <fstream>\n#include <iostream>\n#include <sstream>\n#include <vector>\n\n#include \"common/io/proto_io.h\"\n#include \"common/proto/config/config_map.pb.h\"\n#include \"map_layer_dictionary_parser.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstatic const float grid_size_ratio = 1000.0f;  // convert from m to mm,\n\nbool MapLayerDictionaryParser::load(const std::string& dict_file) {\n  proto::config::MapLayerDictionary dict;\n  if (!common::ProtoIO::readProtoFromTextFile(dict_file, &dict)) {\n    std::cerr << \"MapLayerDictionaryParser: failed to load from dictionary file!\" << std::endl;\n    std::cerr << \"dict_file: \" << dict_file << std::endl;\n    return false;\n  }\n\n  for (const auto& item : dict.items()) {\n    int layer_id = item.layer_id();\n    std::string type_name = item.type_name();\n    float grid_size = item.grid_size();\n    float tile_size = item.tile_size();\n\n    // compose the key\n    std::string key;\n    composeKey(type_name, grid_size, tile_size, &key);\n\n    // set unordered_map\n    id_to_key_[layer_id] = key;\n    key_to_id_[key] = layer_id;\n  }\n\n  return true;\n}\n\nbool MapLayerDictionaryParser::getInfoById(const int layer_id, std::string* type_name,\n                                           float* grid_size, float* tile_size) {\n  if (id_to_key_.count(layer_id) == 0) {\n    return false;\n  }\n\n  analyseKey(id_to_key_[layer_id], type_name, grid_size, tile_size);\n  return true;\n}\n\nbool MapLayerDictionaryParser::getIdByInfo(const std::string& type_name, const float& grid_size,\n                                           const float& tile_size, int* layer_id) {\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 0) {\n    return false;\n  }\n\n  *layer_id = key_to_id_[key];\n  return true;\n}\n\nfloat MapLayerDictionaryParser::getGridSize(const int layer_id) {\n  float grid_size;\n  if(!getInfoById(layer_id, nullptr, &grid_size, nullptr)){\n    return -1; // return a negtive value for invalid layer_id\n  }\n\n  return grid_size;\n}\n\nfloat MapLayerDictionaryParser::getTileSize(const int layer_id) {\n  float tile_size;\n  if(!getInfoById(layer_id, nullptr, nullptr, &tile_size)){\n    return -1; // return a negtive value for invalid layer_id\n  }\n\n  return tile_size;\n}\n\nstd::string MapLayerDictionaryParser::getTypeName(const int layer_id) {\n  std::string type_name;\n  if(!getInfoById(layer_id, &type_name, nullptr, nullptr)){\n    \n  }\n  return type_name;\n}\n\nbool MapLayerDictionaryParser::addItem(const int layer_id, const std::string& type_name,\n                                       const float grid_size, const float tile_size) {\n  if (id_to_key_.count(layer_id) == 1) {\n    std::cerr << \"failed to add item: layer_id \" << layer_id << \" has already exited in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 1) {\n    std::cerr << \"failed to add item: layer configuration has already existed in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  id_to_key_[layer_id] = key;\n  key_to_id_[key] = layer_id;\n  return true;\n}\n\nbool MapLayerDictionaryParser::save(const std::string& dict_file) {\n  // sort layer id\n  std::vector<int> layer_ids;\n  for (auto& pair : id_to_key_) {\n    layer_ids.emplace_back(pair.first);\n  }\n  std::sort(layer_ids.begin(), layer_ids.end());\n\n  // add item to dict\n  proto::config::MapLayerDictionary dict;\n  for (auto& id : layer_ids) {\n    // analyze key\n    std::string type_name;\n    float grid_size;\n    float tile_size;\n    analyseKey(id_to_key_[id], &type_name, &grid_size, &tile_size);\n\n    // add item\n    proto::config::MapLayerItem* item = dict.add_items();\n    item->set_layer_id(id);\n    item->set_type_name(type_name);\n    item->set_grid_size(grid_size);\n    item->set_tile_size(tile_size);\n  }\n\n  // write dict to file\n  return common::ProtoIO::writeProtoToTextFile(dict_file, dict);\n}\n\nvoid MapLayerDictionaryParser::composeKey(const std::string& type_name, const float& grid_size,\n                                          const float& tile_size, std::string* key) {\n  std::stringstream str_stream;\n  str_stream << type_name << \"_\" << static_cast<int>(grid_size * grid_size_ratio) << \"_\"\n             << static_cast<int>(tile_size);\n  *key = str_stream.str();\n}\n\nvoid MapLayerDictionaryParser::analyseKey(const std::string& key, std::string* type_name,\n                                          float* grid_size, float* tile_size) {\n  std::vector<std::string> substrs;\n  substrs.resize(3);\n\n  // achieve sub strings from key\n  size_t tail = key.size() - 1;\n  for (int i = 0; i < 2; i++) {\n    size_t pos = key.rfind('_', tail);\n    substrs[2 - i] = key.substr(pos + 1, tail - pos);\n    tail = pos - 1;\n  }\n  substrs[0] = key.substr(0, tail + 1);\n\n  // output\n  if (tile_size != nullptr) {\n    *tile_size = std::stof(substrs[2]);\n  }\n  if (grid_size != nullptr) {\n    *grid_size = std::stof(substrs[1]) / grid_size_ratio;\n  }\n  if (type_name != nullptr) {\n    *type_name = substrs[0];\n  }\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp"
		}
	}
]
I0403 13:42:02.423995 32175 json_parser.cpp:18] 
[
	34,
	{
		"bufnr" : 3,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All rights reserved.\n// Authors: Yongjian Zhao (yongjian.zhao@allride.ai)\n\n#include <fstream>\n#include <iostream>\n#include <sstream>\n#include <vector>\n\n#include \"common/io/proto_io.h\"\n#include \"common/proto/config/config_map.pb.h\"\n#include \"map_layer_dictionary_parser.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstatic const float grid_size_ratio = 1000.0f;  // convert from m to mm,\n\nbool MapLayerDictionaryParser::load(const std::string& dict_file) {\n  proto::config::MapLayerDictionary dict;\n  if (!common::ProtoIO::readProtoFromTextFile(dict_file, &dict)) {\n    std::cerr << \"MapLayerDictionaryParser: failed to load from dictionary file!\" << std::endl;\n    std::cerr << \"dict_file: \" << dict_file << std::endl;\n    return false;\n  }\n\n  for (const auto& item : dict.items()) {\n    int layer_id = item.layer_id();\n    std::string type_name = item.type_name();\n    float grid_size = item.grid_size();\n    float tile_size = item.tile_size();\n\n    // compose the key\n    std::string key;\n    composeKey(type_name, grid_size, tile_size, &key);\n\n    // set unordered_map\n    id_to_key_[layer_id] = key;\n    key_to_id_[key] = layer_id;\n  }\n\n  return true;\n}\n\nbool MapLayerDictionaryParser::getInfoById(const int layer_id, std::string* type_name,\n                                           float* grid_size, float* tile_size) {\n  if (id_to_key_.count(layer_id) == 0) {\n    return false;\n  }\n\n  analyseKey(id_to_key_[layer_id], type_name, grid_size, tile_size);\n  return true;\n}\n\nbool MapLayerDictionaryParser::getIdByInfo(const std::string& type_name, const float& grid_size,\n                                           const float& tile_size, int* layer_id) {\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 0) {\n    return false;\n  }\n\n  *layer_id = key_to_id_[key];\n  return true;\n}\n\nfloat MapLayerDictionaryParser::getGridSize(const int layer_id) {\n  float grid_size;\n  if(!getInfoById(layer_id, nullptr, &grid_size, nullptr)){\n    return -1; // return a negtive value for invalid layer_id\n  }\n\n  return grid_size;\n}\n\nfloat MapLayerDictionaryParser::getTileSize(const int layer_id) {\n  float tile_size;\n  if(!getInfoById(layer_id, nullptr, nullptr, &tile_size)){\n    return -1; // return a negtive value for invalid layer_id\n  }\n\n  return tile_size;\n}\n\nstd::string MapLayerDictionaryParser::getTypeName(const int layer_id) {\n  std::string type_name;\n  if(!getInfoById(layer_id, &type_name, nullptr, nullptr)){\n    return \"\";\n  }\n  return type_name;\n}\n\nbool MapLayerDictionaryParser::addItem(const int layer_id, const std::string& type_name,\n                                       const float grid_size, const float tile_size) {\n  if (id_to_key_.count(layer_id) == 1) {\n    std::cerr << \"failed to add item: layer_id \" << layer_id << \" has already exited in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 1) {\n    std::cerr << \"failed to add item: layer configuration has already existed in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  id_to_key_[layer_id] = key;\n  key_to_id_[key] = layer_id;\n  return true;\n}\n\nbool MapLayerDictionaryParser::save(const std::string& dict_file) {\n  // sort layer id\n  std::vector<int> layer_ids;\n  for (auto& pair : id_to_key_) {\n    layer_ids.emplace_back(pair.first);\n  }\n  std::sort(layer_ids.begin(), layer_ids.end());\n\n  // add item to dict\n  proto::config::MapLayerDictionary dict;\n  for (auto& id : layer_ids) {\n    // analyze key\n    std::string type_name;\n    float grid_size;\n    float tile_size;\n    analyseKey(id_to_key_[id], &type_name, &grid_size, &tile_size);\n\n    // add item\n    proto::config::MapLayerItem* item = dict.add_items();\n    item->set_layer_id(id);\n    item->set_type_name(type_name);\n    item->set_grid_size(grid_size);\n    item->set_tile_size(tile_size);\n  }\n\n  // write dict to file\n  return common::ProtoIO::writeProtoToTextFile(dict_file, dict);\n}\n\nvoid MapLayerDictionaryParser::composeKey(const std::string& type_name, const float& grid_size,\n                                          const float& tile_size, std::string* key) {\n  std::stringstream str_stream;\n  str_stream << type_name << \"_\" << static_cast<int>(grid_size * grid_size_ratio) << \"_\"\n             << static_cast<int>(tile_size);\n  *key = str_stream.str();\n}\n\nvoid MapLayerDictionaryParser::analyseKey(const std::string& key, std::string* type_name,\n                                          float* grid_size, float* tile_size) {\n  std::vector<std::string> substrs;\n  substrs.resize(3);\n\n  // achieve sub strings from key\n  size_t tail = key.size() - 1;\n  for (int i = 0; i < 2; i++) {\n    size_t pos = key.rfind('_', tail);\n    substrs[2 - i] = key.substr(pos + 1, tail - pos);\n    tail = pos - 1;\n  }\n  substrs[0] = key.substr(0, tail + 1);\n\n  // output\n  if (tile_size != nullptr) {\n    *tile_size = std::stof(substrs[2]);\n  }\n  if (grid_size != nullptr) {\n    *grid_size = std::stof(substrs[1]) / grid_size_ratio;\n  }\n  if (type_name != nullptr) {\n    *type_name = substrs[0];\n  }\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp"
		}
	}
]
I0403 13:42:04.433394 32175 json_parser.cpp:18] 
[
	35,
	{
		"bufnr" : 3,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All rights reserved.\n// Authors: Yongjian Zhao (yongjian.zhao@allride.ai)\n\n#include <fstream>\n#include <iostream>\n#include <sstream>\n#include <vector>\n\n#include \"common/io/proto_io.h\"\n#include \"common/proto/config/config_map.pb.h\"\n#include \"map_layer_dictionary_parser.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstatic const float grid_size_ratio = 1000.0f;  // convert from m to mm,\n\nbool MapLayerDictionaryParser::load(const std::string& dict_file) {\n  proto::config::MapLayerDictionary dict;\n  if (!common::ProtoIO::readProtoFromTextFile(dict_file, &dict)) {\n    std::cerr << \"MapLayerDictionaryParser: failed to load from dictionary file!\" << std::endl;\n    std::cerr << \"dict_file: \" << dict_file << std::endl;\n    return false;\n  }\n\n  for (const auto& item : dict.items()) {\n    int layer_id = item.layer_id();\n    std::string type_name = item.type_name();\n    float grid_size = item.grid_size();\n    float tile_size = item.tile_size();\n\n    // compose the key\n    std::string key;\n    composeKey(type_name, grid_size, tile_size, &key);\n\n    // set unordered_map\n    id_to_key_[layer_id] = key;\n    key_to_id_[key] = layer_id;\n  }\n\n  return true;\n}\n\nbool MapLayerDictionaryParser::getInfoById(const int layer_id, std::string* type_name,\n                                           float* grid_size, float* tile_size) {\n  if (id_to_key_.count(layer_id) == 0) {\n    return false;\n  }\n\n  analyseKey(id_to_key_[layer_id], type_name, grid_size, tile_size);\n  return true;\n}\n\nbool MapLayerDictionaryParser::getIdByInfo(const std::string& type_name, const float& grid_size,\n                                           const float& tile_size, int* layer_id) {\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 0) {\n    return false;\n  }\n\n  *layer_id = key_to_id_[key];\n  return true;\n}\n\nfloat MapLayerDictionaryParser::getGridSize(const int layer_id) {\n  float grid_size;\n  if(!getInfoById(layer_id, nullptr, &grid_size, nullptr)){\n    return -1; // return a negtive value for invalid layer_id\n  }\n\n  return grid_size;\n}\n\nfloat MapLayerDictionaryParser::getTileSize(const int layer_id) {\n  float tile_size;\n  if(!getInfoById(layer_id, nullptr, nullptr, &tile_size)){\n    return -1; // return a negtive value for invalid layer_id\n  }\n\n  return tile_size;\n}\n\nstd::string MapLayerDictionaryParser::getTypeName(const int layer_id) {\n  std::string type_name;\n  if(!getInfoById(layer_id, &type_name, nullptr, nullptr)){\n    return \"\";\n  }\n  \n  return type_name;\n}\n\nbool MapLayerDictionaryParser::addItem(const int layer_id, const std::string& type_name,\n                                       const float grid_size, const float tile_size) {\n  if (id_to_key_.count(layer_id) == 1) {\n    std::cerr << \"failed to add item: layer_id \" << layer_id << \" has already exited in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 1) {\n    std::cerr << \"failed to add item: layer configuration has already existed in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  id_to_key_[layer_id] = key;\n  key_to_id_[key] = layer_id;\n  return true;\n}\n\nbool MapLayerDictionaryParser::save(const std::string& dict_file) {\n  // sort layer id\n  std::vector<int> layer_ids;\n  for (auto& pair : id_to_key_) {\n    layer_ids.emplace_back(pair.first);\n  }\n  std::sort(layer_ids.begin(), layer_ids.end());\n\n  // add item to dict\n  proto::config::MapLayerDictionary dict;\n  for (auto& id : layer_ids) {\n    // analyze key\n    std::string type_name;\n    float grid_size;\n    float tile_size;\n    analyseKey(id_to_key_[id], &type_name, &grid_size, &tile_size);\n\n    // add item\n    proto::config::MapLayerItem* item = dict.add_items();\n    item->set_layer_id(id);\n    item->set_type_name(type_name);\n    item->set_grid_size(grid_size);\n    item->set_tile_size(tile_size);\n  }\n\n  // write dict to file\n  return common::ProtoIO::writeProtoToTextFile(dict_file, dict);\n}\n\nvoid MapLayerDictionaryParser::composeKey(const std::string& type_name, const float& grid_size,\n                                          const float& tile_size, std::string* key) {\n  std::stringstream str_stream;\n  str_stream << type_name << \"_\" << static_cast<int>(grid_size * grid_size_ratio) << \"_\"\n             << static_cast<int>(tile_size);\n  *key = str_stream.str();\n}\n\nvoid MapLayerDictionaryParser::analyseKey(const std::string& key, std::string* type_name,\n                                          float* grid_size, float* tile_size) {\n  std::vector<std::string> substrs;\n  substrs.resize(3);\n\n  // achieve sub strings from key\n  size_t tail = key.size() - 1;\n  for (int i = 0; i < 2; i++) {\n    size_t pos = key.rfind('_', tail);\n    substrs[2 - i] = key.substr(pos + 1, tail - pos);\n    tail = pos - 1;\n  }\n  substrs[0] = key.substr(0, tail + 1);\n\n  // output\n  if (tile_size != nullptr) {\n    *tile_size = std::stof(substrs[2]);\n  }\n  if (grid_size != nullptr) {\n    *grid_size = std::stof(substrs[1]) / grid_size_ratio;\n  }\n  if (type_name != nullptr) {\n    *type_name = substrs[0];\n  }\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp"
		}
	}
]
I0403 13:42:04.656213 32175 json_parser.cpp:18] 
[
	36,
	{
		"bufnr" : 3,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All rights reserved.\n// Authors: Yongjian Zhao (yongjian.zhao@allride.ai)\n\n#include <fstream>\n#include <iostream>\n#include <sstream>\n#include <vector>\n\n#include \"common/io/proto_io.h\"\n#include \"common/proto/config/config_map.pb.h\"\n#include \"map_layer_dictionary_parser.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstatic const float grid_size_ratio = 1000.0f;  // convert from m to mm,\n\nbool MapLayerDictionaryParser::load(const std::string& dict_file) {\n  proto::config::MapLayerDictionary dict;\n  if (!common::ProtoIO::readProtoFromTextFile(dict_file, &dict)) {\n    std::cerr << \"MapLayerDictionaryParser: failed to load from dictionary file!\" << std::endl;\n    std::cerr << \"dict_file: \" << dict_file << std::endl;\n    return false;\n  }\n\n  for (const auto& item : dict.items()) {\n    int layer_id = item.layer_id();\n    std::string type_name = item.type_name();\n    float grid_size = item.grid_size();\n    float tile_size = item.tile_size();\n\n    // compose the key\n    std::string key;\n    composeKey(type_name, grid_size, tile_size, &key);\n\n    // set unordered_map\n    id_to_key_[layer_id] = key;\n    key_to_id_[key] = layer_id;\n  }\n\n  return true;\n}\n\nbool MapLayerDictionaryParser::getInfoById(const int layer_id, std::string* type_name,\n                                           float* grid_size, float* tile_size) {\n  if (id_to_key_.count(layer_id) == 0) {\n    return false;\n  }\n\n  analyseKey(id_to_key_[layer_id], type_name, grid_size, tile_size);\n  return true;\n}\n\nbool MapLayerDictionaryParser::getIdByInfo(const std::string& type_name, const float& grid_size,\n                                           const float& tile_size, int* layer_id) {\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 0) {\n    return false;\n  }\n\n  *layer_id = key_to_id_[key];\n  return true;\n}\n\nfloat MapLayerDictionaryParser::getGridSize(const int layer_id) {\n  float grid_size;\n  if(!getInfoById(layer_id, nullptr, &grid_size, nullptr)){\n    return -1; // return a negtive value for invalid layer_id\n  }\n\n  return grid_size;\n}\n\nfloat MapLayerDictionaryParser::getTileSize(const int layer_id) {\n  float tile_size;\n  if(!getInfoById(layer_id, nullptr, nullptr, &tile_size)){\n    return -1; // return a negtive value for invalid layer_id\n  }\n\n  return tile_size;\n}\n\nstd::string MapLayerDictionaryParser::getTypeName(const int layer_id) {\n  std::string type_name;\n  if(!getInfoById(layer_id, &type_name, nullptr, nullptr)){\n    return \"\";\n  }\n\n  return type_name;\n}\n\nbool MapLayerDictionaryParser::addItem(const int layer_id, const std::string& type_name,\n                                       const float grid_size, const float tile_size) {\n  if (id_to_key_.count(layer_id) == 1) {\n    std::cerr << \"failed to add item: layer_id \" << layer_id << \" has already exited in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 1) {\n    std::cerr << \"failed to add item: layer configuration has already existed in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  id_to_key_[layer_id] = key;\n  key_to_id_[key] = layer_id;\n  return true;\n}\n\nbool MapLayerDictionaryParser::save(const std::string& dict_file) {\n  // sort layer id\n  std::vector<int> layer_ids;\n  for (auto& pair : id_to_key_) {\n    layer_ids.emplace_back(pair.first);\n  }\n  std::sort(layer_ids.begin(), layer_ids.end());\n\n  // add item to dict\n  proto::config::MapLayerDictionary dict;\n  for (auto& id : layer_ids) {\n    // analyze key\n    std::string type_name;\n    float grid_size;\n    float tile_size;\n    analyseKey(id_to_key_[id], &type_name, &grid_size, &tile_size);\n\n    // add item\n    proto::config::MapLayerItem* item = dict.add_items();\n    item->set_layer_id(id);\n    item->set_type_name(type_name);\n    item->set_grid_size(grid_size);\n    item->set_tile_size(tile_size);\n  }\n\n  // write dict to file\n  return common::ProtoIO::writeProtoToTextFile(dict_file, dict);\n}\n\nvoid MapLayerDictionaryParser::composeKey(const std::string& type_name, const float& grid_size,\n                                          const float& tile_size, std::string* key) {\n  std::stringstream str_stream;\n  str_stream << type_name << \"_\" << static_cast<int>(grid_size * grid_size_ratio) << \"_\"\n             << static_cast<int>(tile_size);\n  *key = str_stream.str();\n}\n\nvoid MapLayerDictionaryParser::analyseKey(const std::string& key, std::string* type_name,\n                                          float* grid_size, float* tile_size) {\n  std::vector<std::string> substrs;\n  substrs.resize(3);\n\n  // achieve sub strings from key\n  size_t tail = key.size() - 1;\n  for (int i = 0; i < 2; i++) {\n    size_t pos = key.rfind('_', tail);\n    substrs[2 - i] = key.substr(pos + 1, tail - pos);\n    tail = pos - 1;\n  }\n  substrs[0] = key.substr(0, tail + 1);\n\n  // output\n  if (tile_size != nullptr) {\n    *tile_size = std::stof(substrs[2]);\n  }\n  if (grid_size != nullptr) {\n    *grid_size = std::stof(substrs[1]) / grid_size_ratio;\n  }\n  if (type_name != nullptr) {\n    *type_name = substrs[0];\n  }\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp"
		}
	}
]
I0403 13:42:09.309098 32175 json_parser.cpp:18] 
[
	37,
	{
		"bufnr" : 3,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All rights reserved.\n// Authors: Yongjian Zhao (yongjian.zhao@allride.ai)\n\n#include <fstream>\n#include <iostream>\n#include <sstream>\n#include <vector>\n\n#include \"common/io/proto_io.h\"\n#include \"common/proto/config/config_map.pb.h\"\n#include \"map_layer_dictionary_parser.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstatic const float grid_size_ratio = 1000.0f;  // convert from m to mm,\n\nbool MapLayerDictionaryParser::load(const std::string& dict_file) {\n  proto::config::MapLayerDictionary dict;\n  if (!common::ProtoIO::readProtoFromTextFile(dict_file, &dict)) {\n    std::cerr << \"MapLayerDictionaryParser: failed to load from dictionary file!\" << std::endl;\n    std::cerr << \"dict_file: \" << dict_file << std::endl;\n    return false;\n  }\n\n  for (const auto& item : dict.items()) {\n    int layer_id = item.layer_id();\n    std::string type_name = item.type_name();\n    float grid_size = item.grid_size();\n    float tile_size = item.tile_size();\n\n    // compose the key\n    std::string key;\n    composeKey(type_name, grid_size, tile_size, &key);\n\n    // set unordered_map\n    id_to_key_[layer_id] = key;\n    key_to_id_[key] = layer_id;\n  }\n\n  return true;\n}\n\nbool MapLayerDictionaryParser::getInfoById(const int layer_id, std::string* type_name,\n                                           float* grid_size, float* tile_size) {\n  if (id_to_key_.count(layer_id) == 0) {\n    return false;\n  }\n\n  analyseKey(id_to_key_[layer_id], type_name, grid_size, tile_size);\n  return true;\n}\n\nbool MapLayerDictionaryParser::getIdByInfo(const std::string& type_name, const float& grid_size,\n                                           const float& tile_size, int* layer_id) {\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 0) {\n    return false;\n  }\n\n  *layer_id = key_to_id_[key];\n  return true;\n}\n\nfloat MapLayerDictionaryParser::getGridSize(const int layer_id) {\n  float grid_size;\n  if(!getInfoById(layer_id, nullptr, &grid_size, nullptr)){\n    return -1; // return a negtive value for invalid layer_id\n  }\n\n  return grid_size;\n}\n\nfloat MapLayerDictionaryParser::getTileSize(const int layer_id) {\n  float tile_size;\n  if(!getInfoById(layer_id, nullptr, nullptr, &tile_size)){\n    return -1; // return a negtive value for invalid layer_id\n  }\n\n  return tile_size;\n}\n\nstd::string MapLayerDictionaryParser::getTypeName(const int layer_id) {\n  std::string type_name;\n  if(!getInfoById(layer_id, &type_name, nullptr, nullptr)){\n    return \";\n  }\n\n  return type_name;\n}\n\nbool MapLayerDictionaryParser::addItem(const int layer_id, const std::string& type_name,\n                                       const float grid_size, const float tile_size) {\n  if (id_to_key_.count(layer_id) == 1) {\n    std::cerr << \"failed to add item: layer_id \" << layer_id << \" has already exited in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 1) {\n    std::cerr << \"failed to add item: layer configuration has already existed in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  id_to_key_[layer_id] = key;\n  key_to_id_[key] = layer_id;\n  return true;\n}\n\nbool MapLayerDictionaryParser::save(const std::string& dict_file) {\n  // sort layer id\n  std::vector<int> layer_ids;\n  for (auto& pair : id_to_key_) {\n    layer_ids.emplace_back(pair.first);\n  }\n  std::sort(layer_ids.begin(), layer_ids.end());\n\n  // add item to dict\n  proto::config::MapLayerDictionary dict;\n  for (auto& id : layer_ids) {\n    // analyze key\n    std::string type_name;\n    float grid_size;\n    float tile_size;\n    analyseKey(id_to_key_[id], &type_name, &grid_size, &tile_size);\n\n    // add item\n    proto::config::MapLayerItem* item = dict.add_items();\n    item->set_layer_id(id);\n    item->set_type_name(type_name);\n    item->set_grid_size(grid_size);\n    item->set_tile_size(tile_size);\n  }\n\n  // write dict to file\n  return common::ProtoIO::writeProtoToTextFile(dict_file, dict);\n}\n\nvoid MapLayerDictionaryParser::composeKey(const std::string& type_name, const float& grid_size,\n                                          const float& tile_size, std::string* key) {\n  std::stringstream str_stream;\n  str_stream << type_name << \"_\" << static_cast<int>(grid_size * grid_size_ratio) << \"_\"\n             << static_cast<int>(tile_size);\n  *key = str_stream.str();\n}\n\nvoid MapLayerDictionaryParser::analyseKey(const std::string& key, std::string* type_name,\n                                          float* grid_size, float* tile_size) {\n  std::vector<std::string> substrs;\n  substrs.resize(3);\n\n  // achieve sub strings from key\n  size_t tail = key.size() - 1;\n  for (int i = 0; i < 2; i++) {\n    size_t pos = key.rfind('_', tail);\n    substrs[2 - i] = key.substr(pos + 1, tail - pos);\n    tail = pos - 1;\n  }\n  substrs[0] = key.substr(0, tail + 1);\n\n  // output\n  if (tile_size != nullptr) {\n    *tile_size = std::stof(substrs[2]);\n  }\n  if (grid_size != nullptr) {\n    *grid_size = std::stof(substrs[1]) / grid_size_ratio;\n  }\n  if (type_name != nullptr) {\n    *type_name = substrs[0];\n  }\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp"
		}
	}
]
I0403 13:42:09.452579 32175 json_parser.cpp:18] 
[
	38,
	{
		"bufnr" : 3,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All rights reserved.\n// Authors: Yongjian Zhao (yongjian.zhao@allride.ai)\n\n#include <fstream>\n#include <iostream>\n#include <sstream>\n#include <vector>\n\n#include \"common/io/proto_io.h\"\n#include \"common/proto/config/config_map.pb.h\"\n#include \"map_layer_dictionary_parser.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstatic const float grid_size_ratio = 1000.0f;  // convert from m to mm,\n\nbool MapLayerDictionaryParser::load(const std::string& dict_file) {\n  proto::config::MapLayerDictionary dict;\n  if (!common::ProtoIO::readProtoFromTextFile(dict_file, &dict)) {\n    std::cerr << \"MapLayerDictionaryParser: failed to load from dictionary file!\" << std::endl;\n    std::cerr << \"dict_file: \" << dict_file << std::endl;\n    return false;\n  }\n\n  for (const auto& item : dict.items()) {\n    int layer_id = item.layer_id();\n    std::string type_name = item.type_name();\n    float grid_size = item.grid_size();\n    float tile_size = item.tile_size();\n\n    // compose the key\n    std::string key;\n    composeKey(type_name, grid_size, tile_size, &key);\n\n    // set unordered_map\n    id_to_key_[layer_id] = key;\n    key_to_id_[key] = layer_id;\n  }\n\n  return true;\n}\n\nbool MapLayerDictionaryParser::getInfoById(const int layer_id, std::string* type_name,\n                                           float* grid_size, float* tile_size) {\n  if (id_to_key_.count(layer_id) == 0) {\n    return false;\n  }\n\n  analyseKey(id_to_key_[layer_id], type_name, grid_size, tile_size);\n  return true;\n}\n\nbool MapLayerDictionaryParser::getIdByInfo(const std::string& type_name, const float& grid_size,\n                                           const float& tile_size, int* layer_id) {\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 0) {\n    return false;\n  }\n\n  *layer_id = key_to_id_[key];\n  return true;\n}\n\nfloat MapLayerDictionaryParser::getGridSize(const int layer_id) {\n  float grid_size;\n  if(!getInfoById(layer_id, nullptr, &grid_size, nullptr)){\n    return -1; // return a negtive value for invalid layer_id\n  }\n\n  return grid_size;\n}\n\nfloat MapLayerDictionaryParser::getTileSize(const int layer_id) {\n  float tile_size;\n  if(!getInfoById(layer_id, nullptr, nullptr, &tile_size)){\n    return -1; // return a negtive value for invalid layer_id\n  }\n\n  return tile_size;\n}\n\nstd::string MapLayerDictionaryParser::getTypeName(const int layer_id) {\n  std::string type_name;\n  if(!getInfoById(layer_id, &type_name, nullptr, nullptr)){\n    return ;\n  }\n\n  return type_name;\n}\n\nbool MapLayerDictionaryParser::addItem(const int layer_id, const std::string& type_name,\n                                       const float grid_size, const float tile_size) {\n  if (id_to_key_.count(layer_id) == 1) {\n    std::cerr << \"failed to add item: layer_id \" << layer_id << \" has already exited in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 1) {\n    std::cerr << \"failed to add item: layer configuration has already existed in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  id_to_key_[layer_id] = key;\n  key_to_id_[key] = layer_id;\n  return true;\n}\n\nbool MapLayerDictionaryParser::save(const std::string& dict_file) {\n  // sort layer id\n  std::vector<int> layer_ids;\n  for (auto& pair : id_to_key_) {\n    layer_ids.emplace_back(pair.first);\n  }\n  std::sort(layer_ids.begin(), layer_ids.end());\n\n  // add item to dict\n  proto::config::MapLayerDictionary dict;\n  for (auto& id : layer_ids) {\n    // analyze key\n    std::string type_name;\n    float grid_size;\n    float tile_size;\n    analyseKey(id_to_key_[id], &type_name, &grid_size, &tile_size);\n\n    // add item\n    proto::config::MapLayerItem* item = dict.add_items();\n    item->set_layer_id(id);\n    item->set_type_name(type_name);\n    item->set_grid_size(grid_size);\n    item->set_tile_size(tile_size);\n  }\n\n  // write dict to file\n  return common::ProtoIO::writeProtoToTextFile(dict_file, dict);\n}\n\nvoid MapLayerDictionaryParser::composeKey(const std::string& type_name, const float& grid_size,\n                                          const float& tile_size, std::string* key) {\n  std::stringstream str_stream;\n  str_stream << type_name << \"_\" << static_cast<int>(grid_size * grid_size_ratio) << \"_\"\n             << static_cast<int>(tile_size);\n  *key = str_stream.str();\n}\n\nvoid MapLayerDictionaryParser::analyseKey(const std::string& key, std::string* type_name,\n                                          float* grid_size, float* tile_size) {\n  std::vector<std::string> substrs;\n  substrs.resize(3);\n\n  // achieve sub strings from key\n  size_t tail = key.size() - 1;\n  for (int i = 0; i < 2; i++) {\n    size_t pos = key.rfind('_', tail);\n    substrs[2 - i] = key.substr(pos + 1, tail - pos);\n    tail = pos - 1;\n  }\n  substrs[0] = key.substr(0, tail + 1);\n\n  // output\n  if (tile_size != nullptr) {\n    *tile_size = std::stof(substrs[2]);\n  }\n  if (grid_size != nullptr) {\n    *grid_size = std::stof(substrs[1]) / grid_size_ratio;\n  }\n  if (type_name != nullptr) {\n    *type_name = substrs[0];\n  }\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp"
		}
	}
]
I0403 13:42:09.575028 32175 json_parser.cpp:18] 
[
	39,
	{
		"bufnr" : 3,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All rights reserved.\n// Authors: Yongjian Zhao (yongjian.zhao@allride.ai)\n\n#include <fstream>\n#include <iostream>\n#include <sstream>\n#include <vector>\n\n#include \"common/io/proto_io.h\"\n#include \"common/proto/config/config_map.pb.h\"\n#include \"map_layer_dictionary_parser.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstatic const float grid_size_ratio = 1000.0f;  // convert from m to mm,\n\nbool MapLayerDictionaryParser::load(const std::string& dict_file) {\n  proto::config::MapLayerDictionary dict;\n  if (!common::ProtoIO::readProtoFromTextFile(dict_file, &dict)) {\n    std::cerr << \"MapLayerDictionaryParser: failed to load from dictionary file!\" << std::endl;\n    std::cerr << \"dict_file: \" << dict_file << std::endl;\n    return false;\n  }\n\n  for (const auto& item : dict.items()) {\n    int layer_id = item.layer_id();\n    std::string type_name = item.type_name();\n    float grid_size = item.grid_size();\n    float tile_size = item.tile_size();\n\n    // compose the key\n    std::string key;\n    composeKey(type_name, grid_size, tile_size, &key);\n\n    // set unordered_map\n    id_to_key_[layer_id] = key;\n    key_to_id_[key] = layer_id;\n  }\n\n  return true;\n}\n\nbool MapLayerDictionaryParser::getInfoById(const int layer_id, std::string* type_name,\n                                           float* grid_size, float* tile_size) {\n  if (id_to_key_.count(layer_id) == 0) {\n    return false;\n  }\n\n  analyseKey(id_to_key_[layer_id], type_name, grid_size, tile_size);\n  return true;\n}\n\nbool MapLayerDictionaryParser::getIdByInfo(const std::string& type_name, const float& grid_size,\n                                           const float& tile_size, int* layer_id) {\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 0) {\n    return false;\n  }\n\n  *layer_id = key_to_id_[key];\n  return true;\n}\n\nfloat MapLayerDictionaryParser::getGridSize(const int layer_id) {\n  float grid_size;\n  if(!getInfoById(layer_id, nullptr, &grid_size, nullptr)){\n    return -1; // return a negtive value for invalid layer_id\n  }\n\n  return grid_size;\n}\n\nfloat MapLayerDictionaryParser::getTileSize(const int layer_id) {\n  float tile_size;\n  if(!getInfoById(layer_id, nullptr, nullptr, &tile_size)){\n    return -1; // return a negtive value for invalid layer_id\n  }\n\n  return tile_size;\n}\n\nstd::string MapLayerDictionaryParser::getTypeName(const int layer_id) {\n  std::string type_name;\n  if(!getInfoById(layer_id, &type_name, nullptr, nullptr)){\n    return ;\n  }\n\n  return type_name;\n}\n\nbool MapLayerDictionaryParser::addItem(const int layer_id, const std::string& type_name,\n                                       const float grid_size, const float tile_size) {\n  if (id_to_key_.count(layer_id) == 1) {\n    std::cerr << \"failed to add item: layer_id \" << layer_id << \" has already exited in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 1) {\n    std::cerr << \"failed to add item: layer configuration has already existed in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  id_to_key_[layer_id] = key;\n  key_to_id_[key] = layer_id;\n  return true;\n}\n\nbool MapLayerDictionaryParser::save(const std::string& dict_file) {\n  // sort layer id\n  std::vector<int> layer_ids;\n  for (auto& pair : id_to_key_) {\n    layer_ids.emplace_back(pair.first);\n  }\n  std::sort(layer_ids.begin(), layer_ids.end());\n\n  // add item to dict\n  proto::config::MapLayerDictionary dict;\n  for (auto& id : layer_ids) {\n    // analyze key\n    std::string type_name;\n    float grid_size;\n    float tile_size;\n    analyseKey(id_to_key_[id], &type_name, &grid_size, &tile_size);\n\n    // add item\n    proto::config::MapLayerItem* item = dict.add_items();\n    item->set_layer_id(id);\n    item->set_type_name(type_name);\n    item->set_grid_size(grid_size);\n    item->set_tile_size(tile_size);\n  }\n\n  // write dict to file\n  return common::ProtoIO::writeProtoToTextFile(dict_file, dict);\n}\n\nvoid MapLayerDictionaryParser::composeKey(const std::string& type_name, const float& grid_size,\n                                          const float& tile_size, std::string* key) {\n  std::stringstream str_stream;\n  str_stream << type_name << \"_\" << static_cast<int>(grid_size * grid_size_ratio) << \"_\"\n             << static_cast<int>(tile_size);\n  *key = str_stream.str();\n}\n\nvoid MapLayerDictionaryParser::analyseKey(const std::string& key, std::string* type_name,\n                                          float* grid_size, float* tile_size) {\n  std::vector<std::string> substrs;\n  substrs.resize(3);\n\n  // achieve sub strings from key\n  size_t tail = key.size() - 1;\n  for (int i = 0; i < 2; i++) {\n    size_t pos = key.rfind('_', tail);\n    substrs[2 - i] = key.substr(pos + 1, tail - pos);\n    tail = pos - 1;\n  }\n  substrs[0] = key.substr(0, tail + 1);\n\n  // output\n  if (tile_size != nullptr) {\n    *tile_size = std::stof(substrs[2]);\n  }\n  if (grid_size != nullptr) {\n    *grid_size = std::stof(substrs[1]) / grid_size_ratio;\n  }\n  if (type_name != nullptr) {\n    *type_name = substrs[0];\n  }\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp"
		}
	}
]
I0403 13:42:12.951050 32175 json_parser.cpp:18] 
[
	40,
	{
		"bufnr" : 3,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All rights reserved.\n// Authors: Yongjian Zhao (yongjian.zhao@allride.ai)\n\n#include <fstream>\n#include <iostream>\n#include <sstream>\n#include <vector>\n\n#include \"common/io/proto_io.h\"\n#include \"common/proto/config/config_map.pb.h\"\n#include \"map_layer_dictionary_parser.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstatic const float grid_size_ratio = 1000.0f;  // convert from m to mm,\n\nbool MapLayerDictionaryParser::load(const std::string& dict_file) {\n  proto::config::MapLayerDictionary dict;\n  if (!common::ProtoIO::readProtoFromTextFile(dict_file, &dict)) {\n    std::cerr << \"MapLayerDictionaryParser: failed to load from dictionary file!\" << std::endl;\n    std::cerr << \"dict_file: \" << dict_file << std::endl;\n    return false;\n  }\n\n  for (const auto& item : dict.items()) {\n    int layer_id = item.layer_id();\n    std::string type_name = item.type_name();\n    float grid_size = item.grid_size();\n    float tile_size = item.tile_size();\n\n    // compose the key\n    std::string key;\n    composeKey(type_name, grid_size, tile_size, &key);\n\n    // set unordered_map\n    id_to_key_[layer_id] = key;\n    key_to_id_[key] = layer_id;\n  }\n\n  return true;\n}\n\nbool MapLayerDictionaryParser::getInfoById(const int layer_id, std::string* type_name,\n                                           float* grid_size, float* tile_size) {\n  if (id_to_key_.count(layer_id) == 0) {\n    return false;\n  }\n\n  analyseKey(id_to_key_[layer_id], type_name, grid_size, tile_size);\n  return true;\n}\n\nbool MapLayerDictionaryParser::getIdByInfo(const std::string& type_name, const float& grid_size,\n                                           const float& tile_size, int* layer_id) {\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 0) {\n    return false;\n  }\n\n  *layer_id = key_to_id_[key];\n  return true;\n}\n\nfloat MapLayerDictionaryParser::getGridSize(const int layer_id) {\n  float grid_size;\n  if(!getInfoById(layer_id, nullptr, &grid_size, nullptr)){\n    return -1; // return a negtive value for invalid layer_id\n  }\n\n  return grid_size;\n}\n\nfloat MapLayerDictionaryParser::getTileSize(const int layer_id) {\n  float tile_size;\n  if(!getInfoById(layer_id, nullptr, nullptr, &tile_size)){\n    return -1; // return a negtive value for invalid layer_id\n  }\n\n  return tile_size;\n}\n\nstd::string MapLayerDictionaryParser::getTypeName(const int layer_id) {\n  std::string type_name;\n  if(!getInfoById(layer_id, &type_name, nullptr, nullptr)){\n    return std::string();\n  }\n\n  return type_name;\n}\n\nbool MapLayerDictionaryParser::addItem(const int layer_id, const std::string& type_name,\n                                       const float grid_size, const float tile_size) {\n  if (id_to_key_.count(layer_id) == 1) {\n    std::cerr << \"failed to add item: layer_id \" << layer_id << \" has already exited in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 1) {\n    std::cerr << \"failed to add item: layer configuration has already existed in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  id_to_key_[layer_id] = key;\n  key_to_id_[key] = layer_id;\n  return true;\n}\n\nbool MapLayerDictionaryParser::save(const std::string& dict_file) {\n  // sort layer id\n  std::vector<int> layer_ids;\n  for (auto& pair : id_to_key_) {\n    layer_ids.emplace_back(pair.first);\n  }\n  std::sort(layer_ids.begin(), layer_ids.end());\n\n  // add item to dict\n  proto::config::MapLayerDictionary dict;\n  for (auto& id : layer_ids) {\n    // analyze key\n    std::string type_name;\n    float grid_size;\n    float tile_size;\n    analyseKey(id_to_key_[id], &type_name, &grid_size, &tile_size);\n\n    // add item\n    proto::config::MapLayerItem* item = dict.add_items();\n    item->set_layer_id(id);\n    item->set_type_name(type_name);\n    item->set_grid_size(grid_size);\n    item->set_tile_size(tile_size);\n  }\n\n  // write dict to file\n  return common::ProtoIO::writeProtoToTextFile(dict_file, dict);\n}\n\nvoid MapLayerDictionaryParser::composeKey(const std::string& type_name, const float& grid_size,\n                                          const float& tile_size, std::string* key) {\n  std::stringstream str_stream;\n  str_stream << type_name << \"_\" << static_cast<int>(grid_size * grid_size_ratio) << \"_\"\n             << static_cast<int>(tile_size);\n  *key = str_stream.str();\n}\n\nvoid MapLayerDictionaryParser::analyseKey(const std::string& key, std::string* type_name,\n                                          float* grid_size, float* tile_size) {\n  std::vector<std::string> substrs;\n  substrs.resize(3);\n\n  // achieve sub strings from key\n  size_t tail = key.size() - 1;\n  for (int i = 0; i < 2; i++) {\n    size_t pos = key.rfind('_', tail);\n    substrs[2 - i] = key.substr(pos + 1, tail - pos);\n    tail = pos - 1;\n  }\n  substrs[0] = key.substr(0, tail + 1);\n\n  // output\n  if (tile_size != nullptr) {\n    *tile_size = std::stof(substrs[2]);\n  }\n  if (grid_size != nullptr) {\n    *grid_size = std::stof(substrs[1]) / grid_size_ratio;\n  }\n  if (type_name != nullptr) {\n    *type_name = substrs[0];\n  }\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp"
		}
	}
]
I0403 13:42:13.071269 32175 json_parser.cpp:18] 
[
	41,
	{
		"bufnr" : 3,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All rights reserved.\n// Authors: Yongjian Zhao (yongjian.zhao@allride.ai)\n\n#include <fstream>\n#include <iostream>\n#include <sstream>\n#include <vector>\n\n#include \"common/io/proto_io.h\"\n#include \"common/proto/config/config_map.pb.h\"\n#include \"map_layer_dictionary_parser.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstatic const float grid_size_ratio = 1000.0f;  // convert from m to mm,\n\nbool MapLayerDictionaryParser::load(const std::string& dict_file) {\n  proto::config::MapLayerDictionary dict;\n  if (!common::ProtoIO::readProtoFromTextFile(dict_file, &dict)) {\n    std::cerr << \"MapLayerDictionaryParser: failed to load from dictionary file!\" << std::endl;\n    std::cerr << \"dict_file: \" << dict_file << std::endl;\n    return false;\n  }\n\n  for (const auto& item : dict.items()) {\n    int layer_id = item.layer_id();\n    std::string type_name = item.type_name();\n    float grid_size = item.grid_size();\n    float tile_size = item.tile_size();\n\n    // compose the key\n    std::string key;\n    composeKey(type_name, grid_size, tile_size, &key);\n\n    // set unordered_map\n    id_to_key_[layer_id] = key;\n    key_to_id_[key] = layer_id;\n  }\n\n  return true;\n}\n\nbool MapLayerDictionaryParser::getInfoById(const int layer_id, std::string* type_name,\n                                           float* grid_size, float* tile_size) {\n  if (id_to_key_.count(layer_id) == 0) {\n    return false;\n  }\n\n  analyseKey(id_to_key_[layer_id], type_name, grid_size, tile_size);\n  return true;\n}\n\nbool MapLayerDictionaryParser::getIdByInfo(const std::string& type_name, const float& grid_size,\n                                           const float& tile_size, int* layer_id) {\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 0) {\n    return false;\n  }\n\n  *layer_id = key_to_id_[key];\n  return true;\n}\n\nfloat MapLayerDictionaryParser::getGridSize(const int layer_id) {\n  float grid_size;\n  if(!getInfoById(layer_id, nullptr, &grid_size, nullptr)){\n    return -1; // return a negtive value for invalid layer_id\n  }\n\n  return grid_size;\n}\n\nfloat MapLayerDictionaryParser::getTileSize(const int layer_id) {\n  float tile_size;\n  if(!getInfoById(layer_id, nullptr, nullptr, &tile_size)){\n    return -1; // return a negtive value for invalid layer_id\n  }\n\n  return tile_size;\n}\n\nstd::string MapLayerDictionaryParser::getTypeName(const int layer_id) {\n  std::string type_name;\n  if(!getInfoById(layer_id, &type_name, nullptr, nullptr)){\n    return std::string();\n  }\n\n  return type_name;\n}\n\nbool MapLayerDictionaryParser::addItem(const int layer_id, const std::string& type_name,\n                                       const float grid_size, const float tile_size) {\n  if (id_to_key_.count(layer_id) == 1) {\n    std::cerr << \"failed to add item: layer_id \" << layer_id << \" has already exited in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 1) {\n    std::cerr << \"failed to add item: layer configuration has already existed in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  id_to_key_[layer_id] = key;\n  key_to_id_[key] = layer_id;\n  return true;\n}\n\nbool MapLayerDictionaryParser::save(const std::string& dict_file) {\n  // sort layer id\n  std::vector<int> layer_ids;\n  for (auto& pair : id_to_key_) {\n    layer_ids.emplace_back(pair.first);\n  }\n  std::sort(layer_ids.begin(), layer_ids.end());\n\n  // add item to dict\n  proto::config::MapLayerDictionary dict;\n  for (auto& id : layer_ids) {\n    // analyze key\n    std::string type_name;\n    float grid_size;\n    float tile_size;\n    analyseKey(id_to_key_[id], &type_name, &grid_size, &tile_size);\n\n    // add item\n    proto::config::MapLayerItem* item = dict.add_items();\n    item->set_layer_id(id);\n    item->set_type_name(type_name);\n    item->set_grid_size(grid_size);\n    item->set_tile_size(tile_size);\n  }\n\n  // write dict to file\n  return common::ProtoIO::writeProtoToTextFile(dict_file, dict);\n}\n\nvoid MapLayerDictionaryParser::composeKey(const std::string& type_name, const float& grid_size,\n                                          const float& tile_size, std::string* key) {\n  std::stringstream str_stream;\n  str_stream << type_name << \"_\" << static_cast<int>(grid_size * grid_size_ratio) << \"_\"\n             << static_cast<int>(tile_size);\n  *key = str_stream.str();\n}\n\nvoid MapLayerDictionaryParser::analyseKey(const std::string& key, std::string* type_name,\n                                          float* grid_size, float* tile_size) {\n  std::vector<std::string> substrs;\n  substrs.resize(3);\n\n  // achieve sub strings from key\n  size_t tail = key.size() - 1;\n  for (int i = 0; i < 2; i++) {\n    size_t pos = key.rfind('_', tail);\n    substrs[2 - i] = key.substr(pos + 1, tail - pos);\n    tail = pos - 1;\n  }\n  substrs[0] = key.substr(0, tail + 1);\n\n  // output\n  if (tile_size != nullptr) {\n    *tile_size = std::stof(substrs[2]);\n  }\n  if (grid_size != nullptr) {\n    *grid_size = std::stof(substrs[1]) / grid_size_ratio;\n  }\n  if (type_name != nullptr) {\n    *type_name = substrs[0];\n  }\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp"
		}
	}
]
I0403 13:42:13.823505 32175 json_parser.cpp:18] 
[
	42,
	{
		"bufnr" : 3,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All rights reserved.\n// Authors: Yongjian Zhao (yongjian.zhao@allride.ai)\n\n#include <fstream>\n#include <iostream>\n#include <sstream>\n#include <vector>\n\n#include \"common/io/proto_io.h\"\n#include \"common/proto/config/config_map.pb.h\"\n#include \"map_layer_dictionary_parser.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstatic const float grid_size_ratio = 1000.0f;  // convert from m to mm,\n\nbool MapLayerDictionaryParser::load(const std::string& dict_file) {\n  proto::config::MapLayerDictionary dict;\n  if (!common::ProtoIO::readProtoFromTextFile(dict_file, &dict)) {\n    std::cerr << \"MapLayerDictionaryParser: failed to load from dictionary file!\" << std::endl;\n    std::cerr << \"dict_file: \" << dict_file << std::endl;\n    return false;\n  }\n\n  for (const auto& item : dict.items()) {\n    int layer_id = item.layer_id();\n    std::string type_name = item.type_name();\n    float grid_size = item.grid_size();\n    float tile_size = item.tile_size();\n\n    // compose the key\n    std::string key;\n    composeKey(type_name, grid_size, tile_size, &key);\n\n    // set unordered_map\n    id_to_key_[layer_id] = key;\n    key_to_id_[key] = layer_id;\n  }\n\n  return true;\n}\n\nbool MapLayerDictionaryParser::getInfoById(const int layer_id, std::string* type_name,\n                                           float* grid_size, float* tile_size) {\n  if (id_to_key_.count(layer_id) == 0) {\n    return false;\n  }\n\n  analyseKey(id_to_key_[layer_id], type_name, grid_size, tile_size);\n  return true;\n}\n\nbool MapLayerDictionaryParser::getIdByInfo(const std::string& type_name, const float& grid_size,\n                                           const float& tile_size, int* layer_id) {\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 0) {\n    return false;\n  }\n\n  *layer_id = key_to_id_[key];\n  return true;\n}\n\nfloat MapLayerDictionaryParser::getGridSize(const int layer_id) {\n  float grid_size;\n  if(!getInfoById(layer_id, nullptr, &grid_size, nullptr)){\n    return -1; // return a negtive value for invalid layer_id\n  }\n\n  return grid_size;\n}\n\nfloat MapLayerDictionaryParser::getTileSize(const int layer_id) {\n  float tile_size;\n  if(!getInfoById(layer_id, nullptr, nullptr, &tile_size)){\n    return -1; // return a negtive value for invalid layer_id\n  }\n\n  return tile_size;\n}\n\nstd::string MapLayerDictionaryParser::getTypeName(const int layer_id) {\n  std::string type_name;\n  if(!getInfoById(layer_id, &type_name, nullptr, nullptr)){\n    return std::string(\"\");\n  }\n\n  return type_name;\n}\n\nbool MapLayerDictionaryParser::addItem(const int layer_id, const std::string& type_name,\n                                       const float grid_size, const float tile_size) {\n  if (id_to_key_.count(layer_id) == 1) {\n    std::cerr << \"failed to add item: layer_id \" << layer_id << \" has already exited in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 1) {\n    std::cerr << \"failed to add item: layer configuration has already existed in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  id_to_key_[layer_id] = key;\n  key_to_id_[key] = layer_id;\n  return true;\n}\n\nbool MapLayerDictionaryParser::save(const std::string& dict_file) {\n  // sort layer id\n  std::vector<int> layer_ids;\n  for (auto& pair : id_to_key_) {\n    layer_ids.emplace_back(pair.first);\n  }\n  std::sort(layer_ids.begin(), layer_ids.end());\n\n  // add item to dict\n  proto::config::MapLayerDictionary dict;\n  for (auto& id : layer_ids) {\n    // analyze key\n    std::string type_name;\n    float grid_size;\n    float tile_size;\n    analyseKey(id_to_key_[id], &type_name, &grid_size, &tile_size);\n\n    // add item\n    proto::config::MapLayerItem* item = dict.add_items();\n    item->set_layer_id(id);\n    item->set_type_name(type_name);\n    item->set_grid_size(grid_size);\n    item->set_tile_size(tile_size);\n  }\n\n  // write dict to file\n  return common::ProtoIO::writeProtoToTextFile(dict_file, dict);\n}\n\nvoid MapLayerDictionaryParser::composeKey(const std::string& type_name, const float& grid_size,\n                                          const float& tile_size, std::string* key) {\n  std::stringstream str_stream;\n  str_stream << type_name << \"_\" << static_cast<int>(grid_size * grid_size_ratio) << \"_\"\n             << static_cast<int>(tile_size);\n  *key = str_stream.str();\n}\n\nvoid MapLayerDictionaryParser::analyseKey(const std::string& key, std::string* type_name,\n                                          float* grid_size, float* tile_size) {\n  std::vector<std::string> substrs;\n  substrs.resize(3);\n\n  // achieve sub strings from key\n  size_t tail = key.size() - 1;\n  for (int i = 0; i < 2; i++) {\n    size_t pos = key.rfind('_', tail);\n    substrs[2 - i] = key.substr(pos + 1, tail - pos);\n    tail = pos - 1;\n  }\n  substrs[0] = key.substr(0, tail + 1);\n\n  // output\n  if (tile_size != nullptr) {\n    *tile_size = std::stof(substrs[2]);\n  }\n  if (grid_size != nullptr) {\n    *grid_size = std::stof(substrs[1]) / grid_size_ratio;\n  }\n  if (type_name != nullptr) {\n    *type_name = substrs[0];\n  }\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp"
		}
	}
]
I0403 13:42:16.495859 32175 json_parser.cpp:18] 
[
	43,
	{
		"bufnr" : 3,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All rights reserved.\n// Authors: Yongjian Zhao (yongjian.zhao@allride.ai)\n\n#include <fstream>\n#include <iostream>\n#include <sstream>\n#include <vector>\n\n#include \"common/io/proto_io.h\"\n#include \"common/proto/config/config_map.pb.h\"\n#include \"map_layer_dictionary_parser.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstatic const float grid_size_ratio = 1000.0f;  // convert from m to mm,\n\nbool MapLayerDictionaryParser::load(const std::string& dict_file) {\n  proto::config::MapLayerDictionary dict;\n  if (!common::ProtoIO::readProtoFromTextFile(dict_file, &dict)) {\n    std::cerr << \"MapLayerDictionaryParser: failed to load from dictionary file!\" << std::endl;\n    std::cerr << \"dict_file: \" << dict_file << std::endl;\n    return false;\n  }\n\n  for (const auto& item : dict.items()) {\n    int layer_id = item.layer_id();\n    std::string type_name = item.type_name();\n    float grid_size = item.grid_size();\n    float tile_size = item.tile_size();\n\n    // compose the key\n    std::string key;\n    composeKey(type_name, grid_size, tile_size, &key);\n\n    // set unordered_map\n    id_to_key_[layer_id] = key;\n    key_to_id_[key] = layer_id;\n  }\n\n  return true;\n}\n\nbool MapLayerDictionaryParser::getInfoById(const int layer_id, std::string* type_name,\n                                           float* grid_size, float* tile_size) {\n  if (id_to_key_.count(layer_id) == 0) {\n    return false;\n  }\n\n  analyseKey(id_to_key_[layer_id], type_name, grid_size, tile_size);\n  return true;\n}\n\nbool MapLayerDictionaryParser::getIdByInfo(const std::string& type_name, const float& grid_size,\n                                           const float& tile_size, int* layer_id) {\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 0) {\n    return false;\n  }\n\n  *layer_id = key_to_id_[key];\n  return true;\n}\n\nfloat MapLayerDictionaryParser::getGridSize(const int layer_id) {\n  float grid_size;\n  if(!getInfoById(layer_id, nullptr, &grid_size, nullptr)){\n    return -1; // return a negtive value for invalid layer_id\n  }\n\n  return grid_size;\n}\n\nfloat MapLayerDictionaryParser::getTileSize(const int layer_id) {\n  float tile_size;\n  if(!getInfoById(layer_id, nullptr, nullptr, &tile_size)){\n    return -1; // return a negtive value for invalid layer_id\n  }\n\n  return tile_size;\n}\n\nstd::string MapLayerDictionaryParser::getTypeName(const int layer_id) {\n  std::string type_name;\n  if(!getInfoById(layer_id, &type_name, nullptr, nullptr)){\n    return std::string(\"\");\n  }\n\n  return type_name;\n}\n\nbool MapLayerDictionaryParser::addItem(const int layer_id, const std::string& type_name,\n                                       const float grid_size, const float tile_size) {\n  if (id_to_key_.count(layer_id) == 1) {\n    std::cerr << \"failed to add item: layer_id \" << layer_id << \" has already exited in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 1) {\n    std::cerr << \"failed to add item: layer configuration has already existed in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  id_to_key_[layer_id] = key;\n  key_to_id_[key] = layer_id;\n  return true;\n}\n\nbool MapLayerDictionaryParser::save(const std::string& dict_file) {\n  // sort layer id\n  std::vector<int> layer_ids;\n  for (auto& pair : id_to_key_) {\n    layer_ids.emplace_back(pair.first);\n  }\n  std::sort(layer_ids.begin(), layer_ids.end());\n\n  // add item to dict\n  proto::config::MapLayerDictionary dict;\n  for (auto& id : layer_ids) {\n    // analyze key\n    std::string type_name;\n    float grid_size;\n    float tile_size;\n    analyseKey(id_to_key_[id], &type_name, &grid_size, &tile_size);\n\n    // add item\n    proto::config::MapLayerItem* item = dict.add_items();\n    item->set_layer_id(id);\n    item->set_type_name(type_name);\n    item->set_grid_size(grid_size);\n    item->set_tile_size(tile_size);\n  }\n\n  // write dict to file\n  return common::ProtoIO::writeProtoToTextFile(dict_file, dict);\n}\n\nvoid MapLayerDictionaryParser::composeKey(const std::string& type_name, const float& grid_size,\n                                          const float& tile_size, std::string* key) {\n  std::stringstream str_stream;\n  str_stream << type_name << \"_\" << static_cast<int>(grid_size * grid_size_ratio) << \"_\"\n             << static_cast<int>(tile_size);\n  *key = str_stream.str();\n}\n\nvoid MapLayerDictionaryParser::analyseKey(const std::string& key, std::string* type_name,\n                                          float* grid_size, float* tile_size) {\n  std::vector<std::string> substrs;\n  substrs.resize(3);\n\n  // achieve sub strings from key\n  size_t tail = key.size() - 1;\n  for (int i = 0; i < 2; i++) {\n    size_t pos = key.rfind('_', tail);\n    substrs[2 - i] = key.substr(pos + 1, tail - pos);\n    tail = pos - 1;\n  }\n  substrs[0] = key.substr(0, tail + 1);\n\n  // output\n  if (tile_size != nullptr) {\n    *tile_size = std::stof(substrs[2]);\n  }\n  if (grid_size != nullptr) {\n    *grid_size = std::stof(substrs[1]) / grid_size_ratio;\n  }\n  if (type_name != nullptr) {\n    *type_name = substrs[0];\n  }\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp"
		}
	}
]
I0403 13:42:30.085840 32175 json_parser.cpp:18] 
[
	44,
	{
		"bufnr" : 3,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All rights reserved.\n// Authors: Yongjian Zhao (yongjian.zhao@allride.ai)\n\n#include <fstream>\n#include <iostream>\n#include <sstream>\n#include <vector>\n\n#include \"common/io/proto_io.h\"\n#include \"common/proto/config/config_map.pb.h\"\n#include \"map_layer_dictionary_parser.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstatic const float grid_size_ratio = 1000.0f;  // convert from m to mm,\n\nbool MapLayerDictionaryParser::load(const std::string& dict_file) {\n  proto::config::MapLayerDictionary dict;\n  if (!common::ProtoIO::readProtoFromTextFile(dict_file, &dict)) {\n    std::cerr << \"MapLayerDictionaryParser: failed to load from dictionary file!\" << std::endl;\n    std::cerr << \"dict_file: \" << dict_file << std::endl;\n    return false;\n  }\n\n  for (const auto& item : dict.items()) {\n    int layer_id = item.layer_id();\n    std::string type_name = item.type_name();\n    float grid_size = item.grid_size();\n    float tile_size = item.tile_size();\n\n    // compose the key\n    std::string key;\n    composeKey(type_name, grid_size, tile_size, &key);\n\n    // set unordered_map\n    id_to_key_[layer_id] = key;\n    key_to_id_[key] = layer_id;\n  }\n\n  return true;\n}\n\nbool MapLayerDictionaryParser::getInfoById(const int layer_id, std::string* type_name,\n                                           float* grid_size, float* tile_size) {\n  if (id_to_key_.count(layer_id) == 0) {\n    return false;\n  }\n\n  analyseKey(id_to_key_[layer_id], type_name, grid_size, tile_size);\n  return true;\n}\n\nbool MapLayerDictionaryParser::getIdByInfo(const std::string& type_name, const float& grid_size,\n                                           const float& tile_size, int* layer_id) {\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 0) {\n    return false;\n  }\n\n  *layer_id = key_to_id_[key];\n  return true;\n}\n\nfloat MapLayerDictionaryParser::getGridSize(const int layer_id) {\n  float grid_size;\n  if(!getInfoById(layer_id, nullptr, &grid_size, nullptr)){\n    return -1; // return a negtive value for invalid layer_id\n  }\n\n  return grid_size;\n}\n\nfloat MapLayerDictionaryParser::getTileSize(const int layer_id) {\n  float tile_size;\n  if(!getInfoById(layer_id, nullptr, nullptr, &tile_size)){\n    return -1; // return a negtive value for invalid layer_id\n  }\n\n  return tile_size;\n}\n\nstd::string MapLayerDictionaryParser::getTypeName(const int layer_id) {\n  std::string type_name;\n  if(!getInfoById(layer_id, &type_name, nullptr, nullptr)){\n    return std::string(\"\"); // return an empty string for invalid layer_id\n  }\n\n  return type_name;\n}\n\nbool MapLayerDictionaryParser::addItem(const int layer_id, const std::string& type_name,\n                                       const float grid_size, const float tile_size) {\n  if (id_to_key_.count(layer_id) == 1) {\n    std::cerr << \"failed to add item: layer_id \" << layer_id << \" has already exited in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 1) {\n    std::cerr << \"failed to add item: layer configuration has already existed in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  id_to_key_[layer_id] = key;\n  key_to_id_[key] = layer_id;\n  return true;\n}\n\nbool MapLayerDictionaryParser::save(const std::string& dict_file) {\n  // sort layer id\n  std::vector<int> layer_ids;\n  for (auto& pair : id_to_key_) {\n    layer_ids.emplace_back(pair.first);\n  }\n  std::sort(layer_ids.begin(), layer_ids.end());\n\n  // add item to dict\n  proto::config::MapLayerDictionary dict;\n  for (auto& id : layer_ids) {\n    // analyze key\n    std::string type_name;\n    float grid_size;\n    float tile_size;\n    analyseKey(id_to_key_[id], &type_name, &grid_size, &tile_size);\n\n    // add item\n    proto::config::MapLayerItem* item = dict.add_items();\n    item->set_layer_id(id);\n    item->set_type_name(type_name);\n    item->set_grid_size(grid_size);\n    item->set_tile_size(tile_size);\n  }\n\n  // write dict to file\n  return common::ProtoIO::writeProtoToTextFile(dict_file, dict);\n}\n\nvoid MapLayerDictionaryParser::composeKey(const std::string& type_name, const float& grid_size,\n                                          const float& tile_size, std::string* key) {\n  std::stringstream str_stream;\n  str_stream << type_name << \"_\" << static_cast<int>(grid_size * grid_size_ratio) << \"_\"\n             << static_cast<int>(tile_size);\n  *key = str_stream.str();\n}\n\nvoid MapLayerDictionaryParser::analyseKey(const std::string& key, std::string* type_name,\n                                          float* grid_size, float* tile_size) {\n  std::vector<std::string> substrs;\n  substrs.resize(3);\n\n  // achieve sub strings from key\n  size_t tail = key.size() - 1;\n  for (int i = 0; i < 2; i++) {\n    size_t pos = key.rfind('_', tail);\n    substrs[2 - i] = key.substr(pos + 1, tail - pos);\n    tail = pos - 1;\n  }\n  substrs[0] = key.substr(0, tail + 1);\n\n  // output\n  if (tile_size != nullptr) {\n    *tile_size = std::stof(substrs[2]);\n  }\n  if (grid_size != nullptr) {\n    *grid_size = std::stof(substrs[1]) / grid_size_ratio;\n  }\n  if (type_name != nullptr) {\n    *type_name = substrs[0];\n  }\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp"
		}
	}
]
I0403 13:42:58.686339 32175 json_parser.cpp:18] 
[
	45,
	{
		"bufnr" : 3,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All rights reserved.\n// Authors: Yongjian Zhao (yongjian.zhao@allride.ai)\n\n#include <fstream>\n#include <iostream>\n#include <sstream>\n#include <vector>\n\n#include \"common/io/proto_io.h\"\n#include \"common/proto/config/config_map.pb.h\"\n#include \"map_layer_dictionary_parser.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstatic const float grid_size_ratio = 1000.0f;  // convert from m to mm,\n\nbool MapLayerDictionaryParser::load(const std::string& dict_file) {\n  proto::config::MapLayerDictionary dict;\n  if (!common::ProtoIO::readProtoFromTextFile(dict_file, &dict)) {\n    std::cerr << \"MapLayerDictionaryParser: failed to load from dictionary file!\" << std::endl;\n    std::cerr << \"dict_file: \" << dict_file << std::endl;\n    return false;\n  }\n\n  for (const auto& item : dict.items()) {\n    int layer_id = item.layer_id();\n    std::string type_name = item.type_name();\n    float grid_size = item.grid_size();\n    float tile_size = item.tile_size();\n\n    // compose the key\n    std::string key;\n    composeKey(type_name, grid_size, tile_size, &key);\n\n    // set unordered_map\n    id_to_key_[layer_id] = key;\n    key_to_id_[key] = layer_id;\n  }\n\n  return true;\n}\n\nbool MapLayerDictionaryParser::getInfoById(const int layer_id, std::string* type_name,\n                                           float* grid_size, float* tile_size) {\n  if (id_to_key_.count(layer_id) == 0) {\n    return false;\n  }\n\n  analyseKey(id_to_key_[layer_id], type_name, grid_size, tile_size);\n  return true;\n}\n\nbool MapLayerDictionaryParser::getIdByInfo(const std::string& type_name, const float& grid_size,\n                                           const float& tile_size, int* layer_id) {\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 0) {\n    return false;\n  }\n\n  *layer_id = key_to_id_[key];\n  return true;\n}\n\nfloat MapLayerDictionaryParser::getGridSize(const int layer_id) {\n  float grid_size;\n  if(!getInfoById(layer_id, nullptr, &grid_size, nullptr)){\n    return -1; // return a negtive value for invalid layer_id\n  }\n\n  return grid_size;\n}\n\nfloat MapLayerDictionaryParser::getTileSize(const int layer_id) {\n  float tile_size;\n  if(!getInfoById(layer_id, nullptr, nullptr, &tile_size)){\n    return -1; // return a negtive value for invalid layer_id\n  }\n\n  return tile_size;\n}\n\nstd::string MapLayerDictionaryParser::getTypeName(const int layer_id) {\n  std::string type_name;\n  if(!getInfoById(layer_id, &type_name, nullptr, nullptr)){\n    return std::string(\"\"); // return an empty string for invalid layer_id\n  }\n\n  return type_name;\n}\n\nbool MapLayerDictionaryParser::addItem(const int layer_id, const std::string& type_name,\n                                       const float grid_size, const float tile_size) {\n  if (id_to_key_.count(layer_id) == 1) {\n    std::cerr << \"failed to add item: layer_id \" << layer_id << \" has already exited in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 1) {\n    std::cerr << \"failed to add item: layer configuration has already existed in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  id_to_key_[layer_id] = key;\n  key_to_id_[key] = layer_id;\n  return true;\n}\n\nbool MapLayerDictionaryParser::save(const std::string& dict_file) {\n  // sort layer id\n  std::vector<int> layer_ids;\n  for (auto& pair : id_to_key_) {\n    layer_ids.emplace_back(pair.first);\n  }\n  std::sort(layer_ids.begin(), layer_ids.end());\n\n  // add item to dict\n  proto::config::MapLayerDictionary dict;\n  for (auto& id : layer_ids) {\n    // analyze key\n    std::string type_name;\n    float grid_size;\n    float tile_size;\n    analyseKey(id_to_key_[id], &type_name, &grid_size, &tile_size);\n\n    // add item\n    proto::config::MapLayerItem* item = dict.add_items();\n    item->set_layer_id(id);\n    item->set_type_name(type_name);\n    item->set_grid_size(grid_size);\n    item->set_tile_size(tile_size);\n  }\n\n  // write dict to file\n  return common::ProtoIO::writeProtoToTextFile(dict_file, dict);\n}\n\nvoid MapLayerDictionaryParser::composeKey(const std::string& type_name, const float& grid_size,\n                                          const float& tile_size, std::string* key) {\n  std::stringstream str_stream;\n  str_stream << type_name << \"_\" << static_cast<int>(grid_size * grid_size_ratio) << \"_\"\n             << static_cast<int>(tile_size);\n  *key = str_stream.str();\n}\n\nvoid MapLayerDictionaryParser::analyseKey(const std::string& key, std::string* type_name,\n                                          float* grid_size, float* tile_size) {\n  std::vector<std::string> substrs;\n  substrs.resize(3);\n\n  // achieve sub strings from key\n  size_t tail = key.size() - 1;\n  for (int i = 0; i < 2; i++) {\n    size_t pos = key.rfind('_', tail);\n    substrs[2 - i] = key.substr(pos + 1, tail - pos);\n    tail = pos - 1;\n  }\n  substrs[0] = key.substr(0, tail + 1);\n\n  // output\n  if (tile_size != nullptr) {\n    *tile_size = std::stof(substrs[2]);\n  }\n  if (grid_size != nullptr) {\n    *grid_size = std::stof(substrs[1]) / grid_size_ratio;\n  }\n  if (type_name != nullptr) {\n    *type_name = substrs[0];\n  }\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp"
		}
	}
]
I0403 13:43:24.749302 32175 json_parser.cpp:18] 
[
	46,
	{
		"bufnr" : 3,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All rights reserved.\n// Authors: Yongjian Zhao (yongjian.zhao@allride.ai)\n\n#include <fstream>\n#include <iostream>\n#include <sstream>\n#include <vector>\n\n#include \"common/io/proto_io.h\"\n#include \"common/proto/config/config_map.pb.h\"\n#include \"map_layer_dictionary_parser.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstatic const float grid_size_ratio = 1000.0f;  // convert from m to mm,\n\nbool MapLayerDictionaryParser::load(const std::string& dict_file) {\n  proto::config::MapLayerDictionary dict;\n  if (!common::ProtoIO::readProtoFromTextFile(dict_file, &dict)) {\n    std::cerr << \"MapLayerDictionaryParser: failed to load from dictionary file!\" << std::endl;\n    std::cerr << \"dict_file: \" << dict_file << std::endl;\n    return false;\n  }\n\n  for (const auto& item : dict.items()) {\n    int layer_id = item.layer_id();\n    std::string type_name = item.type_name();\n    float grid_size = item.grid_size();\n    float tile_size = item.tile_size();\n\n    // compose the key\n    std::string key;\n    composeKey(type_name, grid_size, tile_size, &key);\n\n    // set unordered_map\n    id_to_key_[layer_id] = key;\n    key_to_id_[key] = layer_id;\n  }\n\n  return true;\n}\n\nbool MapLayerDictionaryParser::getInfoById(const int layer_id, std::string* type_name,\n                                           float* grid_size, float* tile_size) {\n  if (id_to_key_.count(layer_id) == 0) {\n    return false;\n  }\n\n  analyseKey(id_to_key_[layer_id], type_name, grid_size, tile_size);\n  return true;\n}\n\nbool MapLayerDictionaryParser::getIdByInfo(const std::string& type_name, const float& grid_size,\n                                           const float& tile_size, int* layer_id) {\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 0) {\n    return false;\n  }\n\n  *layer_id = key_to_id_[key];\n  return true;\n}\n\nfloat MapLayerDictionaryParser::getGridSize(const int layer_id) {\n  float grid_size;\n  if(!getInfoById(layer_id, nullptr, &grid_size, nullptr)){\n    return -1; // return a negtive value for invalid layer_id\n  }\n\n  return grid_size;\n}\n\nfloat MapLayerDictionaryParser::getTileSize(const int layer_id) {\n  float tile_size;\n  if(!getInfoById(layer_id, nullptr, nullptr, &tile_size)){\n    return -1; // return a negtive value for invalid layer_id\n  }\n\n  return tile_size;\n}\n\nstd::string MapLayerDictionaryParser::getTypeName(const int layer_id) {\n  std::string type_name;\n  if(!getInfoById(layer_id, &type_name, nullptr, nullptr)){\n    return std::string(\"\"); // return an empty string for invalid layer_id\n  }\n\n  return type_name;\n}\n\nbool MapLayerDictionaryParser::addItem(const int layer_id, const std::string& type_name,\n                                       const float grid_size, const float tile_size) {\n  if (id_to_key_.count(layer_id) == 1) {\n    std::cerr << \"failed to add item: layer_id \" << layer_id << \" has already exited in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 1) {\n    std::cerr << \"failed to add item: layer configuration has already existed in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  id_to_key_[layer_id] = key;\n  key_to_id_[key] = layer_id;\n  return true;\n}\n\nbool MapLayerDictionaryParser::save(const std::string& dict_file) {\n  // sort layer id\n  std::vector<int> layer_ids;\n  for (auto& pair : id_to_key_) {\n    layer_ids.emplace_back(pair.first);\n  }\n  std::sort(layer_ids.begin(), layer_ids.end());\n\n  // add item to dict\n  proto::config::MapLayerDictionary dict;\n  for (auto& id : layer_ids) {\n    // analyze key\n    std::string type_name;\n    float grid_size;\n    float tile_size;\n    analyseKey(id_to_key_[id], &type_name, &grid_size, &tile_size);\n\n    // add item\n    proto::config::MapLayerItem* item = dict.add_items();\n    item->set_layer_id(id);\n    item->set_type_name(type_name);\n    item->set_grid_size(grid_size);\n    item->set_tile_size(tile_size);\n  }\n\n  // write dict to file\n  return common::ProtoIO::writeProtoToTextFile(dict_file, dict);\n}\n\nvoid MapLayerDictionaryParser::composeKey(const std::string& type_name, const float& grid_size,\n                                          const float& tile_size, std::string* key) {\n  std::stringstream str_stream;\n  str_stream << type_name << \"_\" << static_cast<int>(grid_size * grid_size_ratio) << \"_\"\n             << static_cast<int>(tile_size);\n  *key = str_stream.str();\n}\n\nvoid MapLayerDictionaryParser::analyseKey(const std::string& key, std::string* type_name,\n                                          float* grid_size, float* tile_size) {\n  std::vector<std::string> substrs;\n  substrs.resize(3);\n\n  // achieve sub strings from key\n  size_t tail = key.size() - 1;\n  for (int i = 0; i < 2; i++) {\n    size_t pos = key.rfind('_', tail);\n    substrs[2 - i] = key.substr(pos + 1, tail - pos);\n    tail = pos - 1;\n  }\n  substrs[0] = key.substr(0, tail + 1);\n\n  // output\n  if (tile_size != nullptr) {\n    *tile_size = std::stof(substrs[2]);\n  }\n  if (grid_size != nullptr) {\n    *grid_size = std::stof(substrs[1]) / grid_size_ratio;\n  }\n  if (type_name != nullptr) {\n    *type_name = substrs[0];\n  }\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp"
		}
	}
]
I0403 13:43:24.786656 32175 json_parser.cpp:18] 
[
	47,
	{
		"bufnr" : 14,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_online.h\"\n\nnamespace allride {\nnamespace mapping {\n\nvoid LidarMapOnline::setMapOrigin(const common::geometry::SE3& Tx_MP_map) { origin_ = Tx_MP_map; }\n\ncommon::geometry::SE3 LidarMapOnline::getMapOrigin() { return origin_; }\n\nvoid LidarMapOnline::resetMapRegion(const common::geometry::SE3& Tx_MP_V, double radius) {\n  common::geometry::SE3 Tx_delta /* = origin_.inverseCompose(Tx_MP_V) */;  // waiting for api\n\n  // first get all keys\n  std::vector<int> all_layer_ids;\n  for (const auto& pair : ndt3_pool_) {\n    all_layer_ids.emplace_back(pair.first);\n  }\n\n  // update ndt3 data of all layers\n  for (const auto& layer_id : all_layer_ids) {\n    std::shared_ptr<Ndt3Tile> new_ndt3 =\n        std::shared_ptr<Ndt3Tile>(new Ndt3Tile(map_layer_dict_.getGridSize(layer_id)));\n    ndt3_pool_[layer_id]->copyAndTransform(Tx_delta, radius, new_ndt3.get());\n    ndt3_pool_[layer_id] = new_ndt3;\n  }\n}\n\nbool LidarMapOnline::initializeLayer(int layer_id) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it != ndt3_pool_.end()) {\n    return false;  // re-initialize\n  }\n\n  float grid_size;\n  if (!map_layer_dict_.getInfoById(layer_id, nullptr, &grid_size, nullptr)) {\n    return false;\n  }\n\n  ndt3_pool_[layer_id] = std::shared_ptr<Ndt3Tile>(new Ndt3Tile(grid_size));\n\n  return true;\n}\n\nbool LidarMapOnline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  // add sample to ndt3\n  for (const auto& sample : pointcloud) {\n    ndt3_pool_it->second->addSample(sample);\n  }\n\n  return false;\n}\n\nbool LidarMapOnline::getMap(int layer_id, std::shared_ptr<Ndt3Interface>* ndt3) {\n  if (!ndt3) {\n    return false;\n  }\n\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  *ndt3 = ndt3_pool_it->second;\n  return true;\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp"
		}
	}
]
I0403 13:44:19.751442 32175 json_parser.cpp:18] 
[
	48,
	{
		"bufnr" : 14,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_online.h\"\n\nnamespace allride {\nnamespace mapping {\n\nvoid LidarMapOnline::setMapOrigin(const common::geometry::SE3& Tx_MP_map) { origin_ = Tx_MP_map; }\n\ncommon::geometry::SE3 LidarMapOnline::getMapOrigin() { return origin_; }\n\nvoid LidarMapOnline::resetMapRegion(const common::geometry::SE3& Tx_MP_V, double radius) {\n  common::geometry::SE3 Tx_delta /* = origin_.inverseCompose(Tx_MP_V) */;  // waiting for api\n\n  // first get all keys\n  std::vector<int> all_layer_ids;\n  for (const auto& pair : ndt3_pool_) {\n    all_layer_ids.emplace_back(pair.first);\n  }\n\n  // update ndt3 data of all layers\n  for (const auto& layer_id : all_layer_ids) {\n    \n    std::shared_ptr<Ndt3Tile> new_ndt3 =\n        std::shared_ptr<Ndt3Tile>(new Ndt3Tile(map_layer_dict_.getGridSize(layer_id)));\n    ndt3_pool_[layer_id]->copyAndTransform(Tx_delta, radius, new_ndt3.get());\n    ndt3_pool_[layer_id] = new_ndt3;\n  }\n}\n\nbool LidarMapOnline::initializeLayer(int layer_id) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it != ndt3_pool_.end()) {\n    return false;  // re-initialize\n  }\n\n  float grid_size;\n  if (!map_layer_dict_.getInfoById(layer_id, nullptr, &grid_size, nullptr)) {\n    return false;\n  }\n\n  ndt3_pool_[layer_id] = std::shared_ptr<Ndt3Tile>(new Ndt3Tile(grid_size));\n\n  return true;\n}\n\nbool LidarMapOnline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  // add sample to ndt3\n  for (const auto& sample : pointcloud) {\n    ndt3_pool_it->second->addSample(sample);\n  }\n\n  return false;\n}\n\nbool LidarMapOnline::getMap(int layer_id, std::shared_ptr<Ndt3Interface>* ndt3) {\n  if (!ndt3) {\n    return false;\n  }\n\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  *ndt3 = ndt3_pool_it->second;\n  return true;\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp"
		}
	}
]
I0403 13:44:34.229394 32175 json_parser.cpp:18] 
[
	49,
	{
		"bufnr" : 14,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_online.h\"\n\nnamespace allride {\nnamespace mapping {\n\nvoid LidarMapOnline::setMapOrigin(const common::geometry::SE3& Tx_MP_map) { origin_ = Tx_MP_map; }\n\ncommon::geometry::SE3 LidarMapOnline::getMapOrigin() { return origin_; }\n\nvoid LidarMapOnline::resetMapRegion(const common::geometry::SE3& Tx_MP_V, double radius) {\n  common::geometry::SE3 Tx_delta /* = origin_.inverseCompose(Tx_MP_V) */;  // waiting for api\n\n  // first get all keys\n  std::vector<int> all_layer_ids;\n  for (const auto& pair : ndt3_pool_) {\n    all_layer_ids.emplace_back(pair.first);\n  }\n\n  // update ndt3 data of all layers\n  for (const auto& layer_id : all_layer_ids) {\n    float grid_size = \n    std::shared_ptr<Ndt3Tile> new_ndt3 =\n        std::shared_ptr<Ndt3Tile>(new Ndt3Tile(map_layer_dict_.getGridSize(layer_id)));\n    ndt3_pool_[layer_id]->copyAndTransform(Tx_delta, radius, new_ndt3.get());\n    ndt3_pool_[layer_id] = new_ndt3;\n  }\n}\n\nbool LidarMapOnline::initializeLayer(int layer_id) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it != ndt3_pool_.end()) {\n    return false;  // re-initialize\n  }\n\n  float grid_size;\n  if (!map_layer_dict_.getInfoById(layer_id, nullptr, &grid_size, nullptr)) {\n    return false;\n  }\n\n  ndt3_pool_[layer_id] = std::shared_ptr<Ndt3Tile>(new Ndt3Tile(grid_size));\n\n  return true;\n}\n\nbool LidarMapOnline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  // add sample to ndt3\n  for (const auto& sample : pointcloud) {\n    ndt3_pool_it->second->addSample(sample);\n  }\n\n  return false;\n}\n\nbool LidarMapOnline::getMap(int layer_id, std::shared_ptr<Ndt3Interface>* ndt3) {\n  if (!ndt3) {\n    return false;\n  }\n\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  *ndt3 = ndt3_pool_it->second;\n  return true;\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp"
		}
	}
]
I0403 13:44:43.633846 32175 json_parser.cpp:18] 
[
	50,
	{
		"bufnr" : 14,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_online.h\"\n\nnamespace allride {\nnamespace mapping {\n\nvoid LidarMapOnline::setMapOrigin(const common::geometry::SE3& Tx_MP_map) { origin_ = Tx_MP_map; }\n\ncommon::geometry::SE3 LidarMapOnline::getMapOrigin() { return origin_; }\n\nvoid LidarMapOnline::resetMapRegion(const common::geometry::SE3& Tx_MP_V, double radius) {\n  common::geometry::SE3 Tx_delta /* = origin_.inverseCompose(Tx_MP_V) */;  // waiting for api\n\n  // first get all keys\n  std::vector<int> all_layer_ids;\n  for (const auto& pair : ndt3_pool_) {\n    all_layer_ids.emplace_back(pair.first);\n  }\n\n  // update ndt3 data of all layers\n  for (const auto& layer_id : all_layer_ids) {\n    float grid_size = map_layer_dict_.getGridSize(layer_id)\n    std::shared_ptr<Ndt3Tile> new_ndt3 =\n        std::shared_ptr<Ndt3Tile>(new Ndt3Tile(map_layer_dict_.getGridSize(layer_id)));\n    ndt3_pool_[layer_id]->copyAndTransform(Tx_delta, radius, new_ndt3.get());\n    ndt3_pool_[layer_id] = new_ndt3;\n  }\n}\n\nbool LidarMapOnline::initializeLayer(int layer_id) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it != ndt3_pool_.end()) {\n    return false;  // re-initialize\n  }\n\n  float grid_size;\n  if (!map_layer_dict_.getInfoById(layer_id, nullptr, &grid_size, nullptr)) {\n    return false;\n  }\n\n  ndt3_pool_[layer_id] = std::shared_ptr<Ndt3Tile>(new Ndt3Tile(grid_size));\n\n  return true;\n}\n\nbool LidarMapOnline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  // add sample to ndt3\n  for (const auto& sample : pointcloud) {\n    ndt3_pool_it->second->addSample(sample);\n  }\n\n  return false;\n}\n\nbool LidarMapOnline::getMap(int layer_id, std::shared_ptr<Ndt3Interface>* ndt3) {\n  if (!ndt3) {\n    return false;\n  }\n\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  *ndt3 = ndt3_pool_it->second;\n  return true;\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp"
		}
	}
]
I0403 13:44:45.013520 32175 json_parser.cpp:18] 
[
	51,
	{
		"bufnr" : 14,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_online.h\"\n\nnamespace allride {\nnamespace mapping {\n\nvoid LidarMapOnline::setMapOrigin(const common::geometry::SE3& Tx_MP_map) { origin_ = Tx_MP_map; }\n\ncommon::geometry::SE3 LidarMapOnline::getMapOrigin() { return origin_; }\n\nvoid LidarMapOnline::resetMapRegion(const common::geometry::SE3& Tx_MP_V, double radius) {\n  common::geometry::SE3 Tx_delta /* = origin_.inverseCompose(Tx_MP_V) */;  // waiting for api\n\n  // first get all keys\n  std::vector<int> all_layer_ids;\n  for (const auto& pair : ndt3_pool_) {\n    all_layer_ids.emplace_back(pair.first);\n  }\n\n  // update ndt3 data of all layers\n  for (const auto& layer_id : all_layer_ids) {\n    float grid_size = map_layer_dict_.getGridSize(layer_id)\n    std::shared_ptr<Ndt3Tile> new_ndt3 =\n        std::shared_ptr<Ndt3Tile>(new Ndt3Tile(map_layer_dict_.getGridSize(layer_id)));\n    ndt3_pool_[layer_id]->copyAndTransform(Tx_delta, radius, new_ndt3.get());\n    ndt3_pool_[layer_id] = new_ndt3;\n  }\n}\n\nbool LidarMapOnline::initializeLayer(int layer_id) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it != ndt3_pool_.end()) {\n    return false;  // re-initialize\n  }\n\n  float grid_size;\n  if (!map_layer_dict_.getInfoById(layer_id, nullptr, &grid_size, nullptr)) {\n    return false;\n  }\n\n  ndt3_pool_[layer_id] = std::shared_ptr<Ndt3Tile>(new Ndt3Tile(grid_size));\n\n  return true;\n}\n\nbool LidarMapOnline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  // add sample to ndt3\n  for (const auto& sample : pointcloud) {\n    ndt3_pool_it->second->addSample(sample);\n  }\n\n  return false;\n}\n\nbool LidarMapOnline::getMap(int layer_id, std::shared_ptr<Ndt3Interface>* ndt3) {\n  if (!ndt3) {\n    return false;\n  }\n\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  *ndt3 = ndt3_pool_it->second;\n  return true;\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp"
		}
	}
]
I0403 13:44:45.357775 32175 json_parser.cpp:18] 
[
	52,
	{
		"bufnr" : 14,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_online.h\"\n\nnamespace allride {\nnamespace mapping {\n\nvoid LidarMapOnline::setMapOrigin(const common::geometry::SE3& Tx_MP_map) { origin_ = Tx_MP_map; }\n\ncommon::geometry::SE3 LidarMapOnline::getMapOrigin() { return origin_; }\n\nvoid LidarMapOnline::resetMapRegion(const common::geometry::SE3& Tx_MP_V, double radius) {\n  common::geometry::SE3 Tx_delta /* = origin_.inverseCompose(Tx_MP_V) */;  // waiting for api\n\n  // first get all keys\n  std::vector<int> all_layer_ids;\n  for (const auto& pair : ndt3_pool_) {\n    all_layer_ids.emplace_back(pair.first);\n  }\n\n  // update ndt3 data of all layers\n  for (const auto& layer_id : all_layer_ids) {\n    float grid_size = map_layer_dict_.getGridSize(layer_id);\n    std::shared_ptr<Ndt3Tile> new_ndt3 =\n        std::shared_ptr<Ndt3Tile>(new Ndt3Tile(map_layer_dict_.getGridSize(layer_id)));\n    ndt3_pool_[layer_id]->copyAndTransform(Tx_delta, radius, new_ndt3.get());\n    ndt3_pool_[layer_id] = new_ndt3;\n  }\n}\n\nbool LidarMapOnline::initializeLayer(int layer_id) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it != ndt3_pool_.end()) {\n    return false;  // re-initialize\n  }\n\n  float grid_size;\n  if (!map_layer_dict_.getInfoById(layer_id, nullptr, &grid_size, nullptr)) {\n    return false;\n  }\n\n  ndt3_pool_[layer_id] = std::shared_ptr<Ndt3Tile>(new Ndt3Tile(grid_size));\n\n  return true;\n}\n\nbool LidarMapOnline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  // add sample to ndt3\n  for (const auto& sample : pointcloud) {\n    ndt3_pool_it->second->addSample(sample);\n  }\n\n  return false;\n}\n\nbool LidarMapOnline::getMap(int layer_id, std::shared_ptr<Ndt3Interface>* ndt3) {\n  if (!ndt3) {\n    return false;\n  }\n\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  *ndt3 = ndt3_pool_it->second;\n  return true;\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp"
		}
	}
]
I0403 13:44:58.629842 32175 json_parser.cpp:18] 
[
	53,
	{
		"bufnr" : 14,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_online.h\"\n\nnamespace allride {\nnamespace mapping {\n\nvoid LidarMapOnline::setMapOrigin(const common::geometry::SE3& Tx_MP_map) { origin_ = Tx_MP_map; }\n\ncommon::geometry::SE3 LidarMapOnline::getMapOrigin() { return origin_; }\n\nvoid LidarMapOnline::resetMapRegion(const common::geometry::SE3& Tx_MP_V, double radius) {\n  common::geometry::SE3 Tx_delta /* = origin_.inverseCompose(Tx_MP_V) */;  // waiting for api\n\n  // first get all keys\n  std::vector<int> all_layer_ids;\n  for (const auto& pair : ndt3_pool_) {\n    all_layer_ids.emplace_back(pair.first);\n  }\n\n  // update ndt3 data of all layers\n  for (const auto& layer_id : all_layer_ids) {\n    float grid_size = map_layer_dict_.getGridSize(layer_id);\n    \n    std::shared_ptr<Ndt3Tile> new_ndt3 =\n        std::shared_ptr<Ndt3Tile>(new Ndt3Tile(map_layer_dict_.getGridSize(layer_id)));\n    ndt3_pool_[layer_id]->copyAndTransform(Tx_delta, radius, new_ndt3.get());\n    ndt3_pool_[layer_id] = new_ndt3;\n  }\n}\n\nbool LidarMapOnline::initializeLayer(int layer_id) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it != ndt3_pool_.end()) {\n    return false;  // re-initialize\n  }\n\n  float grid_size;\n  if (!map_layer_dict_.getInfoById(layer_id, nullptr, &grid_size, nullptr)) {\n    return false;\n  }\n\n  ndt3_pool_[layer_id] = std::shared_ptr<Ndt3Tile>(new Ndt3Tile(grid_size));\n\n  return true;\n}\n\nbool LidarMapOnline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  // add sample to ndt3\n  for (const auto& sample : pointcloud) {\n    ndt3_pool_it->second->addSample(sample);\n  }\n\n  return false;\n}\n\nbool LidarMapOnline::getMap(int layer_id, std::shared_ptr<Ndt3Interface>* ndt3) {\n  if (!ndt3) {\n    return false;\n  }\n\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  *ndt3 = ndt3_pool_it->second;\n  return true;\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp"
		}
	}
]
I0403 13:45:00.099581 32175 json_parser.cpp:18] 
[
	54,
	{
		"bufnr" : 14,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_online.h\"\n\nnamespace allride {\nnamespace mapping {\n\nvoid LidarMapOnline::setMapOrigin(const common::geometry::SE3& Tx_MP_map) { origin_ = Tx_MP_map; }\n\ncommon::geometry::SE3 LidarMapOnline::getMapOrigin() { return origin_; }\n\nvoid LidarMapOnline::resetMapRegion(const common::geometry::SE3& Tx_MP_V, double radius) {\n  common::geometry::SE3 Tx_delta /* = origin_.inverseCompose(Tx_MP_V) */;  // waiting for api\n\n  // first get all keys\n  std::vector<int> all_layer_ids;\n  for (const auto& pair : ndt3_pool_) {\n    all_layer_ids.emplace_back(pair.first);\n  }\n\n  // update ndt3 data of all layers\n  for (const auto& layer_id : all_layer_ids) {\n    float grid_size = map_layer_dict_.getGridSize(layer_id);\n    if()\n    std::shared_ptr<Ndt3Tile> new_ndt3 =\n        std::shared_ptr<Ndt3Tile>(new Ndt3Tile(map_layer_dict_.getGridSize(layer_id)));\n    ndt3_pool_[layer_id]->copyAndTransform(Tx_delta, radius, new_ndt3.get());\n    ndt3_pool_[layer_id] = new_ndt3;\n  }\n}\n\nbool LidarMapOnline::initializeLayer(int layer_id) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it != ndt3_pool_.end()) {\n    return false;  // re-initialize\n  }\n\n  float grid_size;\n  if (!map_layer_dict_.getInfoById(layer_id, nullptr, &grid_size, nullptr)) {\n    return false;\n  }\n\n  ndt3_pool_[layer_id] = std::shared_ptr<Ndt3Tile>(new Ndt3Tile(grid_size));\n\n  return true;\n}\n\nbool LidarMapOnline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  // add sample to ndt3\n  for (const auto& sample : pointcloud) {\n    ndt3_pool_it->second->addSample(sample);\n  }\n\n  return false;\n}\n\nbool LidarMapOnline::getMap(int layer_id, std::shared_ptr<Ndt3Interface>* ndt3) {\n  if (!ndt3) {\n    return false;\n  }\n\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  *ndt3 = ndt3_pool_it->second;\n  return true;\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp"
		}
	}
]
I0403 13:45:00.260303 32175 json_parser.cpp:18] 
[
	55,
	{
		"bufnr" : 14,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_online.h\"\n\nnamespace allride {\nnamespace mapping {\n\nvoid LidarMapOnline::setMapOrigin(const common::geometry::SE3& Tx_MP_map) { origin_ = Tx_MP_map; }\n\ncommon::geometry::SE3 LidarMapOnline::getMapOrigin() { return origin_; }\n\nvoid LidarMapOnline::resetMapRegion(const common::geometry::SE3& Tx_MP_V, double radius) {\n  common::geometry::SE3 Tx_delta /* = origin_.inverseCompose(Tx_MP_V) */;  // waiting for api\n\n  // first get all keys\n  std::vector<int> all_layer_ids;\n  for (const auto& pair : ndt3_pool_) {\n    all_layer_ids.emplace_back(pair.first);\n  }\n\n  // update ndt3 data of all layers\n  for (const auto& layer_id : all_layer_ids) {\n    float grid_size = map_layer_dict_.getGridSize(layer_id);\n    if()\n    std::shared_ptr<Ndt3Tile> new_ndt3 =\n        std::shared_ptr<Ndt3Tile>(new Ndt3Tile(map_layer_dict_.getGridSize(layer_id)));\n    ndt3_pool_[layer_id]->copyAndTransform(Tx_delta, radius, new_ndt3.get());\n    ndt3_pool_[layer_id] = new_ndt3;\n  }\n}\n\nbool LidarMapOnline::initializeLayer(int layer_id) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it != ndt3_pool_.end()) {\n    return false;  // re-initialize\n  }\n\n  float grid_size;\n  if (!map_layer_dict_.getInfoById(layer_id, nullptr, &grid_size, nullptr)) {\n    return false;\n  }\n\n  ndt3_pool_[layer_id] = std::shared_ptr<Ndt3Tile>(new Ndt3Tile(grid_size));\n\n  return true;\n}\n\nbool LidarMapOnline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  // add sample to ndt3\n  for (const auto& sample : pointcloud) {\n    ndt3_pool_it->second->addSample(sample);\n  }\n\n  return false;\n}\n\nbool LidarMapOnline::getMap(int layer_id, std::shared_ptr<Ndt3Interface>* ndt3) {\n  if (!ndt3) {\n    return false;\n  }\n\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  *ndt3 = ndt3_pool_it->second;\n  return true;\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp"
		}
	}
]
I0403 13:45:03.747928 32175 json_parser.cpp:18] 
[
	56,
	{
		"bufnr" : 14,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_online.h\"\n\nnamespace allride {\nnamespace mapping {\n\nvoid LidarMapOnline::setMapOrigin(const common::geometry::SE3& Tx_MP_map) { origin_ = Tx_MP_map; }\n\ncommon::geometry::SE3 LidarMapOnline::getMapOrigin() { return origin_; }\n\nvoid LidarMapOnline::resetMapRegion(const common::geometry::SE3& Tx_MP_V, double radius) {\n  common::geometry::SE3 Tx_delta /* = origin_.inverseCompose(Tx_MP_V) */;  // waiting for api\n\n  // first get all keys\n  std::vector<int> all_layer_ids;\n  for (const auto& pair : ndt3_pool_) {\n    all_layer_ids.emplace_back(pair.first);\n  }\n\n  // update ndt3 data of all layers\n  for (const auto& layer_id : all_layer_ids) {\n    float grid_size = map_layer_dict_.getGridSize(layer_id);\n    if(grid_size<0)\n    std::shared_ptr<Ndt3Tile> new_ndt3 =\n        std::shared_ptr<Ndt3Tile>(new Ndt3Tile(map_layer_dict_.getGridSize(layer_id)));\n    ndt3_pool_[layer_id]->copyAndTransform(Tx_delta, radius, new_ndt3.get());\n    ndt3_pool_[layer_id] = new_ndt3;\n  }\n}\n\nbool LidarMapOnline::initializeLayer(int layer_id) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it != ndt3_pool_.end()) {\n    return false;  // re-initialize\n  }\n\n  float grid_size;\n  if (!map_layer_dict_.getInfoById(layer_id, nullptr, &grid_size, nullptr)) {\n    return false;\n  }\n\n  ndt3_pool_[layer_id] = std::shared_ptr<Ndt3Tile>(new Ndt3Tile(grid_size));\n\n  return true;\n}\n\nbool LidarMapOnline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  // add sample to ndt3\n  for (const auto& sample : pointcloud) {\n    ndt3_pool_it->second->addSample(sample);\n  }\n\n  return false;\n}\n\nbool LidarMapOnline::getMap(int layer_id, std::shared_ptr<Ndt3Interface>* ndt3) {\n  if (!ndt3) {\n    return false;\n  }\n\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  *ndt3 = ndt3_pool_it->second;\n  return true;\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp"
		}
	}
]
I0403 13:45:04.092262 32175 json_parser.cpp:18] 
[
	57,
	{
		"bufnr" : 14,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_online.h\"\n\nnamespace allride {\nnamespace mapping {\n\nvoid LidarMapOnline::setMapOrigin(const common::geometry::SE3& Tx_MP_map) { origin_ = Tx_MP_map; }\n\ncommon::geometry::SE3 LidarMapOnline::getMapOrigin() { return origin_; }\n\nvoid LidarMapOnline::resetMapRegion(const common::geometry::SE3& Tx_MP_V, double radius) {\n  common::geometry::SE3 Tx_delta /* = origin_.inverseCompose(Tx_MP_V) */;  // waiting for api\n\n  // first get all keys\n  std::vector<int> all_layer_ids;\n  for (const auto& pair : ndt3_pool_) {\n    all_layer_ids.emplace_back(pair.first);\n  }\n\n  // update ndt3 data of all layers\n  for (const auto& layer_id : all_layer_ids) {\n    float grid_size = map_layer_dict_.getGridSize(layer_id);\n    if(grid_size<0)\n    std::shared_ptr<Ndt3Tile> new_ndt3 =\n        std::shared_ptr<Ndt3Tile>(new Ndt3Tile(map_layer_dict_.getGridSize(layer_id)));\n    ndt3_pool_[layer_id]->copyAndTransform(Tx_delta, radius, new_ndt3.get());\n    ndt3_pool_[layer_id] = new_ndt3;\n  }\n}\n\nbool LidarMapOnline::initializeLayer(int layer_id) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it != ndt3_pool_.end()) {\n    return false;  // re-initialize\n  }\n\n  float grid_size;\n  if (!map_layer_dict_.getInfoById(layer_id, nullptr, &grid_size, nullptr)) {\n    return false;\n  }\n\n  ndt3_pool_[layer_id] = std::shared_ptr<Ndt3Tile>(new Ndt3Tile(grid_size));\n\n  return true;\n}\n\nbool LidarMapOnline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  // add sample to ndt3\n  for (const auto& sample : pointcloud) {\n    ndt3_pool_it->second->addSample(sample);\n  }\n\n  return false;\n}\n\nbool LidarMapOnline::getMap(int layer_id, std::shared_ptr<Ndt3Interface>* ndt3) {\n  if (!ndt3) {\n    return false;\n  }\n\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  *ndt3 = ndt3_pool_it->second;\n  return true;\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp"
		}
	}
]
I0403 13:45:04.963618 32175 json_parser.cpp:18] 
[
	58,
	{
		"bufnr" : 14,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_online.h\"\n\nnamespace allride {\nnamespace mapping {\n\nvoid LidarMapOnline::setMapOrigin(const common::geometry::SE3& Tx_MP_map) { origin_ = Tx_MP_map; }\n\ncommon::geometry::SE3 LidarMapOnline::getMapOrigin() { return origin_; }\n\nvoid LidarMapOnline::resetMapRegion(const common::geometry::SE3& Tx_MP_V, double radius) {\n  common::geometry::SE3 Tx_delta /* = origin_.inverseCompose(Tx_MP_V) */;  // waiting for api\n\n  // first get all keys\n  std::vector<int> all_layer_ids;\n  for (const auto& pair : ndt3_pool_) {\n    all_layer_ids.emplace_back(pair.first);\n  }\n\n  // update ndt3 data of all layers\n  for (const auto& layer_id : all_layer_ids) {\n    float grid_size = map_layer_dict_.getGridSize(layer_id);\n    if(grid_size<0){\n    }\n    std::shared_ptr<Ndt3Tile> new_ndt3 =\n        std::shared_ptr<Ndt3Tile>(new Ndt3Tile(map_layer_dict_.getGridSize(layer_id)));\n    ndt3_pool_[layer_id]->copyAndTransform(Tx_delta, radius, new_ndt3.get());\n    ndt3_pool_[layer_id] = new_ndt3;\n  }\n}\n\nbool LidarMapOnline::initializeLayer(int layer_id) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it != ndt3_pool_.end()) {\n    return false;  // re-initialize\n  }\n\n  float grid_size;\n  if (!map_layer_dict_.getInfoById(layer_id, nullptr, &grid_size, nullptr)) {\n    return false;\n  }\n\n  ndt3_pool_[layer_id] = std::shared_ptr<Ndt3Tile>(new Ndt3Tile(grid_size));\n\n  return true;\n}\n\nbool LidarMapOnline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  // add sample to ndt3\n  for (const auto& sample : pointcloud) {\n    ndt3_pool_it->second->addSample(sample);\n  }\n\n  return false;\n}\n\nbool LidarMapOnline::getMap(int layer_id, std::shared_ptr<Ndt3Interface>* ndt3) {\n  if (!ndt3) {\n    return false;\n  }\n\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  *ndt3 = ndt3_pool_it->second;\n  return true;\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp"
		}
	}
]
I0403 13:45:08.522011 32175 json_parser.cpp:18] 
[
	59,
	{
		"bufnr" : 14,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_online.h\"\n\nnamespace allride {\nnamespace mapping {\n\nvoid LidarMapOnline::setMapOrigin(const common::geometry::SE3& Tx_MP_map) { origin_ = Tx_MP_map; }\n\ncommon::geometry::SE3 LidarMapOnline::getMapOrigin() { return origin_; }\n\nvoid LidarMapOnline::resetMapRegion(const common::geometry::SE3& Tx_MP_V, double radius) {\n  common::geometry::SE3 Tx_delta /* = origin_.inverseCompose(Tx_MP_V) */;  // waiting for api\n\n  // first get all keys\n  std::vector<int> all_layer_ids;\n  for (const auto& pair : ndt3_pool_) {\n    all_layer_ids.emplace_back(pair.first);\n  }\n\n  // update ndt3 data of all layers\n  for (const auto& layer_id : all_layer_ids) {\n    float grid_size = map_layer_dict_.getGridSize(layer_id);\n    if(grid_size<0){\n      return;\n    }\n    std::shared_ptr<Ndt3Tile> new_ndt3 =\n        std::shared_ptr<Ndt3Tile>(new Ndt3Tile(map_layer_dict_.getGridSize(layer_id)));\n    ndt3_pool_[layer_id]->copyAndTransform(Tx_delta, radius, new_ndt3.get());\n    ndt3_pool_[layer_id] = new_ndt3;\n  }\n}\n\nbool LidarMapOnline::initializeLayer(int layer_id) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it != ndt3_pool_.end()) {\n    return false;  // re-initialize\n  }\n\n  float grid_size;\n  if (!map_layer_dict_.getInfoById(layer_id, nullptr, &grid_size, nullptr)) {\n    return false;\n  }\n\n  ndt3_pool_[layer_id] = std::shared_ptr<Ndt3Tile>(new Ndt3Tile(grid_size));\n\n  return true;\n}\n\nbool LidarMapOnline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  // add sample to ndt3\n  for (const auto& sample : pointcloud) {\n    ndt3_pool_it->second->addSample(sample);\n  }\n\n  return false;\n}\n\nbool LidarMapOnline::getMap(int layer_id, std::shared_ptr<Ndt3Interface>* ndt3) {\n  if (!ndt3) {\n    return false;\n  }\n\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  *ndt3 = ndt3_pool_it->second;\n  return true;\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp"
		}
	}
]
I0403 13:45:10.676048 32175 json_parser.cpp:18] 
[
	60,
	{
		"bufnr" : 14,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_online.h\"\n\nnamespace allride {\nnamespace mapping {\n\nvoid LidarMapOnline::setMapOrigin(const common::geometry::SE3& Tx_MP_map) { origin_ = Tx_MP_map; }\n\ncommon::geometry::SE3 LidarMapOnline::getMapOrigin() { return origin_; }\n\nvoid LidarMapOnline::resetMapRegion(const common::geometry::SE3& Tx_MP_V, double radius) {\n  common::geometry::SE3 Tx_delta /* = origin_.inverseCompose(Tx_MP_V) */;  // waiting for api\n\n  // first get all keys\n  std::vector<int> all_layer_ids;\n  for (const auto& pair : ndt3_pool_) {\n    all_layer_ids.emplace_back(pair.first);\n  }\n\n  // update ndt3 data of all layers\n  for (const auto& layer_id : all_layer_ids) {\n    float grid_size = map_layer_dict_.getGridSize(layer_id);\n    if(grid_size<0){\n      \n      return;\n    }\n    std::shared_ptr<Ndt3Tile> new_ndt3 =\n        std::shared_ptr<Ndt3Tile>(new Ndt3Tile(map_layer_dict_.getGridSize(layer_id)));\n    ndt3_pool_[layer_id]->copyAndTransform(Tx_delta, radius, new_ndt3.get());\n    ndt3_pool_[layer_id] = new_ndt3;\n  }\n}\n\nbool LidarMapOnline::initializeLayer(int layer_id) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it != ndt3_pool_.end()) {\n    return false;  // re-initialize\n  }\n\n  float grid_size;\n  if (!map_layer_dict_.getInfoById(layer_id, nullptr, &grid_size, nullptr)) {\n    return false;\n  }\n\n  ndt3_pool_[layer_id] = std::shared_ptr<Ndt3Tile>(new Ndt3Tile(grid_size));\n\n  return true;\n}\n\nbool LidarMapOnline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  // add sample to ndt3\n  for (const auto& sample : pointcloud) {\n    ndt3_pool_it->second->addSample(sample);\n  }\n\n  return false;\n}\n\nbool LidarMapOnline::getMap(int layer_id, std::shared_ptr<Ndt3Interface>* ndt3) {\n  if (!ndt3) {\n    return false;\n  }\n\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  *ndt3 = ndt3_pool_it->second;\n  return true;\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp"
		}
	}
]
I0403 13:45:15.195101 32175 json_parser.cpp:18] 
[
	61,
	{
		"bufnr" : 14,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_online.h\"\n\nnamespace allride {\nnamespace mapping {\n\nvoid LidarMapOnline::setMapOrigin(const common::geometry::SE3& Tx_MP_map) { origin_ = Tx_MP_map; }\n\ncommon::geometry::SE3 LidarMapOnline::getMapOrigin() { return origin_; }\n\nvoid LidarMapOnline::resetMapRegion(const common::geometry::SE3& Tx_MP_V, double radius) {\n  common::geometry::SE3 Tx_delta /* = origin_.inverseCompose(Tx_MP_V) */;  // waiting for api\n\n  // first get all keys\n  std::vector<int> all_layer_ids;\n  for (const auto& pair : ndt3_pool_) {\n    all_layer_ids.emplace_back(pair.first);\n  }\n\n  // update ndt3 data of all layers\n  for (const auto& layer_id : all_layer_ids) {\n    float grid_size = map_layer_dict_.getGridSize(layer_id);\n    if(grid_size<0){\n      std::cout<<\"\"\n      return;\n    }\n    std::shared_ptr<Ndt3Tile> new_ndt3 =\n        std::shared_ptr<Ndt3Tile>(new Ndt3Tile(map_layer_dict_.getGridSize(layer_id)));\n    ndt3_pool_[layer_id]->copyAndTransform(Tx_delta, radius, new_ndt3.get());\n    ndt3_pool_[layer_id] = new_ndt3;\n  }\n}\n\nbool LidarMapOnline::initializeLayer(int layer_id) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it != ndt3_pool_.end()) {\n    return false;  // re-initialize\n  }\n\n  float grid_size;\n  if (!map_layer_dict_.getInfoById(layer_id, nullptr, &grid_size, nullptr)) {\n    return false;\n  }\n\n  ndt3_pool_[layer_id] = std::shared_ptr<Ndt3Tile>(new Ndt3Tile(grid_size));\n\n  return true;\n}\n\nbool LidarMapOnline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  // add sample to ndt3\n  for (const auto& sample : pointcloud) {\n    ndt3_pool_it->second->addSample(sample);\n  }\n\n  return false;\n}\n\nbool LidarMapOnline::getMap(int layer_id, std::shared_ptr<Ndt3Interface>* ndt3) {\n  if (!ndt3) {\n    return false;\n  }\n\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  *ndt3 = ndt3_pool_it->second;\n  return true;\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp"
		}
	}
]
I0403 13:45:15.322546 32175 json_parser.cpp:18] 
[
	62,
	{
		"bufnr" : 14,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_online.h\"\n\nnamespace allride {\nnamespace mapping {\n\nvoid LidarMapOnline::setMapOrigin(const common::geometry::SE3& Tx_MP_map) { origin_ = Tx_MP_map; }\n\ncommon::geometry::SE3 LidarMapOnline::getMapOrigin() { return origin_; }\n\nvoid LidarMapOnline::resetMapRegion(const common::geometry::SE3& Tx_MP_V, double radius) {\n  common::geometry::SE3 Tx_delta /* = origin_.inverseCompose(Tx_MP_V) */;  // waiting for api\n\n  // first get all keys\n  std::vector<int> all_layer_ids;\n  for (const auto& pair : ndt3_pool_) {\n    all_layer_ids.emplace_back(pair.first);\n  }\n\n  // update ndt3 data of all layers\n  for (const auto& layer_id : all_layer_ids) {\n    float grid_size = map_layer_dict_.getGridSize(layer_id);\n    if(grid_size<0){\n      std::cout<<\"\"\n      return;\n    }\n    std::shared_ptr<Ndt3Tile> new_ndt3 =\n        std::shared_ptr<Ndt3Tile>(new Ndt3Tile(map_layer_dict_.getGridSize(layer_id)));\n    ndt3_pool_[layer_id]->copyAndTransform(Tx_delta, radius, new_ndt3.get());\n    ndt3_pool_[layer_id] = new_ndt3;\n  }\n}\n\nbool LidarMapOnline::initializeLayer(int layer_id) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it != ndt3_pool_.end()) {\n    return false;  // re-initialize\n  }\n\n  float grid_size;\n  if (!map_layer_dict_.getInfoById(layer_id, nullptr, &grid_size, nullptr)) {\n    return false;\n  }\n\n  ndt3_pool_[layer_id] = std::shared_ptr<Ndt3Tile>(new Ndt3Tile(grid_size));\n\n  return true;\n}\n\nbool LidarMapOnline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  // add sample to ndt3\n  for (const auto& sample : pointcloud) {\n    ndt3_pool_it->second->addSample(sample);\n  }\n\n  return false;\n}\n\nbool LidarMapOnline::getMap(int layer_id, std::shared_ptr<Ndt3Interface>* ndt3) {\n  if (!ndt3) {\n    return false;\n  }\n\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  *ndt3 = ndt3_pool_it->second;\n  return true;\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp"
		}
	}
]
I0403 13:45:24.666041 32175 json_parser.cpp:18] 
[
	63,
	{
		"bufnr" : 14,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_online.h\"\n\nnamespace allride {\nnamespace mapping {\n\nvoid LidarMapOnline::setMapOrigin(const common::geometry::SE3& Tx_MP_map) { origin_ = Tx_MP_map; }\n\ncommon::geometry::SE3 LidarMapOnline::getMapOrigin() { return origin_; }\n\nvoid LidarMapOnline::resetMapRegion(const common::geometry::SE3& Tx_MP_V, double radius) {\n  common::geometry::SE3 Tx_delta /* = origin_.inverseCompose(Tx_MP_V) */;  // waiting for api\n\n  // first get all keys\n  std::vector<int> all_layer_ids;\n  for (const auto& pair : ndt3_pool_) {\n    all_layer_ids.emplace_back(pair.first);\n  }\n\n  // update ndt3 data of all layers\n  for (const auto& layer_id : all_layer_ids) {\n    float grid_size = map_layer_dict_.getGridSize(layer_id);\n    if(grid_size<0){\n      std::cout<<\"Grid size negtive\"\n      return;\n    }\n    std::shared_ptr<Ndt3Tile> new_ndt3 =\n        std::shared_ptr<Ndt3Tile>(new Ndt3Tile(map_layer_dict_.getGridSize(layer_id)));\n    ndt3_pool_[layer_id]->copyAndTransform(Tx_delta, radius, new_ndt3.get());\n    ndt3_pool_[layer_id] = new_ndt3;\n  }\n}\n\nbool LidarMapOnline::initializeLayer(int layer_id) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it != ndt3_pool_.end()) {\n    return false;  // re-initialize\n  }\n\n  float grid_size;\n  if (!map_layer_dict_.getInfoById(layer_id, nullptr, &grid_size, nullptr)) {\n    return false;\n  }\n\n  ndt3_pool_[layer_id] = std::shared_ptr<Ndt3Tile>(new Ndt3Tile(grid_size));\n\n  return true;\n}\n\nbool LidarMapOnline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  // add sample to ndt3\n  for (const auto& sample : pointcloud) {\n    ndt3_pool_it->second->addSample(sample);\n  }\n\n  return false;\n}\n\nbool LidarMapOnline::getMap(int layer_id, std::shared_ptr<Ndt3Interface>* ndt3) {\n  if (!ndt3) {\n    return false;\n  }\n\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  *ndt3 = ndt3_pool_it->second;\n  return true;\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp"
		}
	}
]
I0403 13:45:25.019449 32175 json_parser.cpp:18] 
[
	64,
	{
		"bufnr" : 14,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_online.h\"\n\nnamespace allride {\nnamespace mapping {\n\nvoid LidarMapOnline::setMapOrigin(const common::geometry::SE3& Tx_MP_map) { origin_ = Tx_MP_map; }\n\ncommon::geometry::SE3 LidarMapOnline::getMapOrigin() { return origin_; }\n\nvoid LidarMapOnline::resetMapRegion(const common::geometry::SE3& Tx_MP_V, double radius) {\n  common::geometry::SE3 Tx_delta /* = origin_.inverseCompose(Tx_MP_V) */;  // waiting for api\n\n  // first get all keys\n  std::vector<int> all_layer_ids;\n  for (const auto& pair : ndt3_pool_) {\n    all_layer_ids.emplace_back(pair.first);\n  }\n\n  // update ndt3 data of all layers\n  for (const auto& layer_id : all_layer_ids) {\n    float grid_size = map_layer_dict_.getGridSize(layer_id);\n    if(grid_size<0){\n      std::cout<<\"Grid size negtive\"\n      return;\n    }\n    std::shared_ptr<Ndt3Tile> new_ndt3 =\n        std::shared_ptr<Ndt3Tile>(new Ndt3Tile(map_layer_dict_.getGridSize(layer_id)));\n    ndt3_pool_[layer_id]->copyAndTransform(Tx_delta, radius, new_ndt3.get());\n    ndt3_pool_[layer_id] = new_ndt3;\n  }\n}\n\nbool LidarMapOnline::initializeLayer(int layer_id) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it != ndt3_pool_.end()) {\n    return false;  // re-initialize\n  }\n\n  float grid_size;\n  if (!map_layer_dict_.getInfoById(layer_id, nullptr, &grid_size, nullptr)) {\n    return false;\n  }\n\n  ndt3_pool_[layer_id] = std::shared_ptr<Ndt3Tile>(new Ndt3Tile(grid_size));\n\n  return true;\n}\n\nbool LidarMapOnline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  // add sample to ndt3\n  for (const auto& sample : pointcloud) {\n    ndt3_pool_it->second->addSample(sample);\n  }\n\n  return false;\n}\n\nbool LidarMapOnline::getMap(int layer_id, std::shared_ptr<Ndt3Interface>* ndt3) {\n  if (!ndt3) {\n    return false;\n  }\n\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  *ndt3 = ndt3_pool_it->second;\n  return true;\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp"
		}
	}
]
I0403 13:45:26.612048 32175 json_parser.cpp:18] 
[
	65,
	{
		"bufnr" : 14,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_online.h\"\n\nnamespace allride {\nnamespace mapping {\n\nvoid LidarMapOnline::setMapOrigin(const common::geometry::SE3& Tx_MP_map) { origin_ = Tx_MP_map; }\n\ncommon::geometry::SE3 LidarMapOnline::getMapOrigin() { return origin_; }\n\nvoid LidarMapOnline::resetMapRegion(const common::geometry::SE3& Tx_MP_V, double radius) {\n  common::geometry::SE3 Tx_delta /* = origin_.inverseCompose(Tx_MP_V) */;  // waiting for api\n\n  // first get all keys\n  std::vector<int> all_layer_ids;\n  for (const auto& pair : ndt3_pool_) {\n    all_layer_ids.emplace_back(pair.first);\n  }\n\n  // update ndt3 data of all layers\n  for (const auto& layer_id : all_layer_ids) {\n    float grid_size = map_layer_dict_.getGridSize(layer_id);\n    if(grid_size<0){\n      std::cout<<\"Grid size negtive\"<<endl;\n      return;\n    }\n    std::shared_ptr<Ndt3Tile> new_ndt3 =\n        std::shared_ptr<Ndt3Tile>(new Ndt3Tile(map_layer_dict_.getGridSize(layer_id)));\n    ndt3_pool_[layer_id]->copyAndTransform(Tx_delta, radius, new_ndt3.get());\n    ndt3_pool_[layer_id] = new_ndt3;\n  }\n}\n\nbool LidarMapOnline::initializeLayer(int layer_id) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it != ndt3_pool_.end()) {\n    return false;  // re-initialize\n  }\n\n  float grid_size;\n  if (!map_layer_dict_.getInfoById(layer_id, nullptr, &grid_size, nullptr)) {\n    return false;\n  }\n\n  ndt3_pool_[layer_id] = std::shared_ptr<Ndt3Tile>(new Ndt3Tile(grid_size));\n\n  return true;\n}\n\nbool LidarMapOnline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  // add sample to ndt3\n  for (const auto& sample : pointcloud) {\n    ndt3_pool_it->second->addSample(sample);\n  }\n\n  return false;\n}\n\nbool LidarMapOnline::getMap(int layer_id, std::shared_ptr<Ndt3Interface>* ndt3) {\n  if (!ndt3) {\n    return false;\n  }\n\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  *ndt3 = ndt3_pool_it->second;\n  return true;\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp"
		}
	}
]
I0403 13:45:27.499322 32175 json_parser.cpp:18] 
[
	66,
	{
		"bufnr" : 14,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_online.h\"\n\nnamespace allride {\nnamespace mapping {\n\nvoid LidarMapOnline::setMapOrigin(const common::geometry::SE3& Tx_MP_map) { origin_ = Tx_MP_map; }\n\ncommon::geometry::SE3 LidarMapOnline::getMapOrigin() { return origin_; }\n\nvoid LidarMapOnline::resetMapRegion(const common::geometry::SE3& Tx_MP_V, double radius) {\n  common::geometry::SE3 Tx_delta /* = origin_.inverseCompose(Tx_MP_V) */;  // waiting for api\n\n  // first get all keys\n  std::vector<int> all_layer_ids;\n  for (const auto& pair : ndt3_pool_) {\n    all_layer_ids.emplace_back(pair.first);\n  }\n\n  // update ndt3 data of all layers\n  for (const auto& layer_id : all_layer_ids) {\n    float grid_size = map_layer_dict_.getGridSize(layer_id);\n    if(grid_size<0){\n      std::cout<<\"Grid size negtive\"<<endl;\n      return;\n    }\n    std::shared_ptr<Ndt3Tile> new_ndt3 =\n        std::shared_ptr<Ndt3Tile>(new Ndt3Tile(map_layer_dict_.getGridSize(layer_id)));\n    ndt3_pool_[layer_id]->copyAndTransform(Tx_delta, radius, new_ndt3.get());\n    ndt3_pool_[layer_id] = new_ndt3;\n  }\n}\n\nbool LidarMapOnline::initializeLayer(int layer_id) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it != ndt3_pool_.end()) {\n    return false;  // re-initialize\n  }\n\n  float grid_size;\n  if (!map_layer_dict_.getInfoById(layer_id, nullptr, &grid_size, nullptr)) {\n    return false;\n  }\n\n  ndt3_pool_[layer_id] = std::shared_ptr<Ndt3Tile>(new Ndt3Tile(grid_size));\n\n  return true;\n}\n\nbool LidarMapOnline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  // add sample to ndt3\n  for (const auto& sample : pointcloud) {\n    ndt3_pool_it->second->addSample(sample);\n  }\n\n  return false;\n}\n\nbool LidarMapOnline::getMap(int layer_id, std::shared_ptr<Ndt3Interface>* ndt3) {\n  if (!ndt3) {\n    return false;\n  }\n\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  *ndt3 = ndt3_pool_it->second;\n  return true;\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp"
		}
	}
]
I0403 13:45:28.874537 32175 json_parser.cpp:18] 
[
	67,
	{
		"bufnr" : 14,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_online.h\"\n\nnamespace allride {\nnamespace mapping {\n\nvoid LidarMapOnline::setMapOrigin(const common::geometry::SE3& Tx_MP_map) { origin_ = Tx_MP_map; }\n\ncommon::geometry::SE3 LidarMapOnline::getMapOrigin() { return origin_; }\n\nvoid LidarMapOnline::resetMapRegion(const common::geometry::SE3& Tx_MP_V, double radius) {\n  common::geometry::SE3 Tx_delta /* = origin_.inverseCompose(Tx_MP_V) */;  // waiting for api\n\n  // first get all keys\n  std::vector<int> all_layer_ids;\n  for (const auto& pair : ndt3_pool_) {\n    all_layer_ids.emplace_back(pair.first);\n  }\n\n  // update ndt3 data of all layers\n  for (const auto& layer_id : all_layer_ids) {\n    float grid_size = map_layer_dict_.getGridSize(layer_id);\n    if(grid_size<0){\n      std::cout<<\"Grid size negtive\"<<std::endl;\n      return;\n    }\n    std::shared_ptr<Ndt3Tile> new_ndt3 =\n        std::shared_ptr<Ndt3Tile>(new Ndt3Tile(map_layer_dict_.getGridSize(layer_id)));\n    ndt3_pool_[layer_id]->copyAndTransform(Tx_delta, radius, new_ndt3.get());\n    ndt3_pool_[layer_id] = new_ndt3;\n  }\n}\n\nbool LidarMapOnline::initializeLayer(int layer_id) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it != ndt3_pool_.end()) {\n    return false;  // re-initialize\n  }\n\n  float grid_size;\n  if (!map_layer_dict_.getInfoById(layer_id, nullptr, &grid_size, nullptr)) {\n    return false;\n  }\n\n  ndt3_pool_[layer_id] = std::shared_ptr<Ndt3Tile>(new Ndt3Tile(grid_size));\n\n  return true;\n}\n\nbool LidarMapOnline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  // add sample to ndt3\n  for (const auto& sample : pointcloud) {\n    ndt3_pool_it->second->addSample(sample);\n  }\n\n  return false;\n}\n\nbool LidarMapOnline::getMap(int layer_id, std::shared_ptr<Ndt3Interface>* ndt3) {\n  if (!ndt3) {\n    return false;\n  }\n\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  *ndt3 = ndt3_pool_it->second;\n  return true;\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp"
		}
	}
]
I0403 13:45:31.218729 32175 json_parser.cpp:18] 
[
	68,
	{
		"bufnr" : 14,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_online.h\"\n\nnamespace allride {\nnamespace mapping {\n\nvoid LidarMapOnline::setMapOrigin(const common::geometry::SE3& Tx_MP_map) { origin_ = Tx_MP_map; }\n\ncommon::geometry::SE3 LidarMapOnline::getMapOrigin() { return origin_; }\n\nvoid LidarMapOnline::resetMapRegion(const common::geometry::SE3& Tx_MP_V, double radius) {\n  common::geometry::SE3 Tx_delta /* = origin_.inverseCompose(Tx_MP_V) */;  // waiting for api\n\n  // first get all keys\n  std::vector<int> all_layer_ids;\n  for (const auto& pair : ndt3_pool_) {\n    all_layer_ids.emplace_back(pair.first);\n  }\n\n  // update ndt3 data of all layers\n  for (const auto& layer_id : all_layer_ids) {\n    float grid_size = map_layer_dict_.getGridSize(layer_id);\n    if(grid_size<0){\n      std::cout<<\"Grid size negtive\"<<std::endl;\n      return;\n    }\n    \n    std::shared_ptr<Ndt3Tile> new_ndt3 =\n        std::shared_ptr<Ndt3Tile>(new Ndt3Tile(map_layer_dict_.getGridSize(layer_id)));\n    ndt3_pool_[layer_id]->copyAndTransform(Tx_delta, radius, new_ndt3.get());\n    ndt3_pool_[layer_id] = new_ndt3;\n  }\n}\n\nbool LidarMapOnline::initializeLayer(int layer_id) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it != ndt3_pool_.end()) {\n    return false;  // re-initialize\n  }\n\n  float grid_size;\n  if (!map_layer_dict_.getInfoById(layer_id, nullptr, &grid_size, nullptr)) {\n    return false;\n  }\n\n  ndt3_pool_[layer_id] = std::shared_ptr<Ndt3Tile>(new Ndt3Tile(grid_size));\n\n  return true;\n}\n\nbool LidarMapOnline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  // add sample to ndt3\n  for (const auto& sample : pointcloud) {\n    ndt3_pool_it->second->addSample(sample);\n  }\n\n  return false;\n}\n\nbool LidarMapOnline::getMap(int layer_id, std::shared_ptr<Ndt3Interface>* ndt3) {\n  if (!ndt3) {\n    return false;\n  }\n\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  *ndt3 = ndt3_pool_it->second;\n  return true;\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp"
		}
	}
]
I0403 13:45:31.441450 32175 json_parser.cpp:18] 
[
	69,
	{
		"bufnr" : 14,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_online.h\"\n\nnamespace allride {\nnamespace mapping {\n\nvoid LidarMapOnline::setMapOrigin(const common::geometry::SE3& Tx_MP_map) { origin_ = Tx_MP_map; }\n\ncommon::geometry::SE3 LidarMapOnline::getMapOrigin() { return origin_; }\n\nvoid LidarMapOnline::resetMapRegion(const common::geometry::SE3& Tx_MP_V, double radius) {\n  common::geometry::SE3 Tx_delta /* = origin_.inverseCompose(Tx_MP_V) */;  // waiting for api\n\n  // first get all keys\n  std::vector<int> all_layer_ids;\n  for (const auto& pair : ndt3_pool_) {\n    all_layer_ids.emplace_back(pair.first);\n  }\n\n  // update ndt3 data of all layers\n  for (const auto& layer_id : all_layer_ids) {\n    float grid_size = map_layer_dict_.getGridSize(layer_id);\n    if(grid_size<0){\n      std::cout<<\"Grid size negtive\"<<std::endl;\n      return;\n    }\n\n    std::shared_ptr<Ndt3Tile> new_ndt3 =\n        std::shared_ptr<Ndt3Tile>(new Ndt3Tile(map_layer_dict_.getGridSize(layer_id)));\n    ndt3_pool_[layer_id]->copyAndTransform(Tx_delta, radius, new_ndt3.get());\n    ndt3_pool_[layer_id] = new_ndt3;\n  }\n}\n\nbool LidarMapOnline::initializeLayer(int layer_id) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it != ndt3_pool_.end()) {\n    return false;  // re-initialize\n  }\n\n  float grid_size;\n  if (!map_layer_dict_.getInfoById(layer_id, nullptr, &grid_size, nullptr)) {\n    return false;\n  }\n\n  ndt3_pool_[layer_id] = std::shared_ptr<Ndt3Tile>(new Ndt3Tile(grid_size));\n\n  return true;\n}\n\nbool LidarMapOnline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  // add sample to ndt3\n  for (const auto& sample : pointcloud) {\n    ndt3_pool_it->second->addSample(sample);\n  }\n\n  return false;\n}\n\nbool LidarMapOnline::getMap(int layer_id, std::shared_ptr<Ndt3Interface>* ndt3) {\n  if (!ndt3) {\n    return false;\n  }\n\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  *ndt3 = ndt3_pool_it->second;\n  return true;\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp"
		}
	}
]
I0403 13:45:35.415030 32175 json_parser.cpp:18] 
[
	70,
	{
		"bufnr" : 14,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_online.h\"\n\nnamespace allride {\nnamespace mapping {\n\nvoid LidarMapOnline::setMapOrigin(const common::geometry::SE3& Tx_MP_map) { origin_ = Tx_MP_map; }\n\ncommon::geometry::SE3 LidarMapOnline::getMapOrigin() { return origin_; }\n\nvoid LidarMapOnline::resetMapRegion(const common::geometry::SE3& Tx_MP_V, double radius) {\n  common::geometry::SE3 Tx_delta /* = origin_.inverseCompose(Tx_MP_V) */;  // waiting for api\n\n  // first get all keys\n  std::vector<int> all_layer_ids;\n  for (const auto& pair : ndt3_pool_) {\n    all_layer_ids.emplace_back(pair.first);\n  }\n\n  // update ndt3 data of all layers\n  for (const auto& layer_id : all_layer_ids) {\n    float grid_size = map_layer_dict_.getGridSize(layer_id);\n    if(grid_size<0){\n      std::cout<<\"Grid size negtive\"<<std::endl;\n      return;\n    }\n\n    std::shared_ptr<Ndt3Tile> new_ndt3 =\n        std::shared_ptr<Ndt3Tile>(new Ndt3Tile(ap_layer_dict_.getGridSize(layer_id)));\n    ndt3_pool_[layer_id]->copyAndTransform(Tx_delta, radius, new_ndt3.get());\n    ndt3_pool_[layer_id] = new_ndt3;\n  }\n}\n\nbool LidarMapOnline::initializeLayer(int layer_id) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it != ndt3_pool_.end()) {\n    return false;  // re-initialize\n  }\n\n  float grid_size;\n  if (!map_layer_dict_.getInfoById(layer_id, nullptr, &grid_size, nullptr)) {\n    return false;\n  }\n\n  ndt3_pool_[layer_id] = std::shared_ptr<Ndt3Tile>(new Ndt3Tile(grid_size));\n\n  return true;\n}\n\nbool LidarMapOnline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  // add sample to ndt3\n  for (const auto& sample : pointcloud) {\n    ndt3_pool_it->second->addSample(sample);\n  }\n\n  return false;\n}\n\nbool LidarMapOnline::getMap(int layer_id, std::shared_ptr<Ndt3Interface>* ndt3) {\n  if (!ndt3) {\n    return false;\n  }\n\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  *ndt3 = ndt3_pool_it->second;\n  return true;\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp"
		}
	}
]
I0403 13:45:36.075606 32175 json_parser.cpp:18] 
[
	71,
	{
		"bufnr" : 14,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_online.h\"\n\nnamespace allride {\nnamespace mapping {\n\nvoid LidarMapOnline::setMapOrigin(const common::geometry::SE3& Tx_MP_map) { origin_ = Tx_MP_map; }\n\ncommon::geometry::SE3 LidarMapOnline::getMapOrigin() { return origin_; }\n\nvoid LidarMapOnline::resetMapRegion(const common::geometry::SE3& Tx_MP_V, double radius) {\n  common::geometry::SE3 Tx_delta /* = origin_.inverseCompose(Tx_MP_V) */;  // waiting for api\n\n  // first get all keys\n  std::vector<int> all_layer_ids;\n  for (const auto& pair : ndt3_pool_) {\n    all_layer_ids.emplace_back(pair.first);\n  }\n\n  // update ndt3 data of all layers\n  for (const auto& layer_id : all_layer_ids) {\n    float grid_size = map_layer_dict_.getGridSize(layer_id);\n    if(grid_size<0){\n      std::cout<<\"Grid size negtive\"<<std::endl;\n      return;\n    }\n\n    std::shared_ptr<Ndt3Tile> new_ndt3 =\n        std::shared_ptr<Ndt3Tile>(new Ndt3Tile(p_layer_dict_.getGridSize(layer_id)));\n    ndt3_pool_[layer_id]->copyAndTransform(Tx_delta, radius, new_ndt3.get());\n    ndt3_pool_[layer_id] = new_ndt3;\n  }\n}\n\nbool LidarMapOnline::initializeLayer(int layer_id) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it != ndt3_pool_.end()) {\n    return false;  // re-initialize\n  }\n\n  float grid_size;\n  if (!map_layer_dict_.getInfoById(layer_id, nullptr, &grid_size, nullptr)) {\n    return false;\n  }\n\n  ndt3_pool_[layer_id] = std::shared_ptr<Ndt3Tile>(new Ndt3Tile(grid_size));\n\n  return true;\n}\n\nbool LidarMapOnline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  // add sample to ndt3\n  for (const auto& sample : pointcloud) {\n    ndt3_pool_it->second->addSample(sample);\n  }\n\n  return false;\n}\n\nbool LidarMapOnline::getMap(int layer_id, std::shared_ptr<Ndt3Interface>* ndt3) {\n  if (!ndt3) {\n    return false;\n  }\n\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  *ndt3 = ndt3_pool_it->second;\n  return true;\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp"
		}
	}
]
I0403 13:45:36.190644 32175 json_parser.cpp:18] 
[
	72,
	{
		"bufnr" : 14,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_online.h\"\n\nnamespace allride {\nnamespace mapping {\n\nvoid LidarMapOnline::setMapOrigin(const common::geometry::SE3& Tx_MP_map) { origin_ = Tx_MP_map; }\n\ncommon::geometry::SE3 LidarMapOnline::getMapOrigin() { return origin_; }\n\nvoid LidarMapOnline::resetMapRegion(const common::geometry::SE3& Tx_MP_V, double radius) {\n  common::geometry::SE3 Tx_delta /* = origin_.inverseCompose(Tx_MP_V) */;  // waiting for api\n\n  // first get all keys\n  std::vector<int> all_layer_ids;\n  for (const auto& pair : ndt3_pool_) {\n    all_layer_ids.emplace_back(pair.first);\n  }\n\n  // update ndt3 data of all layers\n  for (const auto& layer_id : all_layer_ids) {\n    float grid_size = map_layer_dict_.getGridSize(layer_id);\n    if(grid_size<0){\n      std::cout<<\"Grid size negtive\"<<std::endl;\n      return;\n    }\n\n    std::shared_ptr<Ndt3Tile> new_ndt3 =\n        std::shared_ptr<Ndt3Tile>(new Ndt3Tile(ayer_dict_.getGridSize(layer_id)));\n    ndt3_pool_[layer_id]->copyAndTransform(Tx_delta, radius, new_ndt3.get());\n    ndt3_pool_[layer_id] = new_ndt3;\n  }\n}\n\nbool LidarMapOnline::initializeLayer(int layer_id) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it != ndt3_pool_.end()) {\n    return false;  // re-initialize\n  }\n\n  float grid_size;\n  if (!map_layer_dict_.getInfoById(layer_id, nullptr, &grid_size, nullptr)) {\n    return false;\n  }\n\n  ndt3_pool_[layer_id] = std::shared_ptr<Ndt3Tile>(new Ndt3Tile(grid_size));\n\n  return true;\n}\n\nbool LidarMapOnline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  // add sample to ndt3\n  for (const auto& sample : pointcloud) {\n    ndt3_pool_it->second->addSample(sample);\n  }\n\n  return false;\n}\n\nbool LidarMapOnline::getMap(int layer_id, std::shared_ptr<Ndt3Interface>* ndt3) {\n  if (!ndt3) {\n    return false;\n  }\n\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  *ndt3 = ndt3_pool_it->second;\n  return true;\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp"
		}
	}
]
I0403 13:45:36.273703 32175 json_parser.cpp:18] 
[
	73,
	{
		"bufnr" : 14,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_online.h\"\n\nnamespace allride {\nnamespace mapping {\n\nvoid LidarMapOnline::setMapOrigin(const common::geometry::SE3& Tx_MP_map) { origin_ = Tx_MP_map; }\n\ncommon::geometry::SE3 LidarMapOnline::getMapOrigin() { return origin_; }\n\nvoid LidarMapOnline::resetMapRegion(const common::geometry::SE3& Tx_MP_V, double radius) {\n  common::geometry::SE3 Tx_delta /* = origin_.inverseCompose(Tx_MP_V) */;  // waiting for api\n\n  // first get all keys\n  std::vector<int> all_layer_ids;\n  for (const auto& pair : ndt3_pool_) {\n    all_layer_ids.emplace_back(pair.first);\n  }\n\n  // update ndt3 data of all layers\n  for (const auto& layer_id : all_layer_ids) {\n    float grid_size = map_layer_dict_.getGridSize(layer_id);\n    if(grid_size<0){\n      std::cout<<\"Grid size negtive\"<<std::endl;\n      return;\n    }\n\n    std::shared_ptr<Ndt3Tile> new_ndt3 =\n        std::shared_ptr<Ndt3Tile>(new Ndt3Tile(er_dict_.getGridSize(layer_id)));\n    ndt3_pool_[layer_id]->copyAndTransform(Tx_delta, radius, new_ndt3.get());\n    ndt3_pool_[layer_id] = new_ndt3;\n  }\n}\n\nbool LidarMapOnline::initializeLayer(int layer_id) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it != ndt3_pool_.end()) {\n    return false;  // re-initialize\n  }\n\n  float grid_size;\n  if (!map_layer_dict_.getInfoById(layer_id, nullptr, &grid_size, nullptr)) {\n    return false;\n  }\n\n  ndt3_pool_[layer_id] = std::shared_ptr<Ndt3Tile>(new Ndt3Tile(grid_size));\n\n  return true;\n}\n\nbool LidarMapOnline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  // add sample to ndt3\n  for (const auto& sample : pointcloud) {\n    ndt3_pool_it->second->addSample(sample);\n  }\n\n  return false;\n}\n\nbool LidarMapOnline::getMap(int layer_id, std::shared_ptr<Ndt3Interface>* ndt3) {\n  if (!ndt3) {\n    return false;\n  }\n\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  *ndt3 = ndt3_pool_it->second;\n  return true;\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp"
		}
	}
]
I0403 13:45:36.355764 32175 json_parser.cpp:18] 
[
	74,
	{
		"bufnr" : 14,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_online.h\"\n\nnamespace allride {\nnamespace mapping {\n\nvoid LidarMapOnline::setMapOrigin(const common::geometry::SE3& Tx_MP_map) { origin_ = Tx_MP_map; }\n\ncommon::geometry::SE3 LidarMapOnline::getMapOrigin() { return origin_; }\n\nvoid LidarMapOnline::resetMapRegion(const common::geometry::SE3& Tx_MP_V, double radius) {\n  common::geometry::SE3 Tx_delta /* = origin_.inverseCompose(Tx_MP_V) */;  // waiting for api\n\n  // first get all keys\n  std::vector<int> all_layer_ids;\n  for (const auto& pair : ndt3_pool_) {\n    all_layer_ids.emplace_back(pair.first);\n  }\n\n  // update ndt3 data of all layers\n  for (const auto& layer_id : all_layer_ids) {\n    float grid_size = map_layer_dict_.getGridSize(layer_id);\n    if(grid_size<0){\n      std::cout<<\"Grid size negtive\"<<std::endl;\n      return;\n    }\n\n    std::shared_ptr<Ndt3Tile> new_ndt3 =\n        std::shared_ptr<Ndt3Tile>(new Ndt3Tile(_dict_.getGridSize(layer_id)));\n    ndt3_pool_[layer_id]->copyAndTransform(Tx_delta, radius, new_ndt3.get());\n    ndt3_pool_[layer_id] = new_ndt3;\n  }\n}\n\nbool LidarMapOnline::initializeLayer(int layer_id) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it != ndt3_pool_.end()) {\n    return false;  // re-initialize\n  }\n\n  float grid_size;\n  if (!map_layer_dict_.getInfoById(layer_id, nullptr, &grid_size, nullptr)) {\n    return false;\n  }\n\n  ndt3_pool_[layer_id] = std::shared_ptr<Ndt3Tile>(new Ndt3Tile(grid_size));\n\n  return true;\n}\n\nbool LidarMapOnline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  // add sample to ndt3\n  for (const auto& sample : pointcloud) {\n    ndt3_pool_it->second->addSample(sample);\n  }\n\n  return false;\n}\n\nbool LidarMapOnline::getMap(int layer_id, std::shared_ptr<Ndt3Interface>* ndt3) {\n  if (!ndt3) {\n    return false;\n  }\n\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  *ndt3 = ndt3_pool_it->second;\n  return true;\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp"
		}
	}
]
I0403 13:45:36.436230 32175 json_parser.cpp:18] 
[
	75,
	{
		"bufnr" : 14,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_online.h\"\n\nnamespace allride {\nnamespace mapping {\n\nvoid LidarMapOnline::setMapOrigin(const common::geometry::SE3& Tx_MP_map) { origin_ = Tx_MP_map; }\n\ncommon::geometry::SE3 LidarMapOnline::getMapOrigin() { return origin_; }\n\nvoid LidarMapOnline::resetMapRegion(const common::geometry::SE3& Tx_MP_V, double radius) {\n  common::geometry::SE3 Tx_delta /* = origin_.inverseCompose(Tx_MP_V) */;  // waiting for api\n\n  // first get all keys\n  std::vector<int> all_layer_ids;\n  for (const auto& pair : ndt3_pool_) {\n    all_layer_ids.emplace_back(pair.first);\n  }\n\n  // update ndt3 data of all layers\n  for (const auto& layer_id : all_layer_ids) {\n    float grid_size = map_layer_dict_.getGridSize(layer_id);\n    if(grid_size<0){\n      std::cout<<\"Grid size negtive\"<<std::endl;\n      return;\n    }\n\n    std::shared_ptr<Ndt3Tile> new_ndt3 =\n        std::shared_ptr<Ndt3Tile>(new Ndt3Tile(ict_.getGridSize(layer_id)));\n    ndt3_pool_[layer_id]->copyAndTransform(Tx_delta, radius, new_ndt3.get());\n    ndt3_pool_[layer_id] = new_ndt3;\n  }\n}\n\nbool LidarMapOnline::initializeLayer(int layer_id) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it != ndt3_pool_.end()) {\n    return false;  // re-initialize\n  }\n\n  float grid_size;\n  if (!map_layer_dict_.getInfoById(layer_id, nullptr, &grid_size, nullptr)) {\n    return false;\n  }\n\n  ndt3_pool_[layer_id] = std::shared_ptr<Ndt3Tile>(new Ndt3Tile(grid_size));\n\n  return true;\n}\n\nbool LidarMapOnline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  // add sample to ndt3\n  for (const auto& sample : pointcloud) {\n    ndt3_pool_it->second->addSample(sample);\n  }\n\n  return false;\n}\n\nbool LidarMapOnline::getMap(int layer_id, std::shared_ptr<Ndt3Interface>* ndt3) {\n  if (!ndt3) {\n    return false;\n  }\n\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  *ndt3 = ndt3_pool_it->second;\n  return true;\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp"
		}
	}
]
I0403 13:45:36.517699 32175 json_parser.cpp:18] 
[
	76,
	{
		"bufnr" : 14,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_online.h\"\n\nnamespace allride {\nnamespace mapping {\n\nvoid LidarMapOnline::setMapOrigin(const common::geometry::SE3& Tx_MP_map) { origin_ = Tx_MP_map; }\n\ncommon::geometry::SE3 LidarMapOnline::getMapOrigin() { return origin_; }\n\nvoid LidarMapOnline::resetMapRegion(const common::geometry::SE3& Tx_MP_V, double radius) {\n  common::geometry::SE3 Tx_delta /* = origin_.inverseCompose(Tx_MP_V) */;  // waiting for api\n\n  // first get all keys\n  std::vector<int> all_layer_ids;\n  for (const auto& pair : ndt3_pool_) {\n    all_layer_ids.emplace_back(pair.first);\n  }\n\n  // update ndt3 data of all layers\n  for (const auto& layer_id : all_layer_ids) {\n    float grid_size = map_layer_dict_.getGridSize(layer_id);\n    if(grid_size<0){\n      std::cout<<\"Grid size negtive\"<<std::endl;\n      return;\n    }\n\n    std::shared_ptr<Ndt3Tile> new_ndt3 =\n        std::shared_ptr<Ndt3Tile>(new Ndt3Tile(t_.getGridSize(layer_id)));\n    ndt3_pool_[layer_id]->copyAndTransform(Tx_delta, radius, new_ndt3.get());\n    ndt3_pool_[layer_id] = new_ndt3;\n  }\n}\n\nbool LidarMapOnline::initializeLayer(int layer_id) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it != ndt3_pool_.end()) {\n    return false;  // re-initialize\n  }\n\n  float grid_size;\n  if (!map_layer_dict_.getInfoById(layer_id, nullptr, &grid_size, nullptr)) {\n    return false;\n  }\n\n  ndt3_pool_[layer_id] = std::shared_ptr<Ndt3Tile>(new Ndt3Tile(grid_size));\n\n  return true;\n}\n\nbool LidarMapOnline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  // add sample to ndt3\n  for (const auto& sample : pointcloud) {\n    ndt3_pool_it->second->addSample(sample);\n  }\n\n  return false;\n}\n\nbool LidarMapOnline::getMap(int layer_id, std::shared_ptr<Ndt3Interface>* ndt3) {\n  if (!ndt3) {\n    return false;\n  }\n\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  *ndt3 = ndt3_pool_it->second;\n  return true;\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp"
		}
	}
]
I0403 13:45:36.600193 32175 json_parser.cpp:18] 
[
	77,
	{
		"bufnr" : 14,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_online.h\"\n\nnamespace allride {\nnamespace mapping {\n\nvoid LidarMapOnline::setMapOrigin(const common::geometry::SE3& Tx_MP_map) { origin_ = Tx_MP_map; }\n\ncommon::geometry::SE3 LidarMapOnline::getMapOrigin() { return origin_; }\n\nvoid LidarMapOnline::resetMapRegion(const common::geometry::SE3& Tx_MP_V, double radius) {\n  common::geometry::SE3 Tx_delta /* = origin_.inverseCompose(Tx_MP_V) */;  // waiting for api\n\n  // first get all keys\n  std::vector<int> all_layer_ids;\n  for (const auto& pair : ndt3_pool_) {\n    all_layer_ids.emplace_back(pair.first);\n  }\n\n  // update ndt3 data of all layers\n  for (const auto& layer_id : all_layer_ids) {\n    float grid_size = map_layer_dict_.getGridSize(layer_id);\n    if(grid_size<0){\n      std::cout<<\"Grid size negtive\"<<std::endl;\n      return;\n    }\n\n    std::shared_ptr<Ndt3Tile> new_ndt3 =\n        std::shared_ptr<Ndt3Tile>(new Ndt3Tile(.getGridSize(layer_id)));\n    ndt3_pool_[layer_id]->copyAndTransform(Tx_delta, radius, new_ndt3.get());\n    ndt3_pool_[layer_id] = new_ndt3;\n  }\n}\n\nbool LidarMapOnline::initializeLayer(int layer_id) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it != ndt3_pool_.end()) {\n    return false;  // re-initialize\n  }\n\n  float grid_size;\n  if (!map_layer_dict_.getInfoById(layer_id, nullptr, &grid_size, nullptr)) {\n    return false;\n  }\n\n  ndt3_pool_[layer_id] = std::shared_ptr<Ndt3Tile>(new Ndt3Tile(grid_size));\n\n  return true;\n}\n\nbool LidarMapOnline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  // add sample to ndt3\n  for (const auto& sample : pointcloud) {\n    ndt3_pool_it->second->addSample(sample);\n  }\n\n  return false;\n}\n\nbool LidarMapOnline::getMap(int layer_id, std::shared_ptr<Ndt3Interface>* ndt3) {\n  if (!ndt3) {\n    return false;\n  }\n\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  *ndt3 = ndt3_pool_it->second;\n  return true;\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp"
		}
	}
]
I0403 13:45:36.680271 32175 json_parser.cpp:18] 
[
	78,
	{
		"bufnr" : 14,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_online.h\"\n\nnamespace allride {\nnamespace mapping {\n\nvoid LidarMapOnline::setMapOrigin(const common::geometry::SE3& Tx_MP_map) { origin_ = Tx_MP_map; }\n\ncommon::geometry::SE3 LidarMapOnline::getMapOrigin() { return origin_; }\n\nvoid LidarMapOnline::resetMapRegion(const common::geometry::SE3& Tx_MP_V, double radius) {\n  common::geometry::SE3 Tx_delta /* = origin_.inverseCompose(Tx_MP_V) */;  // waiting for api\n\n  // first get all keys\n  std::vector<int> all_layer_ids;\n  for (const auto& pair : ndt3_pool_) {\n    all_layer_ids.emplace_back(pair.first);\n  }\n\n  // update ndt3 data of all layers\n  for (const auto& layer_id : all_layer_ids) {\n    float grid_size = map_layer_dict_.getGridSize(layer_id);\n    if(grid_size<0){\n      std::cout<<\"Grid size negtive\"<<std::endl;\n      return;\n    }\n\n    std::shared_ptr<Ndt3Tile> new_ndt3 =\n        std::shared_ptr<Ndt3Tile>(new Ndt3Tile(etGridSize(layer_id)));\n    ndt3_pool_[layer_id]->copyAndTransform(Tx_delta, radius, new_ndt3.get());\n    ndt3_pool_[layer_id] = new_ndt3;\n  }\n}\n\nbool LidarMapOnline::initializeLayer(int layer_id) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it != ndt3_pool_.end()) {\n    return false;  // re-initialize\n  }\n\n  float grid_size;\n  if (!map_layer_dict_.getInfoById(layer_id, nullptr, &grid_size, nullptr)) {\n    return false;\n  }\n\n  ndt3_pool_[layer_id] = std::shared_ptr<Ndt3Tile>(new Ndt3Tile(grid_size));\n\n  return true;\n}\n\nbool LidarMapOnline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  // add sample to ndt3\n  for (const auto& sample : pointcloud) {\n    ndt3_pool_it->second->addSample(sample);\n  }\n\n  return false;\n}\n\nbool LidarMapOnline::getMap(int layer_id, std::shared_ptr<Ndt3Interface>* ndt3) {\n  if (!ndt3) {\n    return false;\n  }\n\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  *ndt3 = ndt3_pool_it->second;\n  return true;\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp"
		}
	}
]
I0403 13:45:36.762037 32175 json_parser.cpp:18] 
[
	79,
	{
		"bufnr" : 14,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_online.h\"\n\nnamespace allride {\nnamespace mapping {\n\nvoid LidarMapOnline::setMapOrigin(const common::geometry::SE3& Tx_MP_map) { origin_ = Tx_MP_map; }\n\ncommon::geometry::SE3 LidarMapOnline::getMapOrigin() { return origin_; }\n\nvoid LidarMapOnline::resetMapRegion(const common::geometry::SE3& Tx_MP_V, double radius) {\n  common::geometry::SE3 Tx_delta /* = origin_.inverseCompose(Tx_MP_V) */;  // waiting for api\n\n  // first get all keys\n  std::vector<int> all_layer_ids;\n  for (const auto& pair : ndt3_pool_) {\n    all_layer_ids.emplace_back(pair.first);\n  }\n\n  // update ndt3 data of all layers\n  for (const auto& layer_id : all_layer_ids) {\n    float grid_size = map_layer_dict_.getGridSize(layer_id);\n    if(grid_size<0){\n      std::cout<<\"Grid size negtive\"<<std::endl;\n      return;\n    }\n\n    std::shared_ptr<Ndt3Tile> new_ndt3 =\n        std::shared_ptr<Ndt3Tile>(new Ndt3Tile(GridSize(layer_id)));\n    ndt3_pool_[layer_id]->copyAndTransform(Tx_delta, radius, new_ndt3.get());\n    ndt3_pool_[layer_id] = new_ndt3;\n  }\n}\n\nbool LidarMapOnline::initializeLayer(int layer_id) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it != ndt3_pool_.end()) {\n    return false;  // re-initialize\n  }\n\n  float grid_size;\n  if (!map_layer_dict_.getInfoById(layer_id, nullptr, &grid_size, nullptr)) {\n    return false;\n  }\n\n  ndt3_pool_[layer_id] = std::shared_ptr<Ndt3Tile>(new Ndt3Tile(grid_size));\n\n  return true;\n}\n\nbool LidarMapOnline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  // add sample to ndt3\n  for (const auto& sample : pointcloud) {\n    ndt3_pool_it->second->addSample(sample);\n  }\n\n  return false;\n}\n\nbool LidarMapOnline::getMap(int layer_id, std::shared_ptr<Ndt3Interface>* ndt3) {\n  if (!ndt3) {\n    return false;\n  }\n\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  *ndt3 = ndt3_pool_it->second;\n  return true;\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp"
		}
	}
]
I0403 13:45:36.876031 32175 json_parser.cpp:18] 
[
	80,
	{
		"bufnr" : 14,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_online.h\"\n\nnamespace allride {\nnamespace mapping {\n\nvoid LidarMapOnline::setMapOrigin(const common::geometry::SE3& Tx_MP_map) { origin_ = Tx_MP_map; }\n\ncommon::geometry::SE3 LidarMapOnline::getMapOrigin() { return origin_; }\n\nvoid LidarMapOnline::resetMapRegion(const common::geometry::SE3& Tx_MP_V, double radius) {\n  common::geometry::SE3 Tx_delta /* = origin_.inverseCompose(Tx_MP_V) */;  // waiting for api\n\n  // first get all keys\n  std::vector<int> all_layer_ids;\n  for (const auto& pair : ndt3_pool_) {\n    all_layer_ids.emplace_back(pair.first);\n  }\n\n  // update ndt3 data of all layers\n  for (const auto& layer_id : all_layer_ids) {\n    float grid_size = map_layer_dict_.getGridSize(layer_id);\n    if(grid_size<0){\n      std::cout<<\"Grid size negtive\"<<std::endl;\n      return;\n    }\n\n    std::shared_ptr<Ndt3Tile> new_ndt3 =\n        std::shared_ptr<Ndt3Tile>(new Ndt3Tile(dSize(layer_id)));\n    ndt3_pool_[layer_id]->copyAndTransform(Tx_delta, radius, new_ndt3.get());\n    ndt3_pool_[layer_id] = new_ndt3;\n  }\n}\n\nbool LidarMapOnline::initializeLayer(int layer_id) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it != ndt3_pool_.end()) {\n    return false;  // re-initialize\n  }\n\n  float grid_size;\n  if (!map_layer_dict_.getInfoById(layer_id, nullptr, &grid_size, nullptr)) {\n    return false;\n  }\n\n  ndt3_pool_[layer_id] = std::shared_ptr<Ndt3Tile>(new Ndt3Tile(grid_size));\n\n  return true;\n}\n\nbool LidarMapOnline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  // add sample to ndt3\n  for (const auto& sample : pointcloud) {\n    ndt3_pool_it->second->addSample(sample);\n  }\n\n  return false;\n}\n\nbool LidarMapOnline::getMap(int layer_id, std::shared_ptr<Ndt3Interface>* ndt3) {\n  if (!ndt3) {\n    return false;\n  }\n\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  *ndt3 = ndt3_pool_it->second;\n  return true;\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp"
		}
	}
]
I0403 13:45:36.960364 32175 json_parser.cpp:18] 
[
	81,
	{
		"bufnr" : 14,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_online.h\"\n\nnamespace allride {\nnamespace mapping {\n\nvoid LidarMapOnline::setMapOrigin(const common::geometry::SE3& Tx_MP_map) { origin_ = Tx_MP_map; }\n\ncommon::geometry::SE3 LidarMapOnline::getMapOrigin() { return origin_; }\n\nvoid LidarMapOnline::resetMapRegion(const common::geometry::SE3& Tx_MP_V, double radius) {\n  common::geometry::SE3 Tx_delta /* = origin_.inverseCompose(Tx_MP_V) */;  // waiting for api\n\n  // first get all keys\n  std::vector<int> all_layer_ids;\n  for (const auto& pair : ndt3_pool_) {\n    all_layer_ids.emplace_back(pair.first);\n  }\n\n  // update ndt3 data of all layers\n  for (const auto& layer_id : all_layer_ids) {\n    float grid_size = map_layer_dict_.getGridSize(layer_id);\n    if(grid_size<0){\n      std::cout<<\"Grid size negtive\"<<std::endl;\n      return;\n    }\n\n    std::shared_ptr<Ndt3Tile> new_ndt3 =\n        std::shared_ptr<Ndt3Tile>(new Ndt3Tile(ize(layer_id)));\n    ndt3_pool_[layer_id]->copyAndTransform(Tx_delta, radius, new_ndt3.get());\n    ndt3_pool_[layer_id] = new_ndt3;\n  }\n}\n\nbool LidarMapOnline::initializeLayer(int layer_id) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it != ndt3_pool_.end()) {\n    return false;  // re-initialize\n  }\n\n  float grid_size;\n  if (!map_layer_dict_.getInfoById(layer_id, nullptr, &grid_size, nullptr)) {\n    return false;\n  }\n\n  ndt3_pool_[layer_id] = std::shared_ptr<Ndt3Tile>(new Ndt3Tile(grid_size));\n\n  return true;\n}\n\nbool LidarMapOnline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  // add sample to ndt3\n  for (const auto& sample : pointcloud) {\n    ndt3_pool_it->second->addSample(sample);\n  }\n\n  return false;\n}\n\nbool LidarMapOnline::getMap(int layer_id, std::shared_ptr<Ndt3Interface>* ndt3) {\n  if (!ndt3) {\n    return false;\n  }\n\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  *ndt3 = ndt3_pool_it->second;\n  return true;\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp"
		}
	}
]
I0403 13:45:37.041893 32175 json_parser.cpp:18] 
[
	82,
	{
		"bufnr" : 14,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_online.h\"\n\nnamespace allride {\nnamespace mapping {\n\nvoid LidarMapOnline::setMapOrigin(const common::geometry::SE3& Tx_MP_map) { origin_ = Tx_MP_map; }\n\ncommon::geometry::SE3 LidarMapOnline::getMapOrigin() { return origin_; }\n\nvoid LidarMapOnline::resetMapRegion(const common::geometry::SE3& Tx_MP_V, double radius) {\n  common::geometry::SE3 Tx_delta /* = origin_.inverseCompose(Tx_MP_V) */;  // waiting for api\n\n  // first get all keys\n  std::vector<int> all_layer_ids;\n  for (const auto& pair : ndt3_pool_) {\n    all_layer_ids.emplace_back(pair.first);\n  }\n\n  // update ndt3 data of all layers\n  for (const auto& layer_id : all_layer_ids) {\n    float grid_size = map_layer_dict_.getGridSize(layer_id);\n    if(grid_size<0){\n      std::cout<<\"Grid size negtive\"<<std::endl;\n      return;\n    }\n\n    std::shared_ptr<Ndt3Tile> new_ndt3 =\n        std::shared_ptr<Ndt3Tile>(new Ndt3Tile(e(layer_id)));\n    ndt3_pool_[layer_id]->copyAndTransform(Tx_delta, radius, new_ndt3.get());\n    ndt3_pool_[layer_id] = new_ndt3;\n  }\n}\n\nbool LidarMapOnline::initializeLayer(int layer_id) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it != ndt3_pool_.end()) {\n    return false;  // re-initialize\n  }\n\n  float grid_size;\n  if (!map_layer_dict_.getInfoById(layer_id, nullptr, &grid_size, nullptr)) {\n    return false;\n  }\n\n  ndt3_pool_[layer_id] = std::shared_ptr<Ndt3Tile>(new Ndt3Tile(grid_size));\n\n  return true;\n}\n\nbool LidarMapOnline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  // add sample to ndt3\n  for (const auto& sample : pointcloud) {\n    ndt3_pool_it->second->addSample(sample);\n  }\n\n  return false;\n}\n\nbool LidarMapOnline::getMap(int layer_id, std::shared_ptr<Ndt3Interface>* ndt3) {\n  if (!ndt3) {\n    return false;\n  }\n\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  *ndt3 = ndt3_pool_it->second;\n  return true;\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp"
		}
	}
]
I0403 13:45:37.124660 32175 json_parser.cpp:18] 
[
	83,
	{
		"bufnr" : 14,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_online.h\"\n\nnamespace allride {\nnamespace mapping {\n\nvoid LidarMapOnline::setMapOrigin(const common::geometry::SE3& Tx_MP_map) { origin_ = Tx_MP_map; }\n\ncommon::geometry::SE3 LidarMapOnline::getMapOrigin() { return origin_; }\n\nvoid LidarMapOnline::resetMapRegion(const common::geometry::SE3& Tx_MP_V, double radius) {\n  common::geometry::SE3 Tx_delta /* = origin_.inverseCompose(Tx_MP_V) */;  // waiting for api\n\n  // first get all keys\n  std::vector<int> all_layer_ids;\n  for (const auto& pair : ndt3_pool_) {\n    all_layer_ids.emplace_back(pair.first);\n  }\n\n  // update ndt3 data of all layers\n  for (const auto& layer_id : all_layer_ids) {\n    float grid_size = map_layer_dict_.getGridSize(layer_id);\n    if(grid_size<0){\n      std::cout<<\"Grid size negtive\"<<std::endl;\n      return;\n    }\n\n    std::shared_ptr<Ndt3Tile> new_ndt3 =\n        std::shared_ptr<Ndt3Tile>(new Ndt3Tile(layer_id)));\n    ndt3_pool_[layer_id]->copyAndTransform(Tx_delta, radius, new_ndt3.get());\n    ndt3_pool_[layer_id] = new_ndt3;\n  }\n}\n\nbool LidarMapOnline::initializeLayer(int layer_id) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it != ndt3_pool_.end()) {\n    return false;  // re-initialize\n  }\n\n  float grid_size;\n  if (!map_layer_dict_.getInfoById(layer_id, nullptr, &grid_size, nullptr)) {\n    return false;\n  }\n\n  ndt3_pool_[layer_id] = std::shared_ptr<Ndt3Tile>(new Ndt3Tile(grid_size));\n\n  return true;\n}\n\nbool LidarMapOnline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  // add sample to ndt3\n  for (const auto& sample : pointcloud) {\n    ndt3_pool_it->second->addSample(sample);\n  }\n\n  return false;\n}\n\nbool LidarMapOnline::getMap(int layer_id, std::shared_ptr<Ndt3Interface>* ndt3) {\n  if (!ndt3) {\n    return false;\n  }\n\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  *ndt3 = ndt3_pool_it->second;\n  return true;\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp"
		}
	}
]
I0403 13:45:37.237298 32175 json_parser.cpp:18] 
[
	84,
	{
		"bufnr" : 14,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_online.h\"\n\nnamespace allride {\nnamespace mapping {\n\nvoid LidarMapOnline::setMapOrigin(const common::geometry::SE3& Tx_MP_map) { origin_ = Tx_MP_map; }\n\ncommon::geometry::SE3 LidarMapOnline::getMapOrigin() { return origin_; }\n\nvoid LidarMapOnline::resetMapRegion(const common::geometry::SE3& Tx_MP_V, double radius) {\n  common::geometry::SE3 Tx_delta /* = origin_.inverseCompose(Tx_MP_V) */;  // waiting for api\n\n  // first get all keys\n  std::vector<int> all_layer_ids;\n  for (const auto& pair : ndt3_pool_) {\n    all_layer_ids.emplace_back(pair.first);\n  }\n\n  // update ndt3 data of all layers\n  for (const auto& layer_id : all_layer_ids) {\n    float grid_size = map_layer_dict_.getGridSize(layer_id);\n    if(grid_size<0){\n      std::cout<<\"Grid size negtive\"<<std::endl;\n      return;\n    }\n\n    std::shared_ptr<Ndt3Tile> new_ndt3 =\n        std::shared_ptr<Ndt3Tile>(new Ndt3Tile(er_id)));\n    ndt3_pool_[layer_id]->copyAndTransform(Tx_delta, radius, new_ndt3.get());\n    ndt3_pool_[layer_id] = new_ndt3;\n  }\n}\n\nbool LidarMapOnline::initializeLayer(int layer_id) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it != ndt3_pool_.end()) {\n    return false;  // re-initialize\n  }\n\n  float grid_size;\n  if (!map_layer_dict_.getInfoById(layer_id, nullptr, &grid_size, nullptr)) {\n    return false;\n  }\n\n  ndt3_pool_[layer_id] = std::shared_ptr<Ndt3Tile>(new Ndt3Tile(grid_size));\n\n  return true;\n}\n\nbool LidarMapOnline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  // add sample to ndt3\n  for (const auto& sample : pointcloud) {\n    ndt3_pool_it->second->addSample(sample);\n  }\n\n  return false;\n}\n\nbool LidarMapOnline::getMap(int layer_id, std::shared_ptr<Ndt3Interface>* ndt3) {\n  if (!ndt3) {\n    return false;\n  }\n\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  *ndt3 = ndt3_pool_it->second;\n  return true;\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp"
		}
	}
]
I0403 13:45:37.319317 32175 json_parser.cpp:18] 
[
	85,
	{
		"bufnr" : 14,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_online.h\"\n\nnamespace allride {\nnamespace mapping {\n\nvoid LidarMapOnline::setMapOrigin(const common::geometry::SE3& Tx_MP_map) { origin_ = Tx_MP_map; }\n\ncommon::geometry::SE3 LidarMapOnline::getMapOrigin() { return origin_; }\n\nvoid LidarMapOnline::resetMapRegion(const common::geometry::SE3& Tx_MP_V, double radius) {\n  common::geometry::SE3 Tx_delta /* = origin_.inverseCompose(Tx_MP_V) */;  // waiting for api\n\n  // first get all keys\n  std::vector<int> all_layer_ids;\n  for (const auto& pair : ndt3_pool_) {\n    all_layer_ids.emplace_back(pair.first);\n  }\n\n  // update ndt3 data of all layers\n  for (const auto& layer_id : all_layer_ids) {\n    float grid_size = map_layer_dict_.getGridSize(layer_id);\n    if(grid_size<0){\n      std::cout<<\"Grid size negtive\"<<std::endl;\n      return;\n    }\n\n    std::shared_ptr<Ndt3Tile> new_ndt3 =\n        std::shared_ptr<Ndt3Tile>(new Ndt3Tile(_id)));\n    ndt3_pool_[layer_id]->copyAndTransform(Tx_delta, radius, new_ndt3.get());\n    ndt3_pool_[layer_id] = new_ndt3;\n  }\n}\n\nbool LidarMapOnline::initializeLayer(int layer_id) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it != ndt3_pool_.end()) {\n    return false;  // re-initialize\n  }\n\n  float grid_size;\n  if (!map_layer_dict_.getInfoById(layer_id, nullptr, &grid_size, nullptr)) {\n    return false;\n  }\n\n  ndt3_pool_[layer_id] = std::shared_ptr<Ndt3Tile>(new Ndt3Tile(grid_size));\n\n  return true;\n}\n\nbool LidarMapOnline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  // add sample to ndt3\n  for (const auto& sample : pointcloud) {\n    ndt3_pool_it->second->addSample(sample);\n  }\n\n  return false;\n}\n\nbool LidarMapOnline::getMap(int layer_id, std::shared_ptr<Ndt3Interface>* ndt3) {\n  if (!ndt3) {\n    return false;\n  }\n\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  *ndt3 = ndt3_pool_it->second;\n  return true;\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp"
		}
	}
]
I0403 13:45:37.655007 32175 json_parser.cpp:18] 
[
	86,
	{
		"bufnr" : 14,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_online.h\"\n\nnamespace allride {\nnamespace mapping {\n\nvoid LidarMapOnline::setMapOrigin(const common::geometry::SE3& Tx_MP_map) { origin_ = Tx_MP_map; }\n\ncommon::geometry::SE3 LidarMapOnline::getMapOrigin() { return origin_; }\n\nvoid LidarMapOnline::resetMapRegion(const common::geometry::SE3& Tx_MP_V, double radius) {\n  common::geometry::SE3 Tx_delta /* = origin_.inverseCompose(Tx_MP_V) */;  // waiting for api\n\n  // first get all keys\n  std::vector<int> all_layer_ids;\n  for (const auto& pair : ndt3_pool_) {\n    all_layer_ids.emplace_back(pair.first);\n  }\n\n  // update ndt3 data of all layers\n  for (const auto& layer_id : all_layer_ids) {\n    float grid_size = map_layer_dict_.getGridSize(layer_id);\n    if(grid_size<0){\n      std::cout<<\"Grid size negtive\"<<std::endl;\n      return;\n    }\n\n    std::shared_ptr<Ndt3Tile> new_ndt3 =\n        std::shared_ptr<Ndt3Tile>(new Ndt3Tile(d)));\n    ndt3_pool_[layer_id]->copyAndTransform(Tx_delta, radius, new_ndt3.get());\n    ndt3_pool_[layer_id] = new_ndt3;\n  }\n}\n\nbool LidarMapOnline::initializeLayer(int layer_id) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it != ndt3_pool_.end()) {\n    return false;  // re-initialize\n  }\n\n  float grid_size;\n  if (!map_layer_dict_.getInfoById(layer_id, nullptr, &grid_size, nullptr)) {\n    return false;\n  }\n\n  ndt3_pool_[layer_id] = std::shared_ptr<Ndt3Tile>(new Ndt3Tile(grid_size));\n\n  return true;\n}\n\nbool LidarMapOnline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  // add sample to ndt3\n  for (const auto& sample : pointcloud) {\n    ndt3_pool_it->second->addSample(sample);\n  }\n\n  return false;\n}\n\nbool LidarMapOnline::getMap(int layer_id, std::shared_ptr<Ndt3Interface>* ndt3) {\n  if (!ndt3) {\n    return false;\n  }\n\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  *ndt3 = ndt3_pool_it->second;\n  return true;\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp"
		}
	}
]
I0403 13:45:37.858220 32175 json_parser.cpp:18] 
[
	87,
	{
		"bufnr" : 14,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_online.h\"\n\nnamespace allride {\nnamespace mapping {\n\nvoid LidarMapOnline::setMapOrigin(const common::geometry::SE3& Tx_MP_map) { origin_ = Tx_MP_map; }\n\ncommon::geometry::SE3 LidarMapOnline::getMapOrigin() { return origin_; }\n\nvoid LidarMapOnline::resetMapRegion(const common::geometry::SE3& Tx_MP_V, double radius) {\n  common::geometry::SE3 Tx_delta /* = origin_.inverseCompose(Tx_MP_V) */;  // waiting for api\n\n  // first get all keys\n  std::vector<int> all_layer_ids;\n  for (const auto& pair : ndt3_pool_) {\n    all_layer_ids.emplace_back(pair.first);\n  }\n\n  // update ndt3 data of all layers\n  for (const auto& layer_id : all_layer_ids) {\n    float grid_size = map_layer_dict_.getGridSize(layer_id);\n    if(grid_size<0){\n      std::cout<<\"Grid size negtive\"<<std::endl;\n      return;\n    }\n\n    std::shared_ptr<Ndt3Tile> new_ndt3 =\n        std::shared_ptr<Ndt3Tile>(new Ndt3Tile()));\n    ndt3_pool_[layer_id]->copyAndTransform(Tx_delta, radius, new_ndt3.get());\n    ndt3_pool_[layer_id] = new_ndt3;\n  }\n}\n\nbool LidarMapOnline::initializeLayer(int layer_id) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it != ndt3_pool_.end()) {\n    return false;  // re-initialize\n  }\n\n  float grid_size;\n  if (!map_layer_dict_.getInfoById(layer_id, nullptr, &grid_size, nullptr)) {\n    return false;\n  }\n\n  ndt3_pool_[layer_id] = std::shared_ptr<Ndt3Tile>(new Ndt3Tile(grid_size));\n\n  return true;\n}\n\nbool LidarMapOnline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  // add sample to ndt3\n  for (const auto& sample : pointcloud) {\n    ndt3_pool_it->second->addSample(sample);\n  }\n\n  return false;\n}\n\nbool LidarMapOnline::getMap(int layer_id, std::shared_ptr<Ndt3Interface>* ndt3) {\n  if (!ndt3) {\n    return false;\n  }\n\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  *ndt3 = ndt3_pool_it->second;\n  return true;\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp"
		}
	}
]
I0403 13:45:38.767424 32175 json_parser.cpp:18] 
[
	88,
	{
		"bufnr" : 14,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_online.h\"\n\nnamespace allride {\nnamespace mapping {\n\nvoid LidarMapOnline::setMapOrigin(const common::geometry::SE3& Tx_MP_map) { origin_ = Tx_MP_map; }\n\ncommon::geometry::SE3 LidarMapOnline::getMapOrigin() { return origin_; }\n\nvoid LidarMapOnline::resetMapRegion(const common::geometry::SE3& Tx_MP_V, double radius) {\n  common::geometry::SE3 Tx_delta /* = origin_.inverseCompose(Tx_MP_V) */;  // waiting for api\n\n  // first get all keys\n  std::vector<int> all_layer_ids;\n  for (const auto& pair : ndt3_pool_) {\n    all_layer_ids.emplace_back(pair.first);\n  }\n\n  // update ndt3 data of all layers\n  for (const auto& layer_id : all_layer_ids) {\n    float grid_size = map_layer_dict_.getGridSize(layer_id);\n    if(grid_size<0){\n      std::cout<<\"Grid size negtive\"<<std::endl;\n      return;\n    }\n\n    std::shared_ptr<Ndt3Tile> new_ndt3 =\n        std::shared_ptr<Ndt3Tile>(new Ndt3Tile());\n    ndt3_pool_[layer_id]->copyAndTransform(Tx_delta, radius, new_ndt3.get());\n    ndt3_pool_[layer_id] = new_ndt3;\n  }\n}\n\nbool LidarMapOnline::initializeLayer(int layer_id) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it != ndt3_pool_.end()) {\n    return false;  // re-initialize\n  }\n\n  float grid_size;\n  if (!map_layer_dict_.getInfoById(layer_id, nullptr, &grid_size, nullptr)) {\n    return false;\n  }\n\n  ndt3_pool_[layer_id] = std::shared_ptr<Ndt3Tile>(new Ndt3Tile(grid_size));\n\n  return true;\n}\n\nbool LidarMapOnline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  // add sample to ndt3\n  for (const auto& sample : pointcloud) {\n    ndt3_pool_it->second->addSample(sample);\n  }\n\n  return false;\n}\n\nbool LidarMapOnline::getMap(int layer_id, std::shared_ptr<Ndt3Interface>* ndt3) {\n  if (!ndt3) {\n    return false;\n  }\n\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  *ndt3 = ndt3_pool_it->second;\n  return true;\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp"
		}
	}
]
I0403 13:45:40.114213 32175 json_parser.cpp:18] 
[
	89,
	{
		"bufnr" : 14,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_online.h\"\n\nnamespace allride {\nnamespace mapping {\n\nvoid LidarMapOnline::setMapOrigin(const common::geometry::SE3& Tx_MP_map) { origin_ = Tx_MP_map; }\n\ncommon::geometry::SE3 LidarMapOnline::getMapOrigin() { return origin_; }\n\nvoid LidarMapOnline::resetMapRegion(const common::geometry::SE3& Tx_MP_V, double radius) {\n  common::geometry::SE3 Tx_delta /* = origin_.inverseCompose(Tx_MP_V) */;  // waiting for api\n\n  // first get all keys\n  std::vector<int> all_layer_ids;\n  for (const auto& pair : ndt3_pool_) {\n    all_layer_ids.emplace_back(pair.first);\n  }\n\n  // update ndt3 data of all layers\n  for (const auto& layer_id : all_layer_ids) {\n    float grid_size = map_layer_dict_.getGridSize(layer_id);\n    if(grid_size<0){\n      std::cout<<\"Grid size negtive\"<<std::endl;\n      return;\n    }\n\n    std::shared_ptr<Ndt3Tile> new_ndt3 =\n        std::shared_ptr<Ndt3Tile>(new Ndt3Tile());\n    ndt3_pool_[layer_id]->copyAndTransform(Tx_delta, radius, new_ndt3.get());\n    ndt3_pool_[layer_id] = new_ndt3;\n  }\n}\n\nbool LidarMapOnline::initializeLayer(int layer_id) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it != ndt3_pool_.end()) {\n    return false;  // re-initialize\n  }\n\n  float grid_size;\n  if (!map_layer_dict_.getInfoById(layer_id, nullptr, &grid_size, nullptr)) {\n    return false;\n  }\n\n  ndt3_pool_[layer_id] = std::shared_ptr<Ndt3Tile>(new Ndt3Tile(grid_size));\n\n  return true;\n}\n\nbool LidarMapOnline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  // add sample to ndt3\n  for (const auto& sample : pointcloud) {\n    ndt3_pool_it->second->addSample(sample);\n  }\n\n  return false;\n}\n\nbool LidarMapOnline::getMap(int layer_id, std::shared_ptr<Ndt3Interface>* ndt3) {\n  if (!ndt3) {\n    return false;\n  }\n\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  *ndt3 = ndt3_pool_it->second;\n  return true;\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp"
		}
	}
]
I0403 13:45:42.858582 32175 json_parser.cpp:18] 
[
	90,
	{
		"bufnr" : 14,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_online.h\"\n\nnamespace allride {\nnamespace mapping {\n\nvoid LidarMapOnline::setMapOrigin(const common::geometry::SE3& Tx_MP_map) { origin_ = Tx_MP_map; }\n\ncommon::geometry::SE3 LidarMapOnline::getMapOrigin() { return origin_; }\n\nvoid LidarMapOnline::resetMapRegion(const common::geometry::SE3& Tx_MP_V, double radius) {\n  common::geometry::SE3 Tx_delta /* = origin_.inverseCompose(Tx_MP_V) */;  // waiting for api\n\n  // first get all keys\n  std::vector<int> all_layer_ids;\n  for (const auto& pair : ndt3_pool_) {\n    all_layer_ids.emplace_back(pair.first);\n  }\n\n  // update ndt3 data of all layers\n  for (const auto& layer_id : all_layer_ids) {\n    float grid_size = map_layer_dict_.getGridSize(layer_id);\n    if(grid_size<0){\n      std::cout<<\"Grid size negtive\"<<std::endl;\n      return;\n    }\n\n    std::shared_ptr<Ndt3Tile> new_ndt3 =\n        std::shared_ptr<Ndt3Tile>(new Ndt3Tile(grid_size));\n    ndt3_pool_[layer_id]->copyAndTransform(Tx_delta, radius, new_ndt3.get());\n    ndt3_pool_[layer_id] = new_ndt3;\n  }\n}\n\nbool LidarMapOnline::initializeLayer(int layer_id) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it != ndt3_pool_.end()) {\n    return false;  // re-initialize\n  }\n\n  float grid_size;\n  if (!map_layer_dict_.getInfoById(layer_id, nullptr, &grid_size, nullptr)) {\n    return false;\n  }\n\n  ndt3_pool_[layer_id] = std::shared_ptr<Ndt3Tile>(new Ndt3Tile(grid_size));\n\n  return true;\n}\n\nbool LidarMapOnline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  // add sample to ndt3\n  for (const auto& sample : pointcloud) {\n    ndt3_pool_it->second->addSample(sample);\n  }\n\n  return false;\n}\n\nbool LidarMapOnline::getMap(int layer_id, std::shared_ptr<Ndt3Interface>* ndt3) {\n  if (!ndt3) {\n    return false;\n  }\n\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  *ndt3 = ndt3_pool_it->second;\n  return true;\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp"
		}
	}
]
I0403 13:46:46.580188 32175 json_parser.cpp:18] 
[
	91,
	{
		"bufnr" : 14,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_online.h\"\n\nnamespace allride {\nnamespace mapping {\n\nvoid LidarMapOnline::setMapOrigin(const common::geometry::SE3& Tx_MP_map) { origin_ = Tx_MP_map; }\n\ncommon::geometry::SE3 LidarMapOnline::getMapOrigin() { return origin_; }\n\nvoid LidarMapOnline::resetMapRegion(const common::geometry::SE3& Tx_MP_V, double radius) {\n  common::geometry::SE3 Tx_delta /* = origin_.inverseCompose(Tx_MP_V) */;  // waiting for api\n\n  // first get all keys\n  std::vector<int> all_layer_ids;\n  for (const auto& pair : ndt3_pool_) {\n    all_layer_ids.emplace_back(pair.first);\n  }\n\n  // update ndt3 data of all layers\n  for (const auto& layer_id : all_layer_ids) {\n    float grid_size = map_layer_dict_.getGridSize(layer_id);\n    if(grid_size<0){\n      std::cout<<\"Grid size negtive\"<<std::endl;\n    }\n\n    std::shared_ptr<Ndt3Tile> new_ndt3 =\n        std::shared_ptr<Ndt3Tile>(new Ndt3Tile(grid_size));\n    ndt3_pool_[layer_id]->copyAndTransform(Tx_delta, radius, new_ndt3.get());\n    ndt3_pool_[layer_id] = new_ndt3;\n  }\n}\n\nbool LidarMapOnline::initializeLayer(int layer_id) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it != ndt3_pool_.end()) {\n    return false;  // re-initialize\n  }\n\n  float grid_size;\n  if (!map_layer_dict_.getInfoById(layer_id, nullptr, &grid_size, nullptr)) {\n    return false;\n  }\n\n  ndt3_pool_[layer_id] = std::shared_ptr<Ndt3Tile>(new Ndt3Tile(grid_size));\n\n  return true;\n}\n\nbool LidarMapOnline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  // add sample to ndt3\n  for (const auto& sample : pointcloud) {\n    ndt3_pool_it->second->addSample(sample);\n  }\n\n  return false;\n}\n\nbool LidarMapOnline::getMap(int layer_id, std::shared_ptr<Ndt3Interface>* ndt3) {\n  if (!ndt3) {\n    return false;\n  }\n\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  *ndt3 = ndt3_pool_it->second;\n  return true;\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp"
		}
	}
]
I0403 13:46:46.854841 32175 json_parser.cpp:18] 
[
	92,
	{
		"bufnr" : 14,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_online.h\"\n\nnamespace allride {\nnamespace mapping {\n\nvoid LidarMapOnline::setMapOrigin(const common::geometry::SE3& Tx_MP_map) { origin_ = Tx_MP_map; }\n\ncommon::geometry::SE3 LidarMapOnline::getMapOrigin() { return origin_; }\n\nvoid LidarMapOnline::resetMapRegion(const common::geometry::SE3& Tx_MP_V, double radius) {\n  common::geometry::SE3 Tx_delta /* = origin_.inverseCompose(Tx_MP_V) */;  // waiting for api\n\n  // first get all keys\n  std::vector<int> all_layer_ids;\n  for (const auto& pair : ndt3_pool_) {\n    all_layer_ids.emplace_back(pair.first);\n  }\n\n  // update ndt3 data of all layers\n  for (const auto& layer_id : all_layer_ids) {\n    float grid_size = map_layer_dict_.getGridSize(layer_id);\n    if(grid_size<0){\n      std::cout<<\"Grid size negtive\"<<std::endl;\n      \n    }\n\n    std::shared_ptr<Ndt3Tile> new_ndt3 =\n        std::shared_ptr<Ndt3Tile>(new Ndt3Tile(grid_size));\n    ndt3_pool_[layer_id]->copyAndTransform(Tx_delta, radius, new_ndt3.get());\n    ndt3_pool_[layer_id] = new_ndt3;\n  }\n}\n\nbool LidarMapOnline::initializeLayer(int layer_id) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it != ndt3_pool_.end()) {\n    return false;  // re-initialize\n  }\n\n  float grid_size;\n  if (!map_layer_dict_.getInfoById(layer_id, nullptr, &grid_size, nullptr)) {\n    return false;\n  }\n\n  ndt3_pool_[layer_id] = std::shared_ptr<Ndt3Tile>(new Ndt3Tile(grid_size));\n\n  return true;\n}\n\nbool LidarMapOnline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  // add sample to ndt3\n  for (const auto& sample : pointcloud) {\n    ndt3_pool_it->second->addSample(sample);\n  }\n\n  return false;\n}\n\nbool LidarMapOnline::getMap(int layer_id, std::shared_ptr<Ndt3Interface>* ndt3) {\n  if (!ndt3) {\n    return false;\n  }\n\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  *ndt3 = ndt3_pool_it->second;\n  return true;\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp"
		}
	}
]
I0403 13:46:52.382863 32175 json_parser.cpp:18] 
[
	93,
	{
		"bufnr" : 14,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_online.h\"\n\nnamespace allride {\nnamespace mapping {\n\nvoid LidarMapOnline::setMapOrigin(const common::geometry::SE3& Tx_MP_map) { origin_ = Tx_MP_map; }\n\ncommon::geometry::SE3 LidarMapOnline::getMapOrigin() { return origin_; }\n\nvoid LidarMapOnline::resetMapRegion(const common::geometry::SE3& Tx_MP_V, double radius) {\n  common::geometry::SE3 Tx_delta /* = origin_.inverseCompose(Tx_MP_V) */;  // waiting for api\n\n  // first get all keys\n  std::vector<int> all_layer_ids;\n  for (const auto& pair : ndt3_pool_) {\n    all_layer_ids.emplace_back(pair.first);\n  }\n\n  // update ndt3 data of all layers\n  for (const auto& layer_id : all_layer_ids) {\n    float grid_size = map_layer_dict_.getGridSize(layer_id);\n    if(grid_size<0){\n      std::cout<<\"Grid size negtive\"<<std::endl;\n      continue;\n    }\n\n    std::shared_ptr<Ndt3Tile> new_ndt3 =\n        std::shared_ptr<Ndt3Tile>(new Ndt3Tile(grid_size));\n    ndt3_pool_[layer_id]->copyAndTransform(Tx_delta, radius, new_ndt3.get());\n    ndt3_pool_[layer_id] = new_ndt3;\n  }\n}\n\nbool LidarMapOnline::initializeLayer(int layer_id) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it != ndt3_pool_.end()) {\n    return false;  // re-initialize\n  }\n\n  float grid_size;\n  if (!map_layer_dict_.getInfoById(layer_id, nullptr, &grid_size, nullptr)) {\n    return false;\n  }\n\n  ndt3_pool_[layer_id] = std::shared_ptr<Ndt3Tile>(new Ndt3Tile(grid_size));\n\n  return true;\n}\n\nbool LidarMapOnline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  // add sample to ndt3\n  for (const auto& sample : pointcloud) {\n    ndt3_pool_it->second->addSample(sample);\n  }\n\n  return false;\n}\n\nbool LidarMapOnline::getMap(int layer_id, std::shared_ptr<Ndt3Interface>* ndt3) {\n  if (!ndt3) {\n    return false;\n  }\n\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  *ndt3 = ndt3_pool_it->second;\n  return true;\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp"
		}
	}
]
I0403 13:46:55.154120 32175 json_parser.cpp:18] 
[
	94,
	{
		"bufnr" : 14,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_online.h\"\n\nnamespace allride {\nnamespace mapping {\n\nvoid LidarMapOnline::setMapOrigin(const common::geometry::SE3& Tx_MP_map) { origin_ = Tx_MP_map; }\n\ncommon::geometry::SE3 LidarMapOnline::getMapOrigin() { return origin_; }\n\nvoid LidarMapOnline::resetMapRegion(const common::geometry::SE3& Tx_MP_V, double radius) {\n  common::geometry::SE3 Tx_delta /* = origin_.inverseCompose(Tx_MP_V) */;  // waiting for api\n\n  // first get all keys\n  std::vector<int> all_layer_ids;\n  for (const auto& pair : ndt3_pool_) {\n    all_layer_ids.emplace_back(pair.first);\n  }\n\n  // update ndt3 data of all layers\n  for (const auto& layer_id : all_layer_ids) {\n    float grid_size = map_layer_dict_.getGridSize(layer_id);\n    if(grid_size<0){\n      std::cout<<\"Grid size negtive\"<<std::endl;\n      contiue;\n    }\n\n    std::shared_ptr<Ndt3Tile> new_ndt3 =\n        std::shared_ptr<Ndt3Tile>(new Ndt3Tile(grid_size));\n    ndt3_pool_[layer_id]->copyAndTransform(Tx_delta, radius, new_ndt3.get());\n    ndt3_pool_[layer_id] = new_ndt3;\n  }\n}\n\nbool LidarMapOnline::initializeLayer(int layer_id) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it != ndt3_pool_.end()) {\n    return false;  // re-initialize\n  }\n\n  float grid_size;\n  if (!map_layer_dict_.getInfoById(layer_id, nullptr, &grid_size, nullptr)) {\n    return false;\n  }\n\n  ndt3_pool_[layer_id] = std::shared_ptr<Ndt3Tile>(new Ndt3Tile(grid_size));\n\n  return true;\n}\n\nbool LidarMapOnline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  // add sample to ndt3\n  for (const auto& sample : pointcloud) {\n    ndt3_pool_it->second->addSample(sample);\n  }\n\n  return false;\n}\n\nbool LidarMapOnline::getMap(int layer_id, std::shared_ptr<Ndt3Interface>* ndt3) {\n  if (!ndt3) {\n    return false;\n  }\n\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  *ndt3 = ndt3_pool_it->second;\n  return true;\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp"
		}
	}
]
I0403 13:46:55.650563 32175 json_parser.cpp:18] 
[
	95,
	{
		"bufnr" : 14,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_online.h\"\n\nnamespace allride {\nnamespace mapping {\n\nvoid LidarMapOnline::setMapOrigin(const common::geometry::SE3& Tx_MP_map) { origin_ = Tx_MP_map; }\n\ncommon::geometry::SE3 LidarMapOnline::getMapOrigin() { return origin_; }\n\nvoid LidarMapOnline::resetMapRegion(const common::geometry::SE3& Tx_MP_V, double radius) {\n  common::geometry::SE3 Tx_delta /* = origin_.inverseCompose(Tx_MP_V) */;  // waiting for api\n\n  // first get all keys\n  std::vector<int> all_layer_ids;\n  for (const auto& pair : ndt3_pool_) {\n    all_layer_ids.emplace_back(pair.first);\n  }\n\n  // update ndt3 data of all layers\n  for (const auto& layer_id : all_layer_ids) {\n    float grid_size = map_layer_dict_.getGridSize(layer_id);\n    if(grid_size<0){\n      std::cout<<\"Grid size negtive\"<<std::endl;\n      contie;\n    }\n\n    std::shared_ptr<Ndt3Tile> new_ndt3 =\n        std::shared_ptr<Ndt3Tile>(new Ndt3Tile(grid_size));\n    ndt3_pool_[layer_id]->copyAndTransform(Tx_delta, radius, new_ndt3.get());\n    ndt3_pool_[layer_id] = new_ndt3;\n  }\n}\n\nbool LidarMapOnline::initializeLayer(int layer_id) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it != ndt3_pool_.end()) {\n    return false;  // re-initialize\n  }\n\n  float grid_size;\n  if (!map_layer_dict_.getInfoById(layer_id, nullptr, &grid_size, nullptr)) {\n    return false;\n  }\n\n  ndt3_pool_[layer_id] = std::shared_ptr<Ndt3Tile>(new Ndt3Tile(grid_size));\n\n  return true;\n}\n\nbool LidarMapOnline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  // add sample to ndt3\n  for (const auto& sample : pointcloud) {\n    ndt3_pool_it->second->addSample(sample);\n  }\n\n  return false;\n}\n\nbool LidarMapOnline::getMap(int layer_id, std::shared_ptr<Ndt3Interface>* ndt3) {\n  if (!ndt3) {\n    return false;\n  }\n\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  *ndt3 = ndt3_pool_it->second;\n  return true;\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp"
		}
	}
]
I0403 13:46:55.838497 32175 json_parser.cpp:18] 
[
	96,
	{
		"bufnr" : 14,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_online.h\"\n\nnamespace allride {\nnamespace mapping {\n\nvoid LidarMapOnline::setMapOrigin(const common::geometry::SE3& Tx_MP_map) { origin_ = Tx_MP_map; }\n\ncommon::geometry::SE3 LidarMapOnline::getMapOrigin() { return origin_; }\n\nvoid LidarMapOnline::resetMapRegion(const common::geometry::SE3& Tx_MP_V, double radius) {\n  common::geometry::SE3 Tx_delta /* = origin_.inverseCompose(Tx_MP_V) */;  // waiting for api\n\n  // first get all keys\n  std::vector<int> all_layer_ids;\n  for (const auto& pair : ndt3_pool_) {\n    all_layer_ids.emplace_back(pair.first);\n  }\n\n  // update ndt3 data of all layers\n  for (const auto& layer_id : all_layer_ids) {\n    float grid_size = map_layer_dict_.getGridSize(layer_id);\n    if(grid_size<0){\n      std::cout<<\"Grid size negtive\"<<std::endl;\n      conti;\n    }\n\n    std::shared_ptr<Ndt3Tile> new_ndt3 =\n        std::shared_ptr<Ndt3Tile>(new Ndt3Tile(grid_size));\n    ndt3_pool_[layer_id]->copyAndTransform(Tx_delta, radius, new_ndt3.get());\n    ndt3_pool_[layer_id] = new_ndt3;\n  }\n}\n\nbool LidarMapOnline::initializeLayer(int layer_id) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it != ndt3_pool_.end()) {\n    return false;  // re-initialize\n  }\n\n  float grid_size;\n  if (!map_layer_dict_.getInfoById(layer_id, nullptr, &grid_size, nullptr)) {\n    return false;\n  }\n\n  ndt3_pool_[layer_id] = std::shared_ptr<Ndt3Tile>(new Ndt3Tile(grid_size));\n\n  return true;\n}\n\nbool LidarMapOnline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  // add sample to ndt3\n  for (const auto& sample : pointcloud) {\n    ndt3_pool_it->second->addSample(sample);\n  }\n\n  return false;\n}\n\nbool LidarMapOnline::getMap(int layer_id, std::shared_ptr<Ndt3Interface>* ndt3) {\n  if (!ndt3) {\n    return false;\n  }\n\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  *ndt3 = ndt3_pool_it->second;\n  return true;\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp"
		}
	}
]
I0403 13:46:56.085711 32175 json_parser.cpp:18] 
[
	97,
	{
		"bufnr" : 14,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_online.h\"\n\nnamespace allride {\nnamespace mapping {\n\nvoid LidarMapOnline::setMapOrigin(const common::geometry::SE3& Tx_MP_map) { origin_ = Tx_MP_map; }\n\ncommon::geometry::SE3 LidarMapOnline::getMapOrigin() { return origin_; }\n\nvoid LidarMapOnline::resetMapRegion(const common::geometry::SE3& Tx_MP_V, double radius) {\n  common::geometry::SE3 Tx_delta /* = origin_.inverseCompose(Tx_MP_V) */;  // waiting for api\n\n  // first get all keys\n  std::vector<int> all_layer_ids;\n  for (const auto& pair : ndt3_pool_) {\n    all_layer_ids.emplace_back(pair.first);\n  }\n\n  // update ndt3 data of all layers\n  for (const auto& layer_id : all_layer_ids) {\n    float grid_size = map_layer_dict_.getGridSize(layer_id);\n    if(grid_size<0){\n      std::cout<<\"Grid size negtive\"<<std::endl;\n      conti;\n    }\n\n    std::shared_ptr<Ndt3Tile> new_ndt3 =\n        std::shared_ptr<Ndt3Tile>(new Ndt3Tile(grid_size));\n    ndt3_pool_[layer_id]->copyAndTransform(Tx_delta, radius, new_ndt3.get());\n    ndt3_pool_[layer_id] = new_ndt3;\n  }\n}\n\nbool LidarMapOnline::initializeLayer(int layer_id) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it != ndt3_pool_.end()) {\n    return false;  // re-initialize\n  }\n\n  float grid_size;\n  if (!map_layer_dict_.getInfoById(layer_id, nullptr, &grid_size, nullptr)) {\n    return false;\n  }\n\n  ndt3_pool_[layer_id] = std::shared_ptr<Ndt3Tile>(new Ndt3Tile(grid_size));\n\n  return true;\n}\n\nbool LidarMapOnline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  // add sample to ndt3\n  for (const auto& sample : pointcloud) {\n    ndt3_pool_it->second->addSample(sample);\n  }\n\n  return false;\n}\n\nbool LidarMapOnline::getMap(int layer_id, std::shared_ptr<Ndt3Interface>* ndt3) {\n  if (!ndt3) {\n    return false;\n  }\n\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  *ndt3 = ndt3_pool_it->second;\n  return true;\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp"
		}
	}
]
I0403 13:46:58.516989 32175 json_parser.cpp:18] 
[
	98,
	{
		"bufnr" : 14,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_online.h\"\n\nnamespace allride {\nnamespace mapping {\n\nvoid LidarMapOnline::setMapOrigin(const common::geometry::SE3& Tx_MP_map) { origin_ = Tx_MP_map; }\n\ncommon::geometry::SE3 LidarMapOnline::getMapOrigin() { return origin_; }\n\nvoid LidarMapOnline::resetMapRegion(const common::geometry::SE3& Tx_MP_V, double radius) {\n  common::geometry::SE3 Tx_delta /* = origin_.inverseCompose(Tx_MP_V) */;  // waiting for api\n\n  // first get all keys\n  std::vector<int> all_layer_ids;\n  for (const auto& pair : ndt3_pool_) {\n    all_layer_ids.emplace_back(pair.first);\n  }\n\n  // update ndt3 data of all layers\n  for (const auto& layer_id : all_layer_ids) {\n    float grid_size = map_layer_dict_.getGridSize(layer_id);\n    if(grid_size<0){\n      std::cout<<\"Grid size negtive\"<<std::endl;\n      continue;\n    }\n\n    std::shared_ptr<Ndt3Tile> new_ndt3 =\n        std::shared_ptr<Ndt3Tile>(new Ndt3Tile(grid_size));\n    ndt3_pool_[layer_id]->copyAndTransform(Tx_delta, radius, new_ndt3.get());\n    ndt3_pool_[layer_id] = new_ndt3;\n  }\n}\n\nbool LidarMapOnline::initializeLayer(int layer_id) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it != ndt3_pool_.end()) {\n    return false;  // re-initialize\n  }\n\n  float grid_size;\n  if (!map_layer_dict_.getInfoById(layer_id, nullptr, &grid_size, nullptr)) {\n    return false;\n  }\n\n  ndt3_pool_[layer_id] = std::shared_ptr<Ndt3Tile>(new Ndt3Tile(grid_size));\n\n  return true;\n}\n\nbool LidarMapOnline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  // add sample to ndt3\n  for (const auto& sample : pointcloud) {\n    ndt3_pool_it->second->addSample(sample);\n  }\n\n  return false;\n}\n\nbool LidarMapOnline::getMap(int layer_id, std::shared_ptr<Ndt3Interface>* ndt3) {\n  if (!ndt3) {\n    return false;\n  }\n\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  *ndt3 = ndt3_pool_it->second;\n  return true;\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp"
		}
	}
]
I0403 13:47:04.258409 32175 json_parser.cpp:18] 
[
	99,
	{
		"bufnr" : 14,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_online.h\"\n\nnamespace allride {\nnamespace mapping {\n\nvoid LidarMapOnline::setMapOrigin(const common::geometry::SE3& Tx_MP_map) { origin_ = Tx_MP_map; }\n\ncommon::geometry::SE3 LidarMapOnline::getMapOrigin() { return origin_; }\n\nvoid LidarMapOnline::resetMapRegion(const common::geometry::SE3& Tx_MP_V, double radius) {\n  common::geometry::SE3 Tx_delta /* = origin_.inverseCompose(Tx_MP_V) */;  // waiting for api\n\n  // first get all keys\n  std::vector<int> all_layer_ids;\n  for (const auto& pair : ndt3_pool_) {\n    all_layer_ids.emplace_back(pair.first);\n  }\n\n  // update ndt3 data of all layers\n  for (const auto& layer_id : all_layer_ids) {\n    float grid_size = map_layer_dict_.getGridSize(layer_id);\n    if(grid_size<0){\n      std::cout<<\"Grid size negtive\"<<std::endl;\n      continu;\n    }\n\n    std::shared_ptr<Ndt3Tile> new_ndt3 =\n        std::shared_ptr<Ndt3Tile>(new Ndt3Tile(grid_size));\n    ndt3_pool_[layer_id]->copyAndTransform(Tx_delta, radius, new_ndt3.get());\n    ndt3_pool_[layer_id] = new_ndt3;\n  }\n}\n\nbool LidarMapOnline::initializeLayer(int layer_id) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it != ndt3_pool_.end()) {\n    return false;  // re-initialize\n  }\n\n  float grid_size;\n  if (!map_layer_dict_.getInfoById(layer_id, nullptr, &grid_size, nullptr)) {\n    return false;\n  }\n\n  ndt3_pool_[layer_id] = std::shared_ptr<Ndt3Tile>(new Ndt3Tile(grid_size));\n\n  return true;\n}\n\nbool LidarMapOnline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  // add sample to ndt3\n  for (const auto& sample : pointcloud) {\n    ndt3_pool_it->second->addSample(sample);\n  }\n\n  return false;\n}\n\nbool LidarMapOnline::getMap(int layer_id, std::shared_ptr<Ndt3Interface>* ndt3) {\n  if (!ndt3) {\n    return false;\n  }\n\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  *ndt3 = ndt3_pool_it->second;\n  return true;\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp"
		}
	}
]
I0403 13:47:05.165663 32175 json_parser.cpp:18] 
[
	100,
	{
		"bufnr" : 14,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_online.h\"\n\nnamespace allride {\nnamespace mapping {\n\nvoid LidarMapOnline::setMapOrigin(const common::geometry::SE3& Tx_MP_map) { origin_ = Tx_MP_map; }\n\ncommon::geometry::SE3 LidarMapOnline::getMapOrigin() { return origin_; }\n\nvoid LidarMapOnline::resetMapRegion(const common::geometry::SE3& Tx_MP_V, double radius) {\n  common::geometry::SE3 Tx_delta /* = origin_.inverseCompose(Tx_MP_V) */;  // waiting for api\n\n  // first get all keys\n  std::vector<int> all_layer_ids;\n  for (const auto& pair : ndt3_pool_) {\n    all_layer_ids.emplace_back(pair.first);\n  }\n\n  // update ndt3 data of all layers\n  for (const auto& layer_id : all_layer_ids) {\n    float grid_size = map_layer_dict_.getGridSize(layer_id);\n    if(grid_size<0){\n      std::cout<<\"Grid size negtive\"<<std::endl;\n      continu;\n    }\n\n    std::shared_ptr<Ndt3Tile> new_ndt3 =\n        std::shared_ptr<Ndt3Tile>(new Ndt3Tile(grid_size));\n    ndt3_pool_[layer_id]->copyAndTransform(Tx_delta, radius, new_ndt3.get());\n    ndt3_pool_[layer_id] = new_ndt3;\n  }\n}\n\nbool LidarMapOnline::initializeLayer(int layer_id) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it != ndt3_pool_.end()) {\n    return false;  // re-initialize\n  }\n\n  float grid_size;\n  if (!map_layer_dict_.getInfoById(layer_id, nullptr, &grid_size, nullptr)) {\n    return false;\n  }\n\n  ndt3_pool_[layer_id] = std::shared_ptr<Ndt3Tile>(new Ndt3Tile(grid_size));\n\n  return true;\n}\n\nbool LidarMapOnline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  // add sample to ndt3\n  for (const auto& sample : pointcloud) {\n    ndt3_pool_it->second->addSample(sample);\n  }\n\n  return false;\n}\n\nbool LidarMapOnline::getMap(int layer_id, std::shared_ptr<Ndt3Interface>* ndt3) {\n  if (!ndt3) {\n    return false;\n  }\n\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  *ndt3 = ndt3_pool_it->second;\n  return true;\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp"
		}
	}
]
I0403 13:47:10.756851 32175 json_parser.cpp:18] 
[
	101,
	{
		"bufnr" : 14,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_online.h\"\n\nnamespace allride {\nnamespace mapping {\n\nvoid LidarMapOnline::setMapOrigin(const common::geometry::SE3& Tx_MP_map) { origin_ = Tx_MP_map; }\n\ncommon::geometry::SE3 LidarMapOnline::getMapOrigin() { return origin_; }\n\nvoid LidarMapOnline::resetMapRegion(const common::geometry::SE3& Tx_MP_V, double radius) {\n  common::geometry::SE3 Tx_delta /* = origin_.inverseCompose(Tx_MP_V) */;  // waiting for api\n\n  // first get all keys\n  std::vector<int> all_layer_ids;\n  for (const auto& pair : ndt3_pool_) {\n    all_layer_ids.emplace_back(pair.first);\n  }\n\n  // update ndt3 data of all layers\n  for (const auto& layer_id : all_layer_ids) {\n    float grid_size = map_layer_dict_.getGridSize(layer_id);\n    if(grid_size<0){\n      std::cout<<\"Grid size negtive\"<<std::endl;\n      continue;\n    }\n\n    std::shared_ptr<Ndt3Tile> new_ndt3 =\n        std::shared_ptr<Ndt3Tile>(new Ndt3Tile(grid_size));\n    ndt3_pool_[layer_id]->copyAndTransform(Tx_delta, radius, new_ndt3.get());\n    ndt3_pool_[layer_id] = new_ndt3;\n  }\n}\n\nbool LidarMapOnline::initializeLayer(int layer_id) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it != ndt3_pool_.end()) {\n    return false;  // re-initialize\n  }\n\n  float grid_size;\n  if (!map_layer_dict_.getInfoById(layer_id, nullptr, &grid_size, nullptr)) {\n    return false;\n  }\n\n  ndt3_pool_[layer_id] = std::shared_ptr<Ndt3Tile>(new Ndt3Tile(grid_size));\n\n  return true;\n}\n\nbool LidarMapOnline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  // add sample to ndt3\n  for (const auto& sample : pointcloud) {\n    ndt3_pool_it->second->addSample(sample);\n  }\n\n  return false;\n}\n\nbool LidarMapOnline::getMap(int layer_id, std::shared_ptr<Ndt3Interface>* ndt3) {\n  if (!ndt3) {\n    return false;\n  }\n\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  *ndt3 = ndt3_pool_it->second;\n  return true;\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp"
		}
	}
]
I0403 13:49:10.689944 32175 json_parser.cpp:18] 
[
	102,
	{
		"bufnr" : 14,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_online.h\"\n\nnamespace allride {\nnamespace mapping {\n\nvoid LidarMapOnline::setMapOrigin(const common::geometry::SE3& Tx_MP_map) { origin_ = Tx_MP_map; }\n\ncommon::geometry::SE3 LidarMapOnline::getMapOrigin() { return origin_; }\n\nvoid LidarMapOnline::resetMapRegion(const common::geometry::SE3& Tx_MP_V, double radius) {\n  common::geometry::SE3 Tx_delta /* = origin_.inverseCompose(Tx_MP_V) */;  // waiting for api\n\n  // first get all keys\n  std::vector<int> all_layer_ids;\n  for (const auto& pair : ndt3_pool_) {\n    all_layer_ids.emplace_back(pair.first);\n  }\n\n  // update ndt3 data of all layers\n  for (const auto& layer_id : all_layer_ids) {\n    float grid_size = map_layer_dict_.getGridSize(layer_id);\n    if (grid_size < 0) {\n      std::cout << \"Grid size negtive\" << std::endl;\n      continue;\n    }\n\n    std::shared_ptr<Ndt3Tile> new_ndt3 = std::shared_ptr<Ndt3Tile>(new Ndt3Tile(grid_size));\n    ndt3_pool_[layer_id]->copyAndTransform(Tx_delta, radius, new_ndt3.get());\n    ndt3_pool_[layer_id] = new_ndt3;\n  }\n}\n\nbool LidarMapOnline::initializeLayer(int layer_id) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it != ndt3_pool_.end()) {\n    return false;  // re-initialize\n  }\n\n  float grid_size;\n  if (!map_layer_dict_.getInfoById(layer_id, nullptr, &grid_size, nullptr)) {\n    return false;\n  }\n\n  ndt3_pool_[layer_id] = std::shared_ptr<Ndt3Tile>(new Ndt3Tile(grid_size));\n\n  return true;\n}\n\nbool LidarMapOnline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  // add sample to ndt3\n  for (const auto& sample : pointcloud) {\n    ndt3_pool_it->second->addSample(sample);\n  }\n\n  return false;\n}\n\nbool LidarMapOnline::getMap(int layer_id, std::shared_ptr<Ndt3Interface>* ndt3) {\n  if (!ndt3) {\n    return false;\n  }\n\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  *ndt3 = ndt3_pool_it->second;\n  return true;\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp"
		}
	}
]
I0403 13:50:19.913064 32175 json_parser.cpp:18] 
[
	103,
	{
		"bufnr" : 14,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_online.h\"\n\nnamespace allride {\nnamespace mapping {\n\nvoid LidarMapOnline::setMapOrigin(const common::geometry::SE3& Tx_MP_map) { origin_ = Tx_MP_map; }\n\ncommon::geometry::SE3 LidarMapOnline::getMapOrigin() { return origin_; }\n\nvoid LidarMapOnline::resetMapRegion(const common::geometry::SE3& Tx_MP_V, double radius) {\n  common::geometry::SE3 Tx_delta /* = origin_.inverseCompose(Tx_MP_V) */;  // waiting for api\n\n  // first get all keys\n  std::vector<int> all_layer_ids;\n  for (const auto& pair : ndt3_pool_) {\n    all_layer_ids.emplace_back(pair.first);\n  }\n\n  // update ndt3 data of all layers\n  for (const auto& layer_id : all_layer_ids) {\n    float grid_size = map_layer_dict_.getGridSize(layer_id);\n    if (grid_size < 0) {\n      std::cout << \"Grid size negtive\" << std::endl;\n      continue;\n    }\n\n    std::shared_ptr<Ndt3Tile> new_ndt3 = std::shared_ptr<Ndt3Tile>(new Ndt3Tile(grid_size));\n    ndt3_pool_[layer_id]->copyAndTransform(Tx_delta, radius, new_ndt3.get());\n    ndt3_pool_[layer_id] = new_ndt3;\n  }\n}\n\nbool LidarMapOnline::initializeLayer(int layer_id) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it != ndt3_pool_.end()) {\n    return false;  // re-initialize\n  }\n\n  float grid_size;\n  if (!map_layer_dict_.getInfoById(layer_id, nullptr, &grid_size, nullptr)) {\n    return false;\n  }\n\n  ndt3_pool_[layer_id] = std::shared_ptr<Ndt3Tile>(new Ndt3Tile(grid_size));\n\n  return true;\n}\n\nbool LidarMapOnline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  // add sample to ndt3\n  for (const auto& sample : pointcloud) {\n    ndt3_pool_it->second->addSample(sample);\n  }\n\n  return false;\n}\n\nbool LidarMapOnline::getMap(int layer_id, std::shared_ptr<Ndt3Interface>* ndt3) {\n  if (!ndt3) {\n    return false;\n  }\n\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  *ndt3 = ndt3_pool_it->second;\n  return true;\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp"
		}
	}
]
I0403 13:50:21.990682 32175 json_parser.cpp:18] 
[
	104,
	{
		"bufnr" : 14,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_online.h\"\n\nnamespace allride {\nnamespace mapping {\n\nvoid LidarMapOnline::setMapOrigin(const common::geometry::SE3& Tx_MP_map) { origin_ = Tx_MP_map; }\n\ncommon::geometry::SE3 LidarMapOnline::getMapOrigin() { return origin_; }\n\nvoid LidarMapOnline::resetMapRegion(const common::geometry::SE3& Tx_MP_V, double radius) {\n  common::geometry::SE3 Tx_delta /* = origin_.inverseCompose(Tx_MP_V) */;  // waiting for api\n\n  // first get all keys\n  std::vector<int> all_layer_ids;\n  for (const auto& pair : ndt3_pool_) {\n    all_layer_ids.emplace_back(pair.first);\n  }\n\n  // update ndt3 data of all layers\n  for (const auto& layer_id : all_layer_ids) {\n    float grid_size = map_layer_dict_.getGridSize(layer_id);\n    if (grid_size < 0) {\n      std::cout << \"Grid size negtive\" << std::endl;\n      continue;\n    }\n\n    std::shared_ptr<Ndt3Tile> new_ndt3 = std::shared_ptr<Ndt3Tile>(new Ndt3Tile(grid_size));\n    ndt3_pool_[layer_id]->copyAndTransform(Tx_delta, radius, new_ndt3.get());\n    ndt3_pool_[layer_id] = new_ndt3;\n  }\n}\n\nbool LidarMapOnline::initializeLayer(int layer_id) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it != ndt3_pool_.end()) {\n    return false;  // re-initialize\n  }\n\n  float grid_size;\n  if (!map_layer_dict_.getInfoById(layer_id, nullptr, &grid_size, nullptr)) {\n    return false;\n  }\n\n  ndt3_pool_[layer_id] = std::shared_ptr<Ndt3Tile>(new Ndt3Tile(grid_size));\n\n  return true;\n}\n\nbool LidarMapOnline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  // add sample to ndt3\n  for (const auto& sample : pointcloud) {\n    ndt3_pool_it->second->addSample(sample);\n  }\n\n  return false;\n}\n\nbool LidarMapOnline::getMap(int layer_id, std::shared_ptr<Ndt3Interface>* ndt3) {\n  if (!ndt3) {\n    return false;\n  }\n\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  *ndt3 = ndt3_pool_it->second;\n  return true;\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp"
		}
	}
]
I0403 13:50:26.040979 32175 json_parser.cpp:18] 
[
	105,
	{
		"bufnr" : 14,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_online.h\"\n\nnamespace allride {\nnamespace mapping {\n\nvoid LidarMapOnline::setMapOrigin(const common::geometry::SE3& Tx_MP_map) { origin_ = Tx_MP_map; }\n\ncommon::geometry::SE3 LidarMapOnline::getMapOrigin() { return origin_; }\n\nvoid LidarMapOnline::resetMapRegion(const common::geometry::SE3& Tx_MP_V, double radius) {\n  common::geometry::SE3 Tx_delta /* = origin_.inverseCompose(Tx_MP_V) */;  // waiting for api\n\n  // first get all keys\n  std::vector<int> all_layer_ids;\n  for (const auto& pair : ndt3_pool_) {\n    all_layer_ids.emplace_back(pair.first);\n  }\n\n  // update ndt3 data of all layers\n  for (const auto& layer_id : all_layer_ids) {\n    float grid_size = map_layer_dict_.getGridSize(layer_id);\n    if (grid_size < 0) {\n      std::cout << \"Grid size negtive\" << std::endl;\n      continue;\n    }\n\n    std::shared_ptr<Ndt3Tile> new_ndt3 = std::shared_ptr<Ndt3Tile>(new Ndt3Tile(grid_size));\n    ndt3_pool_[layer_id]->copyAndTransform(Tx_delta, radius, new_ndt3.get());\n    ndt3_pool_[layer_id] = new_ndt3;\n  }\n}\n\nbool LidarMapOnline::initializeLayer(int layer_id) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it != ndt3_pool_.end()) {\n    return false;  // re-initialize\n  }\n\n  float grid_size;\n  if (!map_layer_dict_.getInfoById(layer_id, nullptr, &grid_size, nullptr)) {\n    return false;\n  }\n\n  ndt3_pool_[layer_id] = std::shared_ptr<Ndt3Tile>(new Ndt3Tile(grid_size));\n\n  return true;\n}\n\nbool LidarMapOnline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  // add sample to ndt3\n  for (const auto& sample : pointcloud) {\n    ndt3_pool_it->second->addSample(sample);\n  }\n\n  return false;\n}\n\nbool LidarMapOnline::getMap(int layer_id, std::shared_ptr<Ndt3Interface>* ndt3) {\n  if (!ndt3) {\n    return false;\n  }\n\n  auto ndt3_pool_it = ndt3_pool_.find(layer_id);\n  if (ndt3_pool_it == ndt3_pool_.end()) {\n    return false;  // layer not exist\n  }\n\n  *ndt3 = ndt3_pool_it->second;\n  return true;\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.cpp"
		}
	}
]
I0403 13:50:26.154475 32175 json_parser.cpp:18] 
[
	106,
	{
		"bufnr" : 16,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/point_types.h\"\n#include \"map_layer_dictionary_parser.h\"\n#include \"ndt3interface.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass LidarMap {\n public:\n  /// @brief configure the LidarMap class, mainly LayerID to resolution map, database path,\n  /// which are shared by all LidarMap and its decents\n  ///\n  /// @param config_file[in] the path to config file\n  ///\n  /// @return true on succeed, else false\n  ///\n  /// @note this should be called first before any operation about LidarMap\n  static bool configure(const std::string& config_file);\n\n  /// @brief initialize a layer before using it\n  ///\n  /// @param layer_id[in] specify which layer to initialize\n  ///\n  /// @return true on succeed, else false\n  virtual bool initializeLayer(int layer_id) = 0;\n\n  /// @brief add point to LidarMap on specific layer\n  ///\n  /// @param layer_id[in] specify which layer to add point cloud\n  /// @param pointcloud[in] the cloud point to add\n  ///\n  /// @return true on succeed, else false\n  virtual bool addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) = 0;\n\n protected:\n  static MapLayerDictionaryParser map_layer_dict_;\n  static std::string database_path_;\n  static int cache_range_;\n  static int cache_margin_;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map.h"
		}
	}
]
I0403 13:50:48.677927 32175 json_parser.cpp:18] 
[
	107,
	{
		"bufnr" : 13,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All rights reserved.\n// Authors: Yongjian Zhao (yongjian.zhao@allride.ai)\n\n#pragma once\n\n#include <string>\n#include <unordered_map>\n\n#include \"common/proto/config/config_map.pb.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass MapLayerDictionaryParser {\n public:\n  MapLayerDictionaryParser() = default;\n  ~MapLayerDictionaryParser() = default;\n\n  // interface for using dictionary\n  bool load(const std::string& dict_file);\n\n  bool getInfoById(const int layer_id, std::string* type_name, float* grid_size, float* tile_size);\n\n  float getGridSize(const int layer_id);\n\n  float getTileSize(const int layer_id);\n\n  std::string getTypeName(const int layer_id);\n\n  bool getIdByInfo(const std::string& type_name, const float& grid_size, const float& tile_size,\n                   int* layer_id);\n\n  // interface for making dictionary,\n  bool addItem(const int layer_id, const std::string& type_name, const float grid_size,\n               const float tile_size);\n\n  bool save(const std::string& dict_file);\n\n private:\n  void composeKey(const std::string& type_name, const float& grid_size, const float& tile_size,\n                  std::string* key);\n\n  void analyseKey(const std::string& key, std::string* type_name, float* grid_size,\n                  float* tile_size);\n\n  std::unordered_map<int, std::string> id_to_key_;\n  std::unordered_map<std::string, int> key_to_id_;\n};\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.h"
		}
	}
]
I0403 13:50:56.510926 32175 json_parser.cpp:18] 
[
	108,
	{
		"bufnr" : 16,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/point_types.h\"\n#include \"map_layer_dictionary_parser.h\"\n#include \"ndt3interface.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass LidarMap {\n public:\n  /// @brief configure the LidarMap class, mainly LayerID to resolution map, database path,\n  /// which are shared by all LidarMap and its decents\n  ///\n  /// @param config_file[in] the path to config file\n  ///\n  /// @return true on succeed, else false\n  ///\n  /// @note this should be called first before any operation about LidarMap\n  static bool configure(const std::string& config_file);\n\n  /// @brief initialize a layer before using it\n  ///\n  /// @param layer_id[in] specify which layer to initialize\n  ///\n  /// @return true on succeed, else false\n  virtual bool initializeLayer(int layer_id) = 0;\n\n  /// @brief add point to LidarMap on specific layer\n  ///\n  /// @param layer_id[in] specify which layer to add point cloud\n  /// @param pointcloud[in] the cloud point to add\n  ///\n  /// @return true on succeed, else false\n  virtual bool addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) = 0;\n\n protected:\n  static MapLayerDictionaryParser map_layer_dict_;\n  static std::string database_path_;\n  static int cache_range_;\n  static int cache_margin_;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map.h"
		}
	}
]
I0403 13:50:57.200860 32175 json_parser.cpp:18] 
[
	109,
	{
		"bufnr" : 16,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/point_types.h\"\n#include \"map_layer_dictionary_parser.h\"\n#include \"ndt3interface.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass LidarMap {\n public:\n  /// @brief configure the LidarMap class, mainly LayerID to resolution map, database path,\n  /// which are shared by all LidarMap and its decents\n  ///\n  /// @param config_file[in] the path to config file\n  ///\n  /// @return true on succeed, else false\n  ///\n  /// @note this should be called first before any operation about LidarMap\n  static bool configure(const std::string& config_file);\n\n  /// @brief initialize a layer before using it\n  ///\n  /// @param layer_id[in] specify which layer to initialize\n  ///\n  /// @return true on succeed, else false\n  virtual bool initializeLayer(int layer_id) = 0;\n\n  /// @brief add point to LidarMap on specific layer\n  ///\n  /// @param layer_id[in] specify which layer to add point cloud\n  /// @param pointcloud[in] the cloud point to add\n  ///\n  /// @return true on succeed, else false\n  virtual bool addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) = 0;\n\n protected:\n  static MapLayerDictionaryParser map_layer_dict_;\n  static std::string database_path_;\n  static int cache_range_;\n  static int cache_margin_;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map.h"
		}
	}
]
I0403 13:51:03.736819 32175 json_parser.cpp:18] 
[
	110,
	{
		"bufnr" : 16,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/point_types.h\"\n#include \"map_layer_dictionary_parser.h\"\n#include \"ndt3interface.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass LidarMap {\n public:\n  /// @brief configure the LidarMap class, mainly LayerID to resolution map, database path,\n  /// which are shared by all LidarMap and its decents\n  ///\n  /// @param config_file[in] the path to config file\n  ///\n  /// @return true on succeed, else false\n  ///\n  /// @note this should be called first before any operation about LidarMap\n  static bool configure(const std::string& config_file);\n\n  /// @brief initialize a layer before using it\n  ///\n  /// @param layer_id[in] specify which layer to initialize\n  ///\n  /// @return true on succeed, else false\n  virtual bool initializeLayer(int layer_id) = 0;\n\n  /// @brief add point to LidarMap on specific layer\n  ///\n  /// @param layer_id[in] specify which layer to add point cloud\n  /// @param pointcloud[in] the cloud point to add\n  ///\n  /// @return true on succeed, else false\n  virtual bool addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) = 0;\n\n protected:\n  static MapLayerDictionaryParser map_layer_dict_;\n  static std::string database_path_;\n  static int cache_range_;\n  static int cache_margin_;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map.h"
		}
	}
]
I0403 13:51:03.801859 32175 json_parser.cpp:18] 
[
	111,
	{
		"bufnr" : 17,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/eigen_types.h\"\n\n#include \"common/proto/config/config_map.pb.h\"\n\n#include \"lidar_map.h\"\n#include \"local_database.h\"\n#include \"map_layer.h\"\n#include \"map_scope.h\"\n#include \"ndt3interface.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass LidarMapOffline : public LidarMap {\n public:\n  /// @brief configure the LidarMapOffline class, mainly static members\n  /// which shared by all LidarMapOffline instance, such as database\n  ///\n  /// @param mode[in] specify the database operation mode, read, write, create...\n  ///\n  /// @note this should be called first before any operation about\n  /// LidarMapOffline\n  static bool configure(LocalDatabase::MODE mode);\n\n  /// @brief get the cache range(in number of tiles)\n  static int getCacheRange() { return LidarMap::cache_range_; }\n\n  /// @brief get the watermark of tile cache\n  static int getCacheMargin() { return LidarMap::cache_margin_; }\n\n  /// @brief implimention of LidarMap::initializeLayer, see LidarMap for more infomation\n  bool initializeLayer(int layer_id) override;\n\n  /// @brief initialize a layer by specify type_name, grid_size and tile\n  /// @return the layer_id of the initilized layer, if failed, a negtive number will be returned\n  int initializeLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief implimention of LidarMap::addPointCloud, see LidarMap for more infomation\n  bool addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) override;\n\n  /// @brief load the map to cache\n  /// @param[in] pos the center of the region to be loaded\n  /// @return true on succeed, else false\n  bool load(const Eigen::Vector3f& pos);\n\n  /// @brief Get the map of a layer in specific region\n  ///\n  /// @param layer_id[in] specify which layer to get\n  /// @param[in] scope specifies the submap region.\n  /// @param[in] blocking if is true, this call will block if cache miss happens,\n  /// until tiles are loaded or timeout\n  /// @param[out] ndt3 stores the map we got\n  ///\n  /// @return true on succeed, else false. we may fails when there is a cache miss\n  /// in blocking mode\n  bool getMap(int layer_id, const MapScope& scope, bool blocking,\n              std::shared_ptr<Ndt3Interface>* ndt3);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @param layer_item[in] a layer item contains nessecery infomation\n  /// to add one layer\n  ///\n  /// @return true on succeed, else false\n  bool addLayer(const proto::config::MapLayerItem& layer_item);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @return the layer id of the layer we add\n  int addLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief save the map into database\n  ///\n  /// @return true on succeed, else false\n  bool save();\n\n  /// @brief get one maplayer\n  ///\n  /// @param layer_id[in] specify which layer to get\n  ///\n  /// @return maplayer got\n  std::shared_ptr<const MapLayer> getLayer(int layer_id);\n\n  /// @brief get one maplayer\n  ///\n  /// @param type_name[in] such as ndt3_corner...\n  ///\n  /// @return map layer got\n  std::shared_ptr<const MapLayer> getLayer(const std::string& type_name, float grid_size, float tile_size);\n\n private:\n  static std::shared_ptr<LocalDatabase> database_;\n  static LocalDatabase::MODE database_operation_mode_;\n  static proto::map::MapInfo map_info_;\n\n  std::map<int, std::shared_ptr<MapLayer>> layers_;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h"
		}
	}
]
I0403 13:52:26.314502 32175 json_parser.cpp:18] 
[
	112,
	{
		"bufnr" : 17,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/eigen_types.h\"\n\n#include \"common/proto/config/config_map.pb.h\"\n\n#include \"lidar_map.h\"\n#include \"local_database.h\"\n#include \"map_layer.h\"\n#include \"map_scope.h\"\n#include \"ndt3interface.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass LidarMapOffline : public LidarMap {\n public:\n  /// @brief configure the LidarMapOffline class, mainly static members\n  /// which shared by all LidarMapOffline instance, such as database\n  ///\n  /// @param mode[in] specify the database operation mode, read, write, create...\n  ///\n  /// @note this should be called first before any operation about\n  /// LidarMapOffline\n  static bool configure(LocalDatabase::MODE mode);\n\n  /// @brief get the cache range(in number of tiles)\n  static int getCacheRange() { return LidarMap::cache_range_; }\n\n  /// @brief get the watermark of tile cache\n  static int getCacheMargin() { return LidarMap::cache_margin_; }\n\n  /// @brief implimention of LidarMap::initializeLayer, see LidarMap for more infomation\n  bool initializeLayer(int layer_id) override;\n\n  /// @brief initialize a layer by specify type_name, grid_size and tile\n  /// @return the layer_id of the initilized layer, if failed, a negtive number will be returned\n  int initializeLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief implimention of LidarMap::addPointCloud, see LidarMap for more infomation\n  bool addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) override;\n\n  /// @brief load the map to cache\n  /// @param[in] pos the center of the region to be loaded\n  /// @return true on succeed, else false\n  bool load(const Eigen::Vector3f& pos);\n\n  /// @brief Get the map of a layer in specific region\n  ///\n  /// @param layer_id[in] specify which layer to get\n  /// @param[in] scope specifies the submap region.\n  /// @param[in] blocking if is true, this call will block if cache miss happens,\n  /// until tiles are loaded or timeout\n  /// @param[out] ndt3 stores the map we got\n  ///\n  /// @return true on succeed, else false. we may fails when there is a cache miss\n  /// in blocking mode\n  bool getMap(int layer_id, const MapScope& scope, bool blocking,\n              std::shared_ptr<Ndt3Interface>* ndt3);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @param layer_item[in] a layer item contains nessecery infomation\n  /// to add one layer\n  ///\n  /// @return true on succeed, else false\n  bool addLayer(const proto::config::MapLayerItem& layer_item);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @return the layer id of the layer we add\n  int addLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief save the map into database\n  ///\n  /// @return true on succeed, else false\n  bool save();\n\n  /// @brief get one maplayer\n  ///\n  /// @param layer_id[in] specify which layer to get\n  ///\n  /// @return maplayer got\n  std::shared_ptr<const MapLayer> getLayer(int layer_id);\n\n  /// @brief get one maplayer\n  ///\n  /// @param type_name[in] such as ndt3_corner...\n  ///\n  /// @return map layer got\n  std::shared_ptr<const MapLayer> getLayer(const std::string& type_name, float grid_size, float tile_size);\n\n private:\n  static std::shared_ptr<LocalDatabase> database_;\n  static LocalDatabase::MODE database_operation_mode_;\n  static proto::map::MapInfo map_info_;\n\n  std::map<int, std::shared_ptr<MapLayer>> layers_;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h"
		}
	}
]
I0403 13:52:26.404197 32175 json_parser.cpp:18] 
[
	113,
	{
		"bufnr" : 18,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/geometry/se3.h\"\n#include \"common/math/point_types.h\"\n\n#include \"lidar_map.h\"\n#include \"ndt3tile.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass LidarMapOnline : public LidarMap {\n public:\n  /// @brief set pose(relative to global map) of the local map\n  ///\n  /// @param[in] Tx_MP_map is the origin to be set\n  void setMapOrigin(const common::geometry::SE3& Tx_MP_map);\n\n  /// @brief get pose(relative to global map) of the local map\n  ///\n  /// @return the origin of the local map\n  common::geometry::SE3 getMapOrigin();\n\n  /// @brief reset the local map to a new region\n  ///\n  /// @param[in] Tx_MP_V is the region center\n  ///\n  /// @param[in] radius is the region radius\n  void resetMapRegion(const common::geometry::SE3& Tx_MP_V, double radius);\n\n  /// @brief implemention of LidarMap::initializeLayer\n  ///\n  /// @see LidarMap for more infomation\n  bool initializeLayer(int layer_id) override;\n\n  /// @brief implemention of LidarMap::addPointCloud\n  ///\n  /// @see LidarMap for more infomation\n  bool addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) override;\n\n  /// @brief get map of specific layer\n  ///\n  /// @param layer_id[in] specify which layer to get\n  /// @param ndt3[out] store the got map data\n  ///\n  /// @return true on succeed, else false\n  bool getMap(int layer_id, std::shared_ptr<Ndt3Interface>* ndt3);\n\n private:\n  std::map<int, std::shared_ptr<Ndt3Tile>> ndt3_pool_;\n  common::geometry::SE3 origin_;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_online.h"
		}
	}
]
I0403 13:56:14.433032 32175 json_parser.cpp:18] 
[
	114,
	{
		"bufnr" : 5,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/ndt3tile.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include <unordered_map>\n#include <unordered_set>\n\n#include \"common/geometry/se3.h\"\n#include \"common/geometry/so3.h\"\n#include \"common/math/eigen_types.h\"\n#include \"common/math/point_types.h\"\n#include \"sensor_msgs/PointCloud2.h\"\n\n#include \"ndt3interface.h\"\n#include \"tile_data_storage.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass Ndt3TileMulti;\n\nclass Ndt3Tile : public Ndt3Interface {\n public:\n  enum NormalType { Plane = 0, Line };\n\n  friend class Ndt3TileMulti;\n\n  /// @brief construct a Ndt3Tile given grid_size\n  Ndt3Tile(float grid_size);\n\n  /// @brief construct a Ndt3Tile given grid_size and storage\n  Ndt3Tile(float grid_size, std::shared_ptr<TileDataStorage> storage);\n\n  /// @brief implemention of the Ndt3Interface::getMeans\n  std::shared_ptr<MapMatrixArray> getMeans() const override;\n\n  /// @brief implemention of the Ndt3Interface::getCovariances\n  std::shared_ptr<MapMatrixArray> getCovariances() const override;\n\n  /// @brief implemention of the Ndt3Interface::getCounts\n  std::shared_ptr<MapMatrixArray> getCounts() const override;\n\n  /// @brief implemention of the Ndt3Interface::getScales\n  std::shared_ptr<MapMatrixArray> getScales() const override;\n\n  /// @brief implemention of the Ndt3Interface::getNormals\n  std::shared_ptr<MapMatrixArray> getNormals() const override;\n\n  /// @brief implemention of the Ndt3Interface::getEigenvalues\n  std::shared_ptr<MapMatrixArray> getEigenvalues() const override;\n\n  /// @brief implemention of the Ndt3Interface::getIntensities\n  std::shared_ptr<MapMatrixArray> getIntensities() const override;\n\n  /// @brief implemention of the Ndt3Interface::getMean\n  bool getMean(const Eigen::Vector3f& pos, Eigen::Vector3f* mean) const override;\n\n  /// @brief implemention of the Ndt3Interface::getCovariance\n  bool getCovariance(const Eigen::Vector3f& pos, Eigen::Matrix3f* cov) const override;\n\n  /// @brief implemention of the Ndt3Interface::getCount\n  bool getCount(const Eigen::Vector3f& pos, float* count) const override;\n\n  /// @brief implemention of the Ndt3Interface::getScale\n  bool getScale(const Eigen::Vector3f& pos, float* scale) const override;\n\n  /// @brief implemention of the Ndt3Interface::getNormal\n  bool getNormal(const Eigen::Vector3f& pos, Eigen::Vector3f* normal) const override;\n\n  /// @brief implemention of the Ndt3Interface::getEigenvalue\n  bool getEigenvalue(const Eigen::Vector3f& pos, Eigen::Vector3f* eigen) const override;\n\n  /// @brief implemention of the Ndt3Interface::getIntensity\n  bool getIntensity(const Eigen::Vector3f& pos, float* intensity) const override;\n\n  /// @brief add a sample\n  ///\n  /// @param sample[in] sample contains x,y,z,intensity\n  void addSample(const common::PointXYZI& sample);\n\n  /// @brief add(merge) a already exist gaussian distribution\n  ///\n  /// @param mean[in] position mean\n  /// @param covariance[in] position covariance\n  /// @param count[in] number of sample\n  /// @param intensity[in] average intensity\n  void addGaussian(const Eigen::Vector3f& mean, const Eigen::Matrix3f& covariance, int count,\n                   float intensity);\n\n  /// @brief Deserialize from protobuf string\n  ///\n  /// @param packeded_string[in] store the serialized string\n  ///\n  /// @return true on succeed, else false\n  bool unpackFromString(const std::string& packeded_string);\n\n  /// @brief Serialize to protobuf string\n  ///\n  /// @param packed_string[out] store the serialized string\n  ///\n  /// @return true on succeed, else false\n  bool packToString(std::string* packed_string) const;\n\n  /// @brief build the grid_id to index mapping\n  ///\n  /// @return true on succeed, else false\n  // bool buildGridIndexMapping();\n\n  /// @brief\n  ///\n  /// @param sensor_noise_var\n  void computeAllNormalsAndEigenvalues(double sensor_noise_var);\n\n  /// @brief\n  ///\n  /// @param sensor_noise_var\n  void computeAllPrincipalAxisAndEigenvalues(double sensor_noise_var);\n\n  /// @brief\n  ///\n  /// @param Tx_MP_V\n  /// @param radius\n  void resetRegion(const common::geometry::SE3& Tx_MP_V, double radius);\n\n  /// @brief get the internal storage\n  ///\n  /// @return the internal storage got\n  std::shared_ptr<const TileDataStorage> getStorage() { return storage_; }\n\n  /// @brief copy from other Ndt3Tile\n  ///\n  /// @param copy_data[in] the other Ndt3Tile\n  void copy(Ndt3Tile* copy_data) const;\n\n  /// @brief copy from other Ndt3Tile in specific region\n  ///\n  /// @param Tx[in] specify the region center\n  /// @param radius[in] specify the region range\n  /// @param copy_data[in] the other Ndt3Tile\n  void copyAndTransform(const common::geometry::SE3& Tx, double radius, Ndt3Tile* copy_data) const;\n\n  /* temporary comment out for compilation\n  bool toRosMsgPointCloud2(const std::string& frame, const Time& time,\n                           sensor_msgs::PointCloud2* point_cloud,\n                           const geometry::SE3& Tx = geometry::SE3()) const;\n                           */\n\n private:\n  TileDataStorage::GridID getGridID(const Eigen::Vector3f& pos) const;\n\n  TileDataStorage::GridID getGridID(const Eigen::Vector3f& pos, float scale) const;\n\n  bool getIndex(const Eigen::Vector3f& pos, int* index) const;\n\n  TileDataStorage::MapMatrix getMeansInner() const;\n\n  TileDataStorage::MapMatrix getCovariancesInner() const;\n\n  TileDataStorage::MapMatrix getCountsInner() const;\n\n  TileDataStorage::MapMatrix getScalesInner() const;\n\n  TileDataStorage::MapMatrix getNormalsInner() const;\n\n  TileDataStorage::MapMatrix getEigenvaluesInner() const;\n\n  TileDataStorage::MapMatrix getIntensitiesInner() const;\n\n  Eigen::Vector3f getMean(int index) const;\n\n  Eigen::Matrix3f getCovariance(int index) const;\n\n  float getCount(int index) const;\n\n  float getScale(int index) const;\n\n  Eigen::Vector3f getNormal(int index) const;\n\n  Eigen::Vector3f getEigenvalue(int index) const;\n\n  float getIntensity(int index) const;\n\n  bool setMean(int index, const Eigen::Vector3f& mean);\n\n  bool setCovariance(int index, const Eigen::Matrix3f& covariance);\n\n  bool setCount(int index, float count);\n\n  bool setScale(int index, float scale);\n\n  bool setNormal(int index, const Eigen::Vector3f& normal);\n\n  bool setEigenvalue(int index, const Eigen::Vector3f& eigenvalue);\n\n  bool setIntensity(int index, float intensity);\n\n  void initializeGaussian(const Eigen::Vector3f& mean, const Eigen::Matrix3f& covariance, int count,\n                          float scale);\n\n  void computeNormalAndEigenvalues(int index, double sensor_noise_var,\n                                   NormalType normal_type = Plane);\n\n  static const std::vector<TileDataStorage::NameSizePair> kChannelNameAndSize;\n\n  static const int kTotalNumberOfRows;\n\n  std::unordered_set<int> indices_to_compute_normal_;\n\n  std::shared_ptr<TileDataStorage> storage_;\n\n  float grid_size_;\n};\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/ndt3tile.h"
		}
	}
]
I0403 13:56:34.305068 32175 json_parser.cpp:18] 
[
	115,
	{
		"bufnr" : 5,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/ndt3tile.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include <unordered_map>\n#include <unordered_set>\n\n#include \"common/geometry/se3.h\"\n#include \"common/geometry/so3.h\"\n#include \"common/math/eigen_types.h\"\n#include \"common/math/point_types.h\"\n#include \"sensor_msgs/PointCloud2.h\"\n\n#include \"ndt3interface.h\"\n#include \"tile_data_storage.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass Ndt3TileMulti;\n\nclass Ndt3Tile : public Ndt3Interface {\n public:\n  enum NormalType { Plane = 0, Line };\n\n  friend class Ndt3TileMulti;\n\n  /// @brief construct a Ndt3Tile given grid_size\n  Ndt3Tile(float grid_size);\n\n  /// @brief construct a Ndt3Tile given grid_size and storage\n  Ndt3Tile(float grid_size, std::shared_ptr<TileDataStorage> storage);\n\n  /// @brief implemention of the Ndt3Interface::getMeans\n  std::shared_ptr<MapMatrixArray> getMeans() const override;\n\n  /// @brief implemention of the Ndt3Interface::getCovariances\n  std::shared_ptr<MapMatrixArray> getCovariances() const override;\n\n  /// @brief implemention of the Ndt3Interface::getCounts\n  std::shared_ptr<MapMatrixArray> getCounts() const override;\n\n  /// @brief implemention of the Ndt3Interface::getScales\n  std::shared_ptr<MapMatrixArray> getScales() const override;\n\n  /// @brief implemention of the Ndt3Interface::getNormals\n  std::shared_ptr<MapMatrixArray> getNormals() const override;\n\n  /// @brief implemention of the Ndt3Interface::getEigenvalues\n  std::shared_ptr<MapMatrixArray> getEigenvalues() const override;\n\n  /// @brief implemention of the Ndt3Interface::getIntensities\n  std::shared_ptr<MapMatrixArray> getIntensities() const override;\n\n  /// @brief implemention of the Ndt3Interface::getMean\n  bool getMean(const Eigen::Vector3f& pos, Eigen::Vector3f* mean) const override;\n\n  /// @brief implemention of the Ndt3Interface::getCovariance\n  bool getCovariance(const Eigen::Vector3f& pos, Eigen::Matrix3f* cov) const override;\n\n  /// @brief implemention of the Ndt3Interface::getCount\n  bool getCount(const Eigen::Vector3f& pos, float* count) const override;\n\n  /// @brief implemention of the Ndt3Interface::getScale\n  bool getScale(const Eigen::Vector3f& pos, float* scale) const override;\n\n  /// @brief implemention of the Ndt3Interface::getNormal\n  bool getNormal(const Eigen::Vector3f& pos, Eigen::Vector3f* normal) const override;\n\n  /// @brief implemention of the Ndt3Interface::getEigenvalue\n  bool getEigenvalue(const Eigen::Vector3f& pos, Eigen::Vector3f* eigen) const override;\n\n  /// @brief implemention of the Ndt3Interface::getIntensity\n  bool getIntensity(const Eigen::Vector3f& pos, float* intensity) const override;\n\n  /// @brief add a sample\n  ///\n  /// @param sample[in] sample contains x,y,z,intensity\n  void addSample(const common::PointXYZI& sample);\n\n  /// @brief add(merge) a already exist gaussian distribution\n  ///\n  /// @param mean[in] position mean\n  /// @param covariance[in] position covariance\n  /// @param count[in] number of sample\n  /// @param intensity[in] average intensity\n  void addGaussian(const Eigen::Vector3f& mean, const Eigen::Matrix3f& covariance, int count,\n                   float intensity);\n\n  /// @brief Deserialize from protobuf string\n  ///\n  /// @param packeded_string[in] store the serialized string\n  ///\n  /// @return true on succeed, else false\n  bool unpackFromString(const std::string& packeded_string);\n\n  /// @brief Serialize to protobuf string\n  ///\n  /// @param packed_string[out] store the serialized string\n  ///\n  /// @return true on succeed, else false\n  bool packToString(std::string* packed_string) const;\n\n  /// @brief build the grid_id to index mapping\n  ///\n  /// @return true on succeed, else false\n  // bool buildGridIndexMapping();\n\n  /// @brief\n  ///\n  /// @param sensor_noise_var\n  void computeAllNormalsAndEigenvalues(double sensor_noise_var);\n\n  /// @brief\n  ///\n  /// @param sensor_noise_var\n  void computeAllPrincipalAxisAndEigenvalues(double sensor_noise_var);\n\n  /// @brief\n  ///\n  /// @param Tx_MP_V\n  /// @param radius\n  void resetRegion(const common::geometry::SE3& Tx_MP_V, double radius);\n\n  /// @brief get the internal storage\n  ///\n  /// @return the internal storage got\n  std::shared_ptr<const TileDataStorage> getStorage() { return storage_; }\n\n  /// @brief copy from other Ndt3Tile\n  ///\n  /// @param copy_data[in] the other Ndt3Tile\n  void copy(Ndt3Tile* copy_data) const;\n\n  /// @brief copy from other Ndt3Tile in specific region\n  ///\n  /// @param Tx[in] specify the region center\n  /// @param radius[in] specify the region range\n  /// @param copy_data[in] the other Ndt3Tile\n  void copyAndTransform(const common::geometry::SE3& Tx, double radius, Ndt3Tile* copy_data) const;\n\n  /* temporary comment out for compilation\n  bool toRosMsgPointCloud2(const std::string& frame, const Time& time,\n                           sensor_msgs::PointCloud2* point_cloud,\n                           const geometry::SE3& Tx = geometry::SE3()) const;\n                           */\n\n private:\n  TileDataStorage::GridID getGridID(const Eigen::Vector3f& pos) const;\n\n  TileDataStorage::GridID getGridID(const Eigen::Vector3f& pos, float scale) const;\n\n  bool getIndex(const Eigen::Vector3f& pos, int* index) const;\n\n  TileDataStorage::MapMatrix getMeansInner() const;\n\n  TileDataStorage::MapMatrix getCovariancesInner() const;\n\n  TileDataStorage::MapMatrix getCountsInner() const;\n\n  TileDataStorage::MapMatrix getScalesInner() const;\n\n  TileDataStorage::MapMatrix getNormalsInner() const;\n\n  TileDataStorage::MapMatrix getEigenvaluesInner() const;\n\n  TileDataStorage::MapMatrix getIntensitiesInner() const;\n\n  Eigen::Vector3f getMean(int index) const;\n\n  Eigen::Matrix3f getCovariance(int index) const;\n\n  float getCount(int index) const;\n\n  float getScale(int index) const;\n\n  Eigen::Vector3f getNormal(int index) const;\n\n  Eigen::Vector3f getEigenvalue(int index) const;\n\n  float getIntensity(int index) const;\n\n  bool setMean(int index, const Eigen::Vector3f& mean);\n\n  bool setCovariance(int index, const Eigen::Matrix3f& covariance);\n\n  bool setCount(int index, float count);\n\n  bool setScale(int index, float scale);\n\n  bool setNormal(int index, const Eigen::Vector3f& normal);\n\n  bool setEigenvalue(int index, const Eigen::Vector3f& eigenvalue);\n\n  bool setIntensity(int index, float intensity);\n\n  void initializeGaussian(const Eigen::Vector3f& mean, const Eigen::Matrix3f& covariance, int count,\n                          float scale);\n\n  void computeNormalAndEigenvalues(int index, double sensor_noise_var,\n                                   NormalType normal_type = Plane);\n\n  static const std::vector<TileDataStorage::NameSizePair> kChannelNameAndSize;\n\n  static const int kTotalNumberOfRows;\n\n  std::unordered_set<int> indices_to_compute_normal_;\n\n  std::shared_ptr<TileDataStorage> storage_;\n\n  float grid_size_;\n};\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/ndt3tile.h"
		}
	}
]
I0403 13:56:34.418284 32175 json_parser.cpp:18] 
[
	116,
	{
		"bufnr" : 19,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/map_layer.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include <mutex>\n#include <unordered_map>\n\n#include \"common/math/point_types.h\"\n#include \"local_database.h\"\n#include \"map_scope.h\"\n#include \"ndt3tile.h\"\n#include \"ndt3tile_multi.h\"\n#include \"tile_cache.h\"\n#include \"tile_client.h\"\n#include \"tiler.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass MapLayer {\n public:\n  /// @brief initialize the map layer\n  ///\n  /// @param layer_info[in] LayerInfo to initialize a MapLayer\n  /// @param database[in] database to be used by layer\n  ///\n  /// @return true on succeed, else false\n  bool initialize(const proto::map::MapLayerInfo& layer_info,\n                  const std::shared_ptr<LocalDatabase>& database);\n\n  /// @brief load data to cache from database\n  ///\n  /// @param[in] pos the center of the region to be loaded\n  ///\n  /// @return true on succeed, else false\n  bool load(const Eigen::Vector3f& pos);\n\n  /// @brief get all the tiles of a specific region\n  ///\n  /// @param[in] scope specify the region\n  /// @param[in] blocking if blocking is set, we will wait when cache miss happens\n  /// @param[out] tiles tile pointers stored in an unordered_map\n  ///\n  /// @return true on succeed, else false. we may fail when cache miss and blocking\n  /// is set to false\n  bool getMap(const MapScope& scope, bool blocking, std::shared_ptr<Ndt3Interface>* ndt3);\n\n  /// @brief add point cloud in to layer(when building map)\n  ///\n  /// @param pointcloud[in] point cloud to add\n  ///\n  /// @return true on succeed, else false\n  bool addPointCloud(const common::PointCloudXYZI& pointcloud);\n\n  /// @brief save to data to database\n  ///\n  /// @return true on succeed, else false\n  bool save();\n\n  /// @brief get all the ndt3tile of a layer, used when building map\n  ///\n  /// @return a const ref of the ndt3hash\n  const Ndt3TileMulti::Ndt3Hash& getAllNdt3();\n\n private:\n  bool initialized_ = false;\n  std::unique_ptr<Tiler> tiler_;\n  std::shared_ptr<TileClient> tile_client_;\n  std::unique_ptr<TileCache> tile_cache_;\n  proto::map::MapLayerInfo layer_info_;\n  Ndt3TileMulti::Ndt3Hash tile_pool_;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/map_layer.h"
		}
	}
]
I0403 13:56:57.466456 32175 json_parser.cpp:18] 
[
	117,
	{
		"bufnr" : 19,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/map_layer.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include <mutex>\n#include <unordered_map>\n\n#include \"common/math/point_types.h\"\n#include \"local_database.h\"\n#include \"map_scope.h\"\n#include \"ndt3tile.h\"\n#include \"ndt3tile_multi.h\"\n#include \"tile_cache.h\"\n#include \"tile_client.h\"\n#include \"tiler.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass MapLayer {\n public:\n  /// @brief initialize the map layer\n  ///\n  /// @param layer_info[in] LayerInfo to initialize a MapLayer\n  /// @param database[in] database to be used by layer\n  ///\n  /// @return true on succeed, else false\n  bool initialize(const proto::map::MapLayerInfo& layer_info,\n                  const std::shared_ptr<LocalDatabase>& database);\n\n  /// @brief load data to cache from database\n  ///\n  /// @param[in] pos the center of the region to be loaded\n  ///\n  /// @return true on succeed, else false\n  bool load(const Eigen::Vector3f& pos);\n\n  /// @brief get all the tiles of a specific region\n  ///\n  /// @param[in] scope specify the region\n  /// @param[in] blocking if blocking is set, we will wait when cache miss happens\n  /// @param[out] tiles tile pointers stored in an unordered_map\n  ///\n  /// @return true on succeed, else false. we may fail when cache miss and blocking\n  /// is set to false\n  bool getMap(const MapScope& scope, bool blocking, std::shared_ptr<Ndt3Interface>* ndt3);\n\n  /// @brief add point cloud in to layer(when building map)\n  ///\n  /// @param pointcloud[in] point cloud to add\n  ///\n  /// @return true on succeed, else false\n  bool addPointCloud(const common::PointCloudXYZI& pointcloud);\n\n  /// @brief save to data to database\n  ///\n  /// @return true on succeed, else false\n  bool save();\n\n  /// @brief get all the ndt3tile of a layer, used when building map\n  ///\n  /// @return a const ref of the ndt3hash\n  const Ndt3TileMulti::Ndt3Hash& getAllNdt3();\n\n private:\n  bool initialized_ = false;\n  std::unique_ptr<Tiler> tiler_;\n  std::shared_ptr<TileClient> tile_client_;\n  std::unique_ptr<TileCache> tile_cache_;\n  proto::map::MapLayerInfo layer_info_;\n  Ndt3TileMulti::Ndt3Hash tile_pool_;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/map_layer.h"
		}
	}
]
I0403 13:56:57.585678 32175 json_parser.cpp:18] 
[
	118,
	{
		"bufnr" : 20,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/ndt3interface.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/eigen_types.h\"\n#include \"tile_data_storage.h\"\n\nnamespace allride {\nnamespace mapping {\n\n/// @brief Define the interface to utilize the Ndt3Data(s).\nclass Ndt3Interface {\n public:\n  typedef std::vector<TileDataStorage::MapMatrix,\n                      Eigen::aligned_allocator<TileDataStorage::MapMatrix>>\n      MapMatrixArray;\n\n  /// @brief get the means of all existing grids in the Ndt3Data(s)\n  ///\n  /// @return an array of the means stored in an Eigen::map\n  virtual std::shared_ptr<MapMatrixArray> getMeans() const = 0;\n\n  /// @brief get the covariances of all existing grids in the Ndt3Data(s)\n  ///\n  /// @return an array of the covariances stored in an Eigen::map\n  virtual std::shared_ptr<MapMatrixArray> getCovariances() const = 0;\n\n  /// @brief get the counts of all existing grids in the Ndt3Data(s)\n  ///\n  /// @return an array of the counts stored in an Eigen::map\n  virtual std::shared_ptr<MapMatrixArray> getCounts() const = 0;\n\n  /// @brief get the scales of all existing grids in the Ndt3Data(s)\n  ///\n  /// @return an array of the scales stored in an Eigen::map\n  virtual std::shared_ptr<MapMatrixArray> getScales() const = 0;\n\n  /// @brief get the normals of all existing grids in the Ndt3Data(s)\n  ///\n  /// @return an array of the normals stored in an Eigen::map\n  virtual std::shared_ptr<MapMatrixArray> getNormals() const = 0;\n\n  /// @brief get the eigen values of all existing grids in the Ndt3Data(s)\n  ///\n  /// @return an array of the eigen values stored in an Eigen::map\n  virtual std::shared_ptr<MapMatrixArray> getEigenvalues() const = 0;\n\n  /// @brief get the intensities of all existing grids in the Ndt3Data(s)\n  ///\n  /// @return an array of the intensities stored in an Eigen::map\n  virtual std::shared_ptr<MapMatrixArray> getIntensities() const = 0;\n\n  /// @brief get the mean of a grid specified by a position\n  ///\n  /// @param[in] pos the point which the querying grid contains\n  /// @param[out] mean stores the mean got\n  ///\n  /// @return true if the querying grid exists, else false\n  virtual bool getMean(const Eigen::Vector3f& pos, Eigen::Vector3f* mean) const = 0;\n\n  /// @brief get the covariance of a grid specified by a position\n  ///\n  /// @param[in] pos the point which the querying grid contains\n  /// @param[out] cov stores the covariance got\n  ///\n  /// @return true if the querying grid exists, else false\n  virtual bool getCovariance(const Eigen::Vector3f& pos, Eigen::Matrix3f* cov) const = 0;\n\n  /// @brief get the covariance of a grid specified by a position\n  ///\n  /// @param[in] pos the point which the querying grid contains\n  /// @param[out] cov stores the covariance got\n  ///\n  /// @return true if the querying grid exists, else false\n  virtual bool getCount(const Eigen::Vector3f& pos, float* count) const = 0;\n\n  /// @brief get the covariance of a grid specified by a position\n  ///\n  /// @param[in] pos the point which the querying grid contains\n  /// @param[out] cov stores the covariance got\n  ///\n  /// @return true if the querying grid exists, else false\n  virtual bool getScale(const Eigen::Vector3f& pos, float* scale) const = 0;\n\n  /// @brief get the normal of a grid specified by a position\n  ///\n  /// @param[in] pos the point which the querying grid contains\n  /// @param[out] cov stores the normal got\n  ///\n  /// @return true if the querying grid exists, else false\n  virtual bool getNormal(const Eigen::Vector3f& pos, Eigen::Vector3f* normal) const = 0;\n\n  /// @brief get the eigen value of a grid specified by a position\n  ///\n  /// @param[in] pos the point which the querying grid contains\n  /// @param[out] cov stores the eigen value got\n  ///\n  /// @return true if the querying grid exists, else false\n  virtual bool getEigenvalue(const Eigen::Vector3f& pos, Eigen::Vector3f* eigen) const = 0;\n\n  /// @brief get the intensity of a grid specified by a position\n  ///\n  /// @param[in] pos the point which the querying grid contains\n  /// @param[out] cov stores the intensity got\n  ///\n  /// @return true if the querying grid exists, else false\n  virtual bool getIntensity(const Eigen::Vector3f& pos, float* intensity) const = 0;\n};\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/ndt3interface.h"
		}
	}
]
I0403 13:57:03.504364 32175 json_parser.cpp:18] 
[
	119,
	{
		"bufnr" : 20,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/ndt3interface.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/eigen_types.h\"\n#include \"tile_data_storage.h\"\n\nnamespace allride {\nnamespace mapping {\n\n/// @brief Define the interface to utilize the Ndt3Data(s).\nclass Ndt3Interface {\n public:\n  typedef std::vector<TileDataStorage::MapMatrix,\n                      Eigen::aligned_allocator<TileDataStorage::MapMatrix>>\n      MapMatrixArray;\n\n  /// @brief get the means of all existing grids in the Ndt3Data(s)\n  ///\n  /// @return an array of the means stored in an Eigen::map\n  virtual std::shared_ptr<MapMatrixArray> getMeans() const = 0;\n\n  /// @brief get the covariances of all existing grids in the Ndt3Data(s)\n  ///\n  /// @return an array of the covariances stored in an Eigen::map\n  virtual std::shared_ptr<MapMatrixArray> getCovariances() const = 0;\n\n  /// @brief get the counts of all existing grids in the Ndt3Data(s)\n  ///\n  /// @return an array of the counts stored in an Eigen::map\n  virtual std::shared_ptr<MapMatrixArray> getCounts() const = 0;\n\n  /// @brief get the scales of all existing grids in the Ndt3Data(s)\n  ///\n  /// @return an array of the scales stored in an Eigen::map\n  virtual std::shared_ptr<MapMatrixArray> getScales() const = 0;\n\n  /// @brief get the normals of all existing grids in the Ndt3Data(s)\n  ///\n  /// @return an array of the normals stored in an Eigen::map\n  virtual std::shared_ptr<MapMatrixArray> getNormals() const = 0;\n\n  /// @brief get the eigen values of all existing grids in the Ndt3Data(s)\n  ///\n  /// @return an array of the eigen values stored in an Eigen::map\n  virtual std::shared_ptr<MapMatrixArray> getEigenvalues() const = 0;\n\n  /// @brief get the intensities of all existing grids in the Ndt3Data(s)\n  ///\n  /// @return an array of the intensities stored in an Eigen::map\n  virtual std::shared_ptr<MapMatrixArray> getIntensities() const = 0;\n\n  /// @brief get the mean of a grid specified by a position\n  ///\n  /// @param[in] pos the point which the querying grid contains\n  /// @param[out] mean stores the mean got\n  ///\n  /// @return true if the querying grid exists, else false\n  virtual bool getMean(const Eigen::Vector3f& pos, Eigen::Vector3f* mean) const = 0;\n\n  /// @brief get the covariance of a grid specified by a position\n  ///\n  /// @param[in] pos the point which the querying grid contains\n  /// @param[out] cov stores the covariance got\n  ///\n  /// @return true if the querying grid exists, else false\n  virtual bool getCovariance(const Eigen::Vector3f& pos, Eigen::Matrix3f* cov) const = 0;\n\n  /// @brief get the covariance of a grid specified by a position\n  ///\n  /// @param[in] pos the point which the querying grid contains\n  /// @param[out] cov stores the covariance got\n  ///\n  /// @return true if the querying grid exists, else false\n  virtual bool getCount(const Eigen::Vector3f& pos, float* count) const = 0;\n\n  /// @brief get the covariance of a grid specified by a position\n  ///\n  /// @param[in] pos the point which the querying grid contains\n  /// @param[out] cov stores the covariance got\n  ///\n  /// @return true if the querying grid exists, else false\n  virtual bool getScale(const Eigen::Vector3f& pos, float* scale) const = 0;\n\n  /// @brief get the normal of a grid specified by a position\n  ///\n  /// @param[in] pos the point which the querying grid contains\n  /// @param[out] cov stores the normal got\n  ///\n  /// @return true if the querying grid exists, else false\n  virtual bool getNormal(const Eigen::Vector3f& pos, Eigen::Vector3f* normal) const = 0;\n\n  /// @brief get the eigen value of a grid specified by a position\n  ///\n  /// @param[in] pos the point which the querying grid contains\n  /// @param[out] cov stores the eigen value got\n  ///\n  /// @return true if the querying grid exists, else false\n  virtual bool getEigenvalue(const Eigen::Vector3f& pos, Eigen::Vector3f* eigen) const = 0;\n\n  /// @brief get the intensity of a grid specified by a position\n  ///\n  /// @param[in] pos the point which the querying grid contains\n  /// @param[out] cov stores the intensity got\n  ///\n  /// @return true if the querying grid exists, else false\n  virtual bool getIntensity(const Eigen::Vector3f& pos, float* intensity) const = 0;\n};\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/ndt3interface.h"
		}
	}
]
I0403 13:57:03.544080 32175 json_parser.cpp:18] 
[
	120,
	{
		"bufnr" : 5,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/ndt3tile.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include <unordered_map>\n#include <unordered_set>\n\n#include \"common/geometry/se3.h\"\n#include \"common/geometry/so3.h\"\n#include \"common/math/eigen_types.h\"\n#include \"common/math/point_types.h\"\n#include \"sensor_msgs/PointCloud2.h\"\n\n#include \"ndt3interface.h\"\n#include \"tile_data_storage.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass Ndt3TileMulti;\n\nclass Ndt3Tile : public Ndt3Interface {\n public:\n  enum NormalType { Plane = 0, Line };\n\n  friend class Ndt3TileMulti;\n\n  /// @brief construct a Ndt3Tile given grid_size\n  Ndt3Tile(float grid_size);\n\n  /// @brief construct a Ndt3Tile given grid_size and storage\n  Ndt3Tile(float grid_size, std::shared_ptr<TileDataStorage> storage);\n\n  /// @brief implemention of the Ndt3Interface::getMeans\n  std::shared_ptr<MapMatrixArray> getMeans() const override;\n\n  /// @brief implemention of the Ndt3Interface::getCovariances\n  std::shared_ptr<MapMatrixArray> getCovariances() const override;\n\n  /// @brief implemention of the Ndt3Interface::getCounts\n  std::shared_ptr<MapMatrixArray> getCounts() const override;\n\n  /// @brief implemention of the Ndt3Interface::getScales\n  std::shared_ptr<MapMatrixArray> getScales() const override;\n\n  /// @brief implemention of the Ndt3Interface::getNormals\n  std::shared_ptr<MapMatrixArray> getNormals() const override;\n\n  /// @brief implemention of the Ndt3Interface::getEigenvalues\n  std::shared_ptr<MapMatrixArray> getEigenvalues() const override;\n\n  /// @brief implemention of the Ndt3Interface::getIntensities\n  std::shared_ptr<MapMatrixArray> getIntensities() const override;\n\n  /// @brief implemention of the Ndt3Interface::getMean\n  bool getMean(const Eigen::Vector3f& pos, Eigen::Vector3f* mean) const override;\n\n  /// @brief implemention of the Ndt3Interface::getCovariance\n  bool getCovariance(const Eigen::Vector3f& pos, Eigen::Matrix3f* cov) const override;\n\n  /// @brief implemention of the Ndt3Interface::getCount\n  bool getCount(const Eigen::Vector3f& pos, float* count) const override;\n\n  /// @brief implemention of the Ndt3Interface::getScale\n  bool getScale(const Eigen::Vector3f& pos, float* scale) const override;\n\n  /// @brief implemention of the Ndt3Interface::getNormal\n  bool getNormal(const Eigen::Vector3f& pos, Eigen::Vector3f* normal) const override;\n\n  /// @brief implemention of the Ndt3Interface::getEigenvalue\n  bool getEigenvalue(const Eigen::Vector3f& pos, Eigen::Vector3f* eigen) const override;\n\n  /// @brief implemention of the Ndt3Interface::getIntensity\n  bool getIntensity(const Eigen::Vector3f& pos, float* intensity) const override;\n\n  /// @brief add a sample\n  ///\n  /// @param sample[in] sample contains x,y,z,intensity\n  void addSample(const common::PointXYZI& sample);\n\n  /// @brief add(merge) a already exist gaussian distribution\n  ///\n  /// @param mean[in] position mean\n  /// @param covariance[in] position covariance\n  /// @param count[in] number of sample\n  /// @param intensity[in] average intensity\n  void addGaussian(const Eigen::Vector3f& mean, const Eigen::Matrix3f& covariance, int count,\n                   float intensity);\n\n  /// @brief Deserialize from protobuf string\n  ///\n  /// @param packeded_string[in] store the serialized string\n  ///\n  /// @return true on succeed, else false\n  bool unpackFromString(const std::string& packeded_string);\n\n  /// @brief Serialize to protobuf string\n  ///\n  /// @param packed_string[out] store the serialized string\n  ///\n  /// @return true on succeed, else false\n  bool packToString(std::string* packed_string) const;\n\n  /// @brief build the grid_id to index mapping\n  ///\n  /// @return true on succeed, else false\n  // bool buildGridIndexMapping();\n\n  /// @brief\n  ///\n  /// @param sensor_noise_var\n  void computeAllNormalsAndEigenvalues(double sensor_noise_var);\n\n  /// @brief\n  ///\n  /// @param sensor_noise_var\n  void computeAllPrincipalAxisAndEigenvalues(double sensor_noise_var);\n\n  /// @brief\n  ///\n  /// @param Tx_MP_V\n  /// @param radius\n  void resetRegion(const common::geometry::SE3& Tx_MP_V, double radius);\n\n  /// @brief get the internal storage\n  ///\n  /// @return the internal storage got\n  std::shared_ptr<const TileDataStorage> getStorage() { return storage_; }\n\n  /// @brief copy from other Ndt3Tile\n  ///\n  /// @param copy_data[in] the other Ndt3Tile\n  void copy(Ndt3Tile* copy_data) const;\n\n  /// @brief copy from other Ndt3Tile in specific region\n  ///\n  /// @param Tx[in] specify the region center\n  /// @param radius[in] specify the region range\n  /// @param copy_data[in] the other Ndt3Tile\n  void copyAndTransform(const common::geometry::SE3& Tx, double radius, Ndt3Tile* copy_data) const;\n\n  /* temporary comment out for compilation\n  bool toRosMsgPointCloud2(const std::string& frame, const Time& time,\n                           sensor_msgs::PointCloud2* point_cloud,\n                           const geometry::SE3& Tx = geometry::SE3()) const;\n                           */\n\n private:\n  TileDataStorage::GridID getGridID(const Eigen::Vector3f& pos) const;\n\n  TileDataStorage::GridID getGridID(const Eigen::Vector3f& pos, float scale) const;\n\n  bool getIndex(const Eigen::Vector3f& pos, int* index) const;\n\n  TileDataStorage::MapMatrix getMeansInner() const;\n\n  TileDataStorage::MapMatrix getCovariancesInner() const;\n\n  TileDataStorage::MapMatrix getCountsInner() const;\n\n  TileDataStorage::MapMatrix getScalesInner() const;\n\n  TileDataStorage::MapMatrix getNormalsInner() const;\n\n  TileDataStorage::MapMatrix getEigenvaluesInner() const;\n\n  TileDataStorage::MapMatrix getIntensitiesInner() const;\n\n  Eigen::Vector3f getMean(int index) const;\n\n  Eigen::Matrix3f getCovariance(int index) const;\n\n  float getCount(int index) const;\n\n  float getScale(int index) const;\n\n  Eigen::Vector3f getNormal(int index) const;\n\n  Eigen::Vector3f getEigenvalue(int index) const;\n\n  float getIntensity(int index) const;\n\n  bool setMean(int index, const Eigen::Vector3f& mean);\n\n  bool setCovariance(int index, const Eigen::Matrix3f& covariance);\n\n  bool setCount(int index, float count);\n\n  bool setScale(int index, float scale);\n\n  bool setNormal(int index, const Eigen::Vector3f& normal);\n\n  bool setEigenvalue(int index, const Eigen::Vector3f& eigenvalue);\n\n  bool setIntensity(int index, float intensity);\n\n  void initializeGaussian(const Eigen::Vector3f& mean, const Eigen::Matrix3f& covariance, int count,\n                          float scale);\n\n  void computeNormalAndEigenvalues(int index, double sensor_noise_var,\n                                   NormalType normal_type = Plane);\n\n  static const std::vector<TileDataStorage::NameSizePair> kChannelNameAndSize;\n\n  static const int kTotalNumberOfRows;\n\n  std::unordered_set<int> indices_to_compute_normal_;\n\n  std::shared_ptr<TileDataStorage> storage_;\n\n  float grid_size_;\n};\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/ndt3tile.h"
		}
	}
]
I0403 13:57:33.267179 32175 json_parser.cpp:18] 
[
	121,
	{
		"bufnr" : 5,
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/ndt3tile.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-DROS_PACKAGE_NAME=\\\"gnss_localizer\\\"",
			"-I/usr/include/hdf5/openmpi",
			"-Dloc_io_EXPORTS",
			"-I/usr/include/vtk-6.2",
			"-I/usr/include/libxml2",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/openni2",
			"-I/usr/include/freetype2",
			"-Dloc_geometry_EXPORTS",
			"-I/usr/local/include",
			"-I/usr/include/pcl-1.7",
			"-DROS_PACKAGE_NAME=\\\"gnss\\\"",
			"-I/home/mr/Workspace/loc/src/lidar_localizer/include",
			"-Dlocalization_EXPORTS",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-DROS_BUILD_SHARED_LIBS=1",
			"-DROS_PACKAGE_NAME=\\\"rideware_connector\\\"",
			"-I/usr/include/ni",
			"-I/usr/include/x86_64-linux-gnu",
			"-Dv2_mapping_EXPORTS",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_NO_DEBUG",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DDISABLE_PNG",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/home/mr/Workspace/loc/src/lib/ndt_cpu/include",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DQT_CORE_LIB",
			"-Dndt_tku_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-I/usr/include/eigen3",
			"-I/home/mr/Workspace/loc/src/lib/ndt_tku/include",
			"-I/opt/ros/kinetic/include",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/home/mr/Workspace/loc/src/lib/pcl_omp_registration/include",
			"-I/usr/include/python2.7",
			"-I/usr/lib/openmpi/include",
			"-Dndt_matching_monitor_lib_EXPORTS",
			"-DQT_GUI_LIB",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DQT_WIDGETS_LIB",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-I/usr/include/tcl",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-I/usr/include/jsoncpp",
			"-Dpcl_omp_registration_EXPORTS",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-Dgnss_EXPORTS",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/home/mr/Workspace/loc/devel/include",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/gnss_localizer/nodes/nmea2tfpose",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-Dinertial_nav_EXPORTS",
			"-DUSE_PCL_OPENMP",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-Dndt_cpu_EXPORTS",
			"-DROS_PACKAGE_NAME=\\\"lidar_localizer\\\"",
			"-I/home/mr/Workspace/loc/src/lib/gnss/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include <unordered_map>\n#include <unordered_set>\n\n#include \"common/geometry/se3.h\"\n#include \"common/geometry/so3.h\"\n#include \"common/math/eigen_types.h\"\n#include \"common/math/point_types.h\"\n#include \"sensor_msgs/PointCloud2.h\"\n\n#include \"ndt3interface.h\"\n#include \"tile_data_storage.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass Ndt3TileMulti;\n\nclass Ndt3Tile : public Ndt3Interface {\n public:\n  enum NormalType { Plane = 0, Line };\n\n  friend class Ndt3TileMulti;\n\n  /// @brief construct a Ndt3Tile given grid_size\n  Ndt3Tile(float grid_size);\n\n  /// @brief construct a Ndt3Tile given grid_size and storage\n  Ndt3Tile(float grid_size, std::shared_ptr<TileDataStorage> storage);\n\n  /// @brief implemention of the Ndt3Interface::getMeans\n  std::shared_ptr<MapMatrixArray> getMeans() const override;\n\n  /// @brief implemention of the Ndt3Interface::getCovariances\n  std::shared_ptr<MapMatrixArray> getCovariances() const override;\n\n  /// @brief implemention of the Ndt3Interface::getCounts\n  std::shared_ptr<MapMatrixArray> getCounts() const override;\n\n  /// @brief implemention of the Ndt3Interface::getScales\n  std::shared_ptr<MapMatrixArray> getScales() const override;\n\n  /// @brief implemention of the Ndt3Interface::getNormals\n  std::shared_ptr<MapMatrixArray> getNormals() const override;\n\n  /// @brief implemention of the Ndt3Interface::getEigenvalues\n  std::shared_ptr<MapMatrixArray> getEigenvalues() const override;\n\n  /// @brief implemention of the Ndt3Interface::getIntensities\n  std::shared_ptr<MapMatrixArray> getIntensities() const override;\n\n  /// @brief implemention of the Ndt3Interface::getMean\n  bool getMean(const Eigen::Vector3f& pos, Eigen::Vector3f* mean) const override;\n\n  /// @brief implemention of the Ndt3Interface::getCovariance\n  bool getCovariance(const Eigen::Vector3f& pos, Eigen::Matrix3f* cov) const override;\n\n  /// @brief implemention of the Ndt3Interface::getCount\n  bool getCount(const Eigen::Vector3f& pos, float* count) const override;\n\n  /// @brief implemention of the Ndt3Interface::getScale\n  bool getScale(const Eigen::Vector3f& pos, float* scale) const override;\n\n  /// @brief implemention of the Ndt3Interface::getNormal\n  bool getNormal(const Eigen::Vector3f& pos, Eigen::Vector3f* normal) const override;\n\n  /// @brief implemention of the Ndt3Interface::getEigenvalue\n  bool getEigenvalue(const Eigen::Vector3f& pos, Eigen::Vector3f* eigen) const override;\n\n  /// @brief implemention of the Ndt3Interface::getIntensity\n  bool getIntensity(const Eigen::Vector3f& pos, float* intensity) const override;\n\n  /// @brief add a sample\n  ///\n  /// @param sample[in] sample contains x,y,z,intensity\n  void addSample(const common::PointXYZI& sample);\n\n  /// @brief add(merge) a already exist gaussian distribution\n  ///\n  /// @param mean[in] position mean\n  /// @param covariance[in] position covariance\n  /// @param count[in] number of sample\n  /// @param intensity[in] average intensity\n  void addGaussian(const Eigen::Vector3f& mean, const Eigen::Matrix3f& covariance, int count,\n                   float intensity);\n\n  /// @brief Deserialize from protobuf string\n  ///\n  /// @param packeded_string[in] store the serialized string\n  ///\n  /// @return true on succeed, else false\n  bool unpackFromString(const std::string& packeded_string);\n\n  /// @brief Serialize to protobuf string\n  ///\n  /// @param packed_string[out] store the serialized string\n  ///\n  /// @return true on succeed, else false\n  bool packToString(std::string* packed_string) const;\n\n  /// @brief build the grid_id to index mapping\n  ///\n  /// @return true on succeed, else false\n  // bool buildGridIndexMapping();\n\n  /// @brief\n  ///\n  /// @param sensor_noise_var\n  void computeAllNormalsAndEigenvalues(double sensor_noise_var);\n\n  /// @brief\n  ///\n  /// @param sensor_noise_var\n  void computeAllPrincipalAxisAndEigenvalues(double sensor_noise_var);\n\n  /// @brief\n  ///\n  /// @param Tx_MP_V\n  /// @param radius\n  void resetRegion(const common::geometry::SE3& Tx_MP_V, double radius);\n\n  /// @brief get the internal storage\n  ///\n  /// @return the internal storage got\n  std::shared_ptr<const TileDataStorage> getStorage() { return storage_; }\n\n  /// @brief copy from other Ndt3Tile\n  ///\n  /// @param copy_data[in] the other Ndt3Tile\n  void copy(Ndt3Tile* copy_data) const;\n\n  /// @brief copy from other Ndt3Tile in specific region\n  ///\n  /// @param Tx[in] specify the region center\n  /// @param radius[in] specify the region range\n  /// @param copy_data[in] the other Ndt3Tile\n  void copyAndTransform(const common::geometry::SE3& Tx, double radius, Ndt3Tile* copy_data) const;\n\n  /* temporary comment out for compilation\n  bool toRosMsgPointCloud2(const std::string& frame, const Time& time,\n                           sensor_msgs::PointCloud2* point_cloud,\n                           const geometry::SE3& Tx = geometry::SE3()) const;\n                           */\n\n private:\n  TileDataStorage::GridID getGridID(const Eigen::Vector3f& pos) const;\n\n  TileDataStorage::GridID getGridID(const Eigen::Vector3f& pos, float scale) const;\n\n  bool getIndex(const Eigen::Vector3f& pos, int* index) const;\n\n  TileDataStorage::MapMatrix getMeansInner() const;\n\n  TileDataStorage::MapMatrix getCovariancesInner() const;\n\n  TileDataStorage::MapMatrix getCountsInner() const;\n\n  TileDataStorage::MapMatrix getScalesInner() const;\n\n  TileDataStorage::MapMatrix getNormalsInner() const;\n\n  TileDataStorage::MapMatrix getEigenvaluesInner() const;\n\n  TileDataStorage::MapMatrix getIntensitiesInner() const;\n\n  Eigen::Vector3f getMean(int index) const;\n\n  Eigen::Matrix3f getCovariance(int index) const;\n\n  float getCount(int index) const;\n\n  float getScale(int index) const;\n\n  Eigen::Vector3f getNormal(int index) const;\n\n  Eigen::Vector3f getEigenvalue(int index) const;\n\n  float getIntensity(int index) const;\n\n  bool setMean(int index, const Eigen::Vector3f& mean);\n\n  bool setCovariance(int index, const Eigen::Matrix3f& covariance);\n\n  bool setCount(int index, float count);\n\n  bool setScale(int index, float scale);\n\n  bool setNormal(int index, const Eigen::Vector3f& normal);\n\n  bool setEigenvalue(int index, const Eigen::Vector3f& eigenvalue);\n\n  bool setIntensity(int index, float intensity);\n\n  void initializeGaussian(const Eigen::Vector3f& mean, const Eigen::Matrix3f& covariance, int count,\n                          float scale);\n\n  void computeNormalAndEigenvalues(int index, double sensor_noise_var,\n                                   NormalType normal_type = Plane);\n\n  static const std::vector<TileDataStorage::NameSizePair> kChannelNameAndSize;\n\n  static const int kTotalNumberOfRows;\n\n  std::unordered_set<int> indices_to_compute_normal_;\n\n  std::shared_ptr<TileDataStorage> storage_;\n\n  float grid_size_;\n};\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/ndt3tile.h"
		}
	}
]
