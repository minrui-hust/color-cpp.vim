Log file created at: 2019/04/02 15:43:00
Running on machine: mr-pc
Log line format: [IWEF]mmdd hh:mm:ss.uuuuuu threadid file:line] msg
I0402 15:43:00.813293  5535 json_parser.cpp:18] 
[
	1,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/intensity_map_builder.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All rights reserved.\n// Authors: Yongjian Zhao (yongjian.zhao@allride.ai)\n\n#include <priority_queue>\n#include <set>\n\n#include \"intensity_map_builder.h\"\n\nvoid ClusterSample::ClusterSample(const ClusterSmaple& other) {\n  this->point_num += other.point_num;\n\n  float other_weight = static_cast<float>(other.point_num) / this->point_num;\n  float this_weight = 1.0f - other_weight;\n\n  this->height = this_weight * this->height + other_weight * other.height;\n  this->intensity = this_weigh * this->intensity + other_weight * other.intensity;\n}\n\nvoid IntensityMapBuilder::buildIntensityMap(const std::string& output_folder) {\n  // To initialize grid2_samples_, each ndt3 grid is one ClusterSample\n  // for each grid2 sample, there are several Cluster\n\n  // height cluster for each grid2_sample\n  for (auto& grid2_smaple : grid2_samples_) {\n    heightCluster(&grid2_smaple.second);\n  }\n\n  // create image acoording to grid2_samples_\n  cv::Mat intensity_image;\n  createImage(&intensity_image);\n\n  // create intensity_map_info according to grid2_samples_\n  /* protoBufType intensity_map_info */\n  createHeightInfo(/*&intensity_map_info*/);\n\n  // save image and intensity_map_info\n  saveIntensityMap(output_folder, intensity_image /*, intensity_map_info*/);\n}\n\nvoid IntensityMapBuilder::heightCluster(std::vector<ClusterSample>* samples) {\n  size_t sample_num = samples->size();\n\n  // make existing_sample_id\n  std::set<size_t> existing_sample_id;\n  for (size_t i = 0; i < sample_num; i++) {\n    existing_sample_id.insert(i);\n  }\n\n  // make distance_queue\n  std::priority_queue<QueueElement, std::vector<QueueElement>, QueueElementCompare> distance_queue;\n  for (size_t i = 0; i < sample_num; i++) {\n    for (size_t j = i + 1; j < sample_num; j++) {\n      float distance = fabs(samples->at(i).height - samples->at(j).height);\n      distance_queue.emplace(distance, i, j);\n    }\n  }\n\n  // cluster\n  const float distance_th = 4.0f;\n  while (true) {\n    // find min_distance between each ClusterSample\n    QueueElement element = distance_queue.top() distance_queue.pop();\n    if (element.distance > distance_th) {\n      break;\n    }\n\n    if (existing_sample_id.count(element.small_id) == 0) {\n      continue;\n    }\n\n    if (existing_sample_id.count(element.big_id) == 0) {\n      continue;\n    }\n\n    // merge two nearest samples\n    samples->at(element.small_id).merge(samples->at(element.big_id));\n    existing_sample_id.erase(element.big_id);\n    sample_num--;\n  }\n\n  if (existing_sample_id.size() != sample_num) {\n    std::cout << \"error: existing_sample_id.size() does not equal to sample_num!\" << std::endl;\n  }\n\n  // save cluster result\n  // need test\n  size_t i = 0;\n  for (size_t id& existing_sample_id) {\n    samples->at<i> = samples->at(id);\n  }\n  samples->resize(sample_num);\n}\n\nvoid IntensityMapBuilder::createImage(cv::Mat* image) {\n  // get necessary information from ndt_map_data_\n  int min_tile_id_x = 0, max_tile_id_x = 10;\n  int min_tile_id_y = 0, max_tile_id_y = 10;\n  float min_height = 0, max_height = 10;\n  float min_intensity = 0, max_intensity = 255;\n\n  int image_width =\n      static_cast<int>((max_tile_id_x - min_tile_id_x + 1) * param_.tile_size / param_.grid_size);\n  int image_height =\n      static_cast<int>((max_tile_id_y - min_tile_id_y + 1) * param_.tile_size / param_.grid_size);\n\n  // make image\n  cv::Mat blank_image = cv::Mat::zeros(image_height, image_width, CV_U8C3);\n  blank_image.copyTo(*image);\n  for (auto grid2_sample : grid2_samples_) {\n    // set pixel value\n  }\n}\n\nvoid IntensityMapBuilder::createHeightInfo(/* protoBufType *intensity_map_info */) {}\n\nbool IntensityMapBuilder::saveIntensityMap(const std::string& output_folder, const cv::Mat& image\n                                           /*const protoBufType *intensity_map_info */) {\n  // check or make output folder\n\n  // save image\n  std::string image_name = output_folder + \"/intensity_image.png\";\n  cv::imwrite(image_name, image);\n\n  // save intensity_map_info\n\n  return true;\n}\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/intensity_map_builder.cpp"
		}
	}
]
I0402 15:43:00.871100  5535 json_parser.cpp:18] 
[
	2,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/intensity_map_builder.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All rights reserved.\n// Authors: Yongjian Zhao (yongjian.zhao@allride.ai)\n\n#include <priority_queue>\n#include <set>\n\n#include \"intensity_map_builder.h\"\n\nvoid ClusterSample::ClusterSample(const ClusterSmaple& other) {\n  this->point_num += other.point_num;\n\n  float other_weight = static_cast<float>(other.point_num) / this->point_num;\n  float this_weight = 1.0f - other_weight;\n\n  this->height = this_weight * this->height + other_weight * other.height;\n  this->intensity = this_weigh * this->intensity + other_weight * other.intensity;\n}\n\nvoid IntensityMapBuilder::buildIntensityMap(const std::string& output_folder) {\n  // To initialize grid2_samples_, each ndt3 grid is one ClusterSample\n  // for each grid2 sample, there are several Cluster\n\n  // height cluster for each grid2_sample\n  for (auto& grid2_smaple : grid2_samples_) {\n    heightCluster(&grid2_smaple.second);\n  }\n\n  // create image acoording to grid2_samples_\n  cv::Mat intensity_image;\n  createImage(&intensity_image);\n\n  // create intensity_map_info according to grid2_samples_\n  /* protoBufType intensity_map_info */\n  createHeightInfo(/*&intensity_map_info*/);\n\n  // save image and intensity_map_info\n  saveIntensityMap(output_folder, intensity_image /*, intensity_map_info*/);\n}\n\nvoid IntensityMapBuilder::heightCluster(std::vector<ClusterSample>* samples) {\n  size_t sample_num = samples->size();\n\n  // make existing_sample_id\n  std::set<size_t> existing_sample_id;\n  for (size_t i = 0; i < sample_num; i++) {\n    existing_sample_id.insert(i);\n  }\n\n  // make distance_queue\n  std::priority_queue<QueueElement, std::vector<QueueElement>, QueueElementCompare> distance_queue;\n  for (size_t i = 0; i < sample_num; i++) {\n    for (size_t j = i + 1; j < sample_num; j++) {\n      float distance = fabs(samples->at(i).height - samples->at(j).height);\n      distance_queue.emplace(distance, i, j);\n    }\n  }\n\n  // cluster\n  const float distance_th = 4.0f;\n  while (true) {\n    // find min_distance between each ClusterSample\n    QueueElement element = distance_queue.top() distance_queue.pop();\n    if (element.distance > distance_th) {\n      break;\n    }\n\n    if (existing_sample_id.count(element.small_id) == 0) {\n      continue;\n    }\n\n    if (existing_sample_id.count(element.big_id) == 0) {\n      continue;\n    }\n\n    // merge two nearest samples\n    samples->at(element.small_id).merge(samples->at(element.big_id));\n    existing_sample_id.erase(element.big_id);\n    sample_num--;\n  }\n\n  if (existing_sample_id.size() != sample_num) {\n    std::cout << \"error: existing_sample_id.size() does not equal to sample_num!\" << std::endl;\n  }\n\n  // save cluster result\n  // need test\n  size_t i = 0;\n  for (size_t id& existing_sample_id) {\n    samples->at<i> = samples->at(id);\n  }\n  samples->resize(sample_num);\n}\n\nvoid IntensityMapBuilder::createImage(cv::Mat* image) {\n  // get necessary information from ndt_map_data_\n  int min_tile_id_x = 0, max_tile_id_x = 10;\n  int min_tile_id_y = 0, max_tile_id_y = 10;\n  float min_height = 0, max_height = 10;\n  float min_intensity = 0, max_intensity = 255;\n\n  int image_width =\n      static_cast<int>((max_tile_id_x - min_tile_id_x + 1) * param_.tile_size / param_.grid_size);\n  int image_height =\n      static_cast<int>((max_tile_id_y - min_tile_id_y + 1) * param_.tile_size / param_.grid_size);\n\n  // make image\n  cv::Mat blank_image = cv::Mat::zeros(image_height, image_width, CV_U8C3);\n  blank_image.copyTo(*image);\n  for (auto grid2_sample : grid2_samples_) {\n    // set pixel value\n  }\n}\n\nvoid IntensityMapBuilder::createHeightInfo(/* protoBufType *intensity_map_info */) {}\n\nbool IntensityMapBuilder::saveIntensityMap(const std::string& output_folder, const cv::Mat& image\n                                           /*const protoBufType *intensity_map_info */) {\n  // check or make output folder\n\n  // save image\n  std::string image_name = output_folder + \"/intensity_image.png\";\n  cv::imwrite(image_name, image);\n\n  // save intensity_map_info\n\n  return true;\n}\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/intensity_map_builder.cpp"
		}
	}
]
I0402 15:43:39.187018  5535 json_parser.cpp:18] 
[
	3,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/intensity_map_builder.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All rights reserved.\n// Authors: Yongjian Zhao (yongjian.zhao@allride.ai)\n\n#include <priority_queue>\n#include <set>\n\n#include \"intensity_map_builder.h\"\n\nvoid ClusterSample::ClusterSample(const ClusterSmaple& other) {\n  this->point_num += other.point_num;\n\n  float other_weight = static_cast<float>(other.point_num) / this->point_num;\n  float this_weight = 1.0f - other_weight;\n\n  this->height = this_weight * this->height + other_weight * other.height;\n  this->intensity = this_weigh * this->intensity + other_weight * other.intensity;\n}\n\nvoid IntensityMapBuilder::buildIntensityMap(const std::string& output_folder) {\n  // To initialize grid2_samples_, each ndt3 grid is one ClusterSample\n  // for each grid2 sample, there are several Cluster\n\n  // height cluster for each grid2_sample\n  for (auto& grid2_smaple : grid2_samples_) {\n    heightCluster(&grid2_smaple.second);\n  }\n\n  // create image acoording to grid2_samples_\n  cv::Mat intensity_image;\n  createImage(&intensity_image);\n\n  // create intensity_map_info according to grid2_samples_\n  /* protoBufType intensity_map_info */\n  createHeightInfo(/*&intensity_map_info*/);\n\n  // save image and intensity_map_info\n  saveIntensityMap(output_folder, intensity_image /*, intensity_map_info*/);\n}\n\nvoid IntensityMapBuilder::heightCluster(std::vector<ClusterSample>* samples) {\n  size_t sample_num = samples->size();\n\n  // make existing_sample_id\n  std::set<size_t> existing_sample_id;\n  for (size_t i = 0; i < sample_num; i++) {\n    existing_sample_id.insert(i);\n  }\n\n  // make distance_queue\n  std::priority_queue<QueueElement, std::vector<QueueElement>, QueueElementCompare> distance_queue;\n  for (size_t i = 0; i < sample_num; i++) {\n    for (size_t j = i + 1; j < sample_num; j++) {\n      float distance = fabs(samples->at(i).height - samples->at(j).height);\n      distance_queue.emplace(distance, i, j);\n    }\n  }\n\n  // cluster\n  const float distance_th = 4.0f;\n  while (true) {\n    // find min_distance between each ClusterSample\n    QueueElement element = distance_queue.top() distance_queue.pop();\n    if (element.distance > distance_th) {\n      break;\n    }\n\n    if (existing_sample_id.count(element.small_id) == 0) {\n      continue;\n    }\n\n    if (existing_sample_id.count(element.big_id) == 0) {\n      continue;\n    }\n\n    // merge two nearest samples\n    samples->at(element.small_id).merge(samples->at(element.big_id));\n    existing_sample_id.erase(element.big_id);\n    sample_num--;\n  }\n\n  if (existing_sample_id.size() != sample_num) {\n    std::cout << \"error: existing_sample_id.size() does not equal to sample_num!\" << std::endl;\n  }\n\n  // save cluster result\n  // need test\n  size_t i = 0;\n  for (size_t id& existing_sample_id) {\n    samples->at<i> = samples->at(id);\n  }\n  samples->resize(sample_num);\n}\n\nvoid IntensityMapBuilder::createImage(cv::Mat* image) {\n  // get necessary information from ndt_map_data_\n  int min_tile_id_x = 0, max_tile_id_x = 10;\n  int min_tile_id_y = 0, max_tile_id_y = 10;\n  float min_height = 0, max_height = 10;\n  float min_intensity = 0, max_intensity = 255;\n\n  int image_width =\n      static_cast<int>((max_tile_id_x - min_tile_id_x + 1) * param_.tile_size / param_.grid_size);\n  int image_height =\n      static_cast<int>((max_tile_id_y - min_tile_id_y + 1) * param_.tile_size / param_.grid_size);\n\n  // make image\n  cv::Mat blank_image = cv::Mat::zeros(image_height, image_width, CV_U8C3);\n  blank_image.copyTo(*image);\n  for (auto grid2_sample : grid2_samples_) {\n    // set pixel value\n  }\n}\n\nvoid IntensityMapBuilder::createHeightInfo(/* protoBufType *intensity_map_info */) {}\n\nbool IntensityMapBuilder::saveIntensityMap(const std::string& output_folder, const cv::Mat& image\n                                           /*const protoBufType *intensity_map_info */) {\n  // check or make output folder\n\n  // save image\n  std::string image_name = output_folder + \"/intensity_image.png\";\n  cv::imwrite(image_name, image);\n\n  // save intensity_map_info\n\n  return true;\n}\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/intensity_map_builder.cpp"
		}
	}
]
I0402 15:43:39.197885  5535 json_parser.cpp:18] 
[
	4,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/intensity_map_builder.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All rights reserved.\n// Authors: Yongjian Zhao (yongjian.zhao@allride.ai)\n\n#include <priority_queue>\n#include <set>\n\n#include \"intensity_map_builder.h\"\n\nvoid ClusterSample::ClusterSample(const ClusterSmaple& other) {\n  this->point_num += other.point_num;\n\n  float other_weight = static_cast<float>(other.point_num) / this->point_num;\n  float this_weight = 1.0f - other_weight;\n\n  this->height = this_weight * this->height + other_weight * other.height;\n  this->intensity = this_weigh * this->intensity + other_weight * other.intensity;\n}\n\nvoid IntensityMapBuilder::buildIntensityMap(const std::string& output_folder) {\n  // To initialize grid2_samples_, each ndt3 grid is one ClusterSample\n  // for each grid2 sample, there are several Cluster\n\n  // height cluster for each grid2_sample\n  for (auto& grid2_smaple : grid2_samples_) {\n    heightCluster(&grid2_smaple.second);\n  }\n\n  // create image acoording to grid2_samples_\n  cv::Mat intensity_image;\n  createImage(&intensity_image);\n\n  // create intensity_map_info according to grid2_samples_\n  /* protoBufType intensity_map_info */\n  createHeightInfo(/*&intensity_map_info*/);\n\n  // save image and intensity_map_info\n  saveIntensityMap(output_folder, intensity_image /*, intensity_map_info*/);\n}\n\nvoid IntensityMapBuilder::heightCluster(std::vector<ClusterSample>* samples) {\n  size_t sample_num = samples->size();\n\n  // make existing_sample_id\n  std::set<size_t> existing_sample_id;\n  for (size_t i = 0; i < sample_num; i++) {\n    existing_sample_id.insert(i);\n  }\n\n  // make distance_queue\n  std::priority_queue<QueueElement, std::vector<QueueElement>, QueueElementCompare> distance_queue;\n  for (size_t i = 0; i < sample_num; i++) {\n    for (size_t j = i + 1; j < sample_num; j++) {\n      float distance = fabs(samples->at(i).height - samples->at(j).height);\n      distance_queue.emplace(distance, i, j);\n    }\n  }\n\n  // cluster\n  const float distance_th = 4.0f;\n  while (true) {\n    // find min_distance between each ClusterSample\n    QueueElement element = distance_queue.top() distance_queue.pop();\n    if (element.distance > distance_th) {\n      break;\n    }\n\n    if (existing_sample_id.count(element.small_id) == 0) {\n      continue;\n    }\n\n    if (existing_sample_id.count(element.big_id) == 0) {\n      continue;\n    }\n\n    // merge two nearest samples\n    samples->at(element.small_id).merge(samples->at(element.big_id));\n    existing_sample_id.erase(element.big_id);\n    sample_num--;\n  }\n\n  if (existing_sample_id.size() != sample_num) {\n    std::cout << \"error: existing_sample_id.size() does not equal to sample_num!\" << std::endl;\n  }\n\n  // save cluster result\n  // need test\n  size_t i = 0;\n  for (size_t id& existing_sample_id) {\n    samples->at<i> = samples->at(id);\n  }\n  samples->resize(sample_num);\n}\n\nvoid IntensityMapBuilder::createImage(cv::Mat* image) {\n  // get necessary information from ndt_map_data_\n  int min_tile_id_x = 0, max_tile_id_x = 10;\n  int min_tile_id_y = 0, max_tile_id_y = 10;\n  float min_height = 0, max_height = 10;\n  float min_intensity = 0, max_intensity = 255;\n\n  int image_width =\n      static_cast<int>((max_tile_id_x - min_tile_id_x + 1) * param_.tile_size / param_.grid_size);\n  int image_height =\n      static_cast<int>((max_tile_id_y - min_tile_id_y + 1) * param_.tile_size / param_.grid_size);\n\n  // make image\n  cv::Mat blank_image = cv::Mat::zeros(image_height, image_width, CV_U8C3);\n  blank_image.copyTo(*image);\n  for (auto grid2_sample : grid2_samples_) {\n    // set pixel value\n  }\n}\n\nvoid IntensityMapBuilder::createHeightInfo(/* protoBufType *intensity_map_info */) {}\n\nbool IntensityMapBuilder::saveIntensityMap(const std::string& output_folder, const cv::Mat& image\n                                           /*const protoBufType *intensity_map_info */) {\n  // check or make output folder\n\n  // save image\n  std::string image_name = output_folder + \"/intensity_image.png\";\n  cv::imwrite(image_name, image);\n\n  // save intensity_map_info\n\n  return true;\n}\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/intensity_map_builder.cpp"
		}
	}
]
I0402 15:43:39.208742  5535 json_parser.cpp:18] 
[
	5,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/intensity_map_builder.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All rights reserved.\n// Authors: Yongjian Zhao (yongjian.zhao@allride.ai)\n\n#include <priority_queue>\n#include <set>\n\n#include \"intensity_map_builder.h\"\n\nvoid ClusterSample::ClusterSample(const ClusterSmaple& other) {\n  this->point_num += other.point_num;\n\n  float other_weight = static_cast<float>(other.point_num) / this->point_num;\n  float this_weight = 1.0f - other_weight;\n\n  this->height = this_weight * this->height + other_weight * other.height;\n  this->intensity = this_weigh * this->intensity + other_weight * other.intensity;\n}\n\nvoid IntensityMapBuilder::buildIntensityMap(const std::string& output_folder) {\n  // To initialize grid2_samples_, each ndt3 grid is one ClusterSample\n  // for each grid2 sample, there are several Cluster\n\n  // height cluster for each grid2_sample\n  for (auto& grid2_smaple : grid2_samples_) {\n    heightCluster(&grid2_smaple.second);\n  }\n\n  // create image acoording to grid2_samples_\n  cv::Mat intensity_image;\n  createImage(&intensity_image);\n\n  // create intensity_map_info according to grid2_samples_\n  /* protoBufType intensity_map_info */\n  createHeightInfo(/*&intensity_map_info*/);\n\n  // save image and intensity_map_info\n  saveIntensityMap(output_folder, intensity_image /*, intensity_map_info*/);\n}\n\nvoid IntensityMapBuilder::heightCluster(std::vector<ClusterSample>* samples) {\n  size_t sample_num = samples->size();\n\n  // make existing_sample_id\n  std::set<size_t> existing_sample_id;\n  for (size_t i = 0; i < sample_num; i++) {\n    existing_sample_id.insert(i);\n  }\n\n  // make distance_queue\n  std::priority_queue<QueueElement, std::vector<QueueElement>, QueueElementCompare> distance_queue;\n  for (size_t i = 0; i < sample_num; i++) {\n    for (size_t j = i + 1; j < sample_num; j++) {\n      float distance = fabs(samples->at(i).height - samples->at(j).height);\n      distance_queue.emplace(distance, i, j);\n    }\n  }\n\n  // cluster\n  const float distance_th = 4.0f;\n  while (true) {\n    // find min_distance between each ClusterSample\n    QueueElement element = distance_queue.top() distance_queue.pop();\n    if (element.distance > distance_th) {\n      break;\n    }\n\n    if (existing_sample_id.count(element.small_id) == 0) {\n      continue;\n    }\n\n    if (existing_sample_id.count(element.big_id) == 0) {\n      continue;\n    }\n\n    // merge two nearest samples\n    samples->at(element.small_id).merge(samples->at(element.big_id));\n    existing_sample_id.erase(element.big_id);\n    sample_num--;\n  }\n\n  if (existing_sample_id.size() != sample_num) {\n    std::cout << \"error: existing_sample_id.size() does not equal to sample_num!\" << std::endl;\n  }\n\n  // save cluster result\n  // need test\n  size_t i = 0;\n  for (size_t id& existing_sample_id) {\n    samples->at<i> = samples->at(id);\n  }\n  samples->resize(sample_num);\n}\n\nvoid IntensityMapBuilder::createImage(cv::Mat* image) {\n  // get necessary information from ndt_map_data_\n  int min_tile_id_x = 0, max_tile_id_x = 10;\n  int min_tile_id_y = 0, max_tile_id_y = 10;\n  float min_height = 0, max_height = 10;\n  float min_intensity = 0, max_intensity = 255;\n\n  int image_width =\n      static_cast<int>((max_tile_id_x - min_tile_id_x + 1) * param_.tile_size / param_.grid_size);\n  int image_height =\n      static_cast<int>((max_tile_id_y - min_tile_id_y + 1) * param_.tile_size / param_.grid_size);\n\n  // make image\n  cv::Mat blank_image = cv::Mat::zeros(image_height, image_width, CV_U8C3);\n  blank_image.copyTo(*image);\n  for (auto grid2_sample : grid2_samples_) {\n    // set pixel value\n  }\n}\n\nvoid IntensityMapBuilder::createHeightInfo(/* protoBufType *intensity_map_info */) {}\n\nbool IntensityMapBuilder::saveIntensityMap(const std::string& output_folder, const cv::Mat& image\n                                           /*const protoBufType *intensity_map_info */) {\n  // check or make output folder\n\n  // save image\n  std::string image_name = output_folder + \"/intensity_image.png\";\n  cv::imwrite(image_name, image);\n\n  // save intensity_map_info\n\n  return true;\n}\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/intensity_map_builder.cpp"
		}
	}
]
I0402 15:44:11.090690  5535 json_parser.cpp:18] 
[
	6,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/intensity_map_builder.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All rights reserved.\n// Authors: Yongjian Zhao (yongjian.zhao@allride.ai)\n\n#pragma once\n\n#include <vector>\n\n#include <opencv2/opencv.hpp>\n\n#include \"ndt3tile.h\"\n#include \"ndt_map_builder.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstruct ClusterSample {\n  int point_num;\n  float intensity;\n  float height;\n\n  ClusterSample();\n  void merge(const ClusterSmaple& other);\n};\n\nclass IntensityMapBuilder : public NdtMapBuilder {\n public:\n  IntensityMapBuilder() = default;\n  ~IntensityMapBuilder() = default;\n\n  void buildIntensityMap(const std::string& output_folder);\n\n private:\n  struct QueueElement {\n    float distance;\n    size_t small_id;\n    size_t big_id;\n  };\n\n  struct QueueElementCompare {\n    bool operator(const QueueElement& left, const QueueElement& right) const {\n      // priority_queue.top() return the element with minimum distance\n      // need test\n      return left.distance > right.distance;\n    }\n  };\n\n  void heightCluster(std::vector<ClusterSample>* samples);\n\n  bool saveIntensityMap(const std::string& output_folder);\n\n  void createImage(cv::Mat* image);\n\n  void hsvToRgb(const std::vector<unsigned char>& hsv, std::vector<unsigned char>* rgb);\n\n  void createHeightInfo(/* protoBufType *intensity_map_info */);\n\n  std::unordered_map<Ndt3Tile::GridID, std::vector<ClusterSample>> grid2_samples_;\n};\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/intensity_map_builder.h"
		}
	}
]
I0402 15:44:12.608026  5535 json_parser.cpp:18] 
[
	7,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/intensity_map_builder.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All rights reserved.\n// Authors: Yongjian Zhao (yongjian.zhao@allride.ai)\n\n#pragma once\n\n#include <vector>\n\n#include <opencv2/opencv.hpp>\n\n#include \"ndt3tile.h\"\n#include \"ndt_map_builder.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstruct ClusterSample {\n  int point_num;\n  float intensity;\n  float height;\n\n  ClusterSample();\n  void merge(const ClusterSmaple& other);\n};\n\nclass IntensityMapBuilder : public NdtMapBuilder {\n public:\n  IntensityMapBuilder() = default;\n  ~IntensityMapBuilder() = default;\n\n  void buildIntensityMap(const std::string& output_folder);\n\n private:\n  struct QueueElement {\n    float distance;\n    size_t small_id;\n    size_t big_id;\n  };\n\n  struct QueueElementCompare {\n    bool operator(const QueueElement& left, const QueueElement& right) const {\n      // priority_queue.top() return the element with minimum distance\n      // need test\n      return left.distance > right.distance;\n    }\n  };\n\n  void heightCluster(std::vector<ClusterSample>* samples);\n\n  bool saveIntensityMap(const std::string& output_folder);\n\n  void createImage(cv::Mat* image);\n\n  void hsvToRgb(const std::vector<unsigned char>& hsv, std::vector<unsigned char>* rgb);\n\n  void createHeightInfo(/* protoBufType *intensity_map_info */);\n\n  std::unordered_map<Ndt3Tile::GridID, std::vector<ClusterSample>> grid2_samples_;\n};\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/intensity_map_builder.h"
		}
	}
]
I0402 15:44:28.865108  5535 json_parser.cpp:18] 
[
	8,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/intensity_map_builder.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All rights reserved.\n// Authors: Yongjian Zhao (yongjian.zhao@allride.ai)\n\n#pragma once\n\n#include <vector>\n\n#include <opencv2/opencv.hpp>\n\n#include \"ndt3tile.h\"\n#include \"ndt_map_builder.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstruct ClusterSample {\n  int point_num;\n  float intensity;\n  float height;\n\n  ClusterSample();\n  void merge(const ClusterSmaple& other);\n};\n\nclass IntensityMapBuilder : public NdtMapBuilder {\n public:\n  IntensityMapBuilder() = default;\n  ~IntensityMapBuilder() = default;\n\n  void buildIntensityMap(const std::string& output_folder);\n\n private:\n  struct QueueElement {\n    float distance;\n    size_t small_id;\n    size_t big_id;\n  };\n\n  struct QueueElementCompare {\n    bool operator(const QueueElement& left, const QueueElement& right) const {\n      // priority_queue.top() return the element with minimum distance\n      // need test\n      return left.distance > right.distance;\n    }\n  };\n\n  void heightCluster(std::vector<ClusterSample>* samples);\n\n  bool saveIntensityMap(const std::string& output_folder);\n\n  void createImage(cv::Mat* image);\n\n  void hsvToRgb(const std::vector<unsigned char>& hsv, std::vector<unsigned char>* rgb);\n\n  void createHeightInfo(/* protoBufType *intensity_map_info */);\n\n  std::unordered_map<Ndt3Tile::GridID, std::vector<ClusterSample>> grid2_samples_;\n};\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/intensity_map_builder.h"
		}
	}
]
I0402 15:44:28.881146  5535 json_parser.cpp:18] 
[
	9,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/intensity_map_builder.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All rights reserved.\n// Authors: Yongjian Zhao (yongjian.zhao@allride.ai)\n\n#pragma once\n\n#include <vector>\n\n#include <opencv2/opencv.hpp>\n\n#include \"ndt3tile.h\"\n#include \"ndt_map_builder.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstruct ClusterSample {\n  int point_num;\n  float intensity;\n  float height;\n\n  ClusterSample();\n  void merge(const ClusterSmaple& other);\n};\n\nclass IntensityMapBuilder : public NdtMapBuilder {\n public:\n  IntensityMapBuilder() = default;\n  ~IntensityMapBuilder() = default;\n\n  void buildIntensityMap(const std::string& output_folder);\n\n private:\n  struct QueueElement {\n    float distance;\n    size_t small_id;\n    size_t big_id;\n  };\n\n  struct QueueElementCompare {\n    bool operator(const QueueElement& left, const QueueElement& right) const {\n      // priority_queue.top() return the element with minimum distance\n      // need test\n      return left.distance > right.distance;\n    }\n  };\n\n  void heightCluster(std::vector<ClusterSample>* samples);\n\n  bool saveIntensityMap(const std::string& output_folder);\n\n  void createImage(cv::Mat* image);\n\n  void hsvToRgb(const std::vector<unsigned char>& hsv, std::vector<unsigned char>* rgb);\n\n  void createHeightInfo(/* protoBufType *intensity_map_info */);\n\n  std::unordered_map<Ndt3Tile::GridID, std::vector<ClusterSample>> grid2_samples_;\n};\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/intensity_map_builder.h"
		}
	}
]
I0402 15:44:28.894279  5535 json_parser.cpp:18] 
[
	10,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/intensity_map_builder.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All rights reserved.\n// Authors: Yongjian Zhao (yongjian.zhao@allride.ai)\n\n#pragma once\n\n#include <vector>\n\n#include <opencv2/opencv.hpp>\n\n#include \"ndt3tile.h\"\n#include \"ndt_map_builder.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstruct ClusterSample {\n  int point_num;\n  float intensity;\n  float height;\n\n  ClusterSample();\n  void merge(const ClusterSmaple& other);\n};\n\nclass IntensityMapBuilder : public NdtMapBuilder {\n public:\n  IntensityMapBuilder() = default;\n  ~IntensityMapBuilder() = default;\n\n  void buildIntensityMap(const std::string& output_folder);\n\n private:\n  struct QueueElement {\n    float distance;\n    size_t small_id;\n    size_t big_id;\n  };\n\n  struct QueueElementCompare {\n    bool operator(const QueueElement& left, const QueueElement& right) const {\n      // priority_queue.top() return the element with minimum distance\n      // need test\n      return left.distance > right.distance;\n    }\n  };\n\n  void heightCluster(std::vector<ClusterSample>* samples);\n\n  bool saveIntensityMap(const std::string& output_folder);\n\n  void createImage(cv::Mat* image);\n\n  void hsvToRgb(const std::vector<unsigned char>& hsv, std::vector<unsigned char>* rgb);\n\n  void createHeightInfo(/* protoBufType *intensity_map_info */);\n\n  std::unordered_map<Ndt3Tile::GridID, std::vector<ClusterSample>> grid2_samples_;\n};\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/intensity_map_builder.h"
		}
	}
]
I0402 15:45:06.423651  5535 json_parser.cpp:18] 
[
	11,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All rights reserved.\n// Authors: Yongjian Zhao (yongjian.zhao@allride.ai)\n\n#include <fstream>\n#include <iostream>\n#include <sstream>\n#include <vector>\n\n#include \"common/io/proto_io.h\"\n#include \"common/proto/config/config_map.pb.h\"\n#include \"map_layer_dictionary_parser.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstatic const float grid_size_ratio = 1000.0f;  // convert from m to mm,\n\nbool MapLayerDictionaryParser::load(const std::string& dict_file) {\n  proto::config::MapLayerDictionary dict;\n  if (!common::ProtoIO::readProtoFromTextFile(dict_file, &dict)) {\n    std::cerr << \"MapLayerDictionaryParser: failed to load from dictionary file!\" << std::endl;\n    std::cerr << \"dict_file: \" << dict_file << std::endl;\n    return false;\n  }\n\n  for (const auto& item : dict.items()) {\n    int layer_id = item.layer_id();\n    std::string type_name = item.type_name();\n    float grid_size = item.grid_size();\n    float tile_size = item.tile_size();\n\n    // compose the key\n    std::string key;\n    composeKey(type_name, grid_size, tile_size, &key);\n\n    // set unordered_map\n    id_to_key_[layer_id] = key;\n    key_to_id_[key] = layer_id;\n  }\n\n  return true;\n}\n\nbool MapLayerDictionaryParser::getInfoById(const int layer_id, std::string* type_name,\n                                           float* grid_size, float* tile_size) {\n  if (id_to_key_.count(layer_id) == 0) {\n    return false;\n  }\n\n  analyseKey(id_to_key_[layer_id], type_name, grid_size, tile_size);\n  return true;\n}\n\nbool MapLayerDictionaryParser::getIdByInfo(const std::string& type_name, const float& grid_size,\n                                           const float& tile_size, int* layer_id) {\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 0) {\n    return false;\n  }\n\n  *layer_id = key_to_id_[key];\n  return true;\n}\n\nfloat MapLayerDictionaryParser::getGridSize(const int layer_id) {\n  float grid_size;\n  getInfoById(layer_id, nullptr, &grid_size, nullptr);\n  return grid_size;\n}\n\nfloat MapLayerDictionaryParser::getTileSize(const int layer_id) {\n  float tile_size;\n  getInfoById(layer_id, nullptr, nullptr, &tile_size);\n  return tile_size;\n}\n\nstd::string MapLayerDictionaryParser::getTypeName(const int layer_id) {\n  std::string type_name;\n  getInfoById(layer_id, &type_name, nullptr, nullptr);\n  return type_name;\n}\n\nbool MapLayerDictionaryParser::addItem(const int layer_id, const std::string& type_name,\n                                       const float grid_size, const float tile_size) {\n  if (id_to_key_.count(layer_id) == 1) {\n    std::cerr << \"failed to add item: layer_id \" << layer_id << \" has already exited in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 1) {\n    std::cerr << \"failed to add item: layer configuration has already existed in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  id_to_key_[layer_id] = key;\n  key_to_id_[key] = layer_id;\n  return true;\n}\n\nbool MapLayerDictionaryParser::save(const std::string& dict_file) {\n  // sort layer id\n  std::vector<int> layer_ids;\n  for (auto& pair : id_to_key_) {\n    layer_ids.emplace_back(pair.first);\n  }\n  std::sort(layer_ids.begin(), layer_ids.end());\n\n  // add item to dict\n  proto::config::MapLayerDictionary dict;\n  for (auto& id : layer_ids) {\n    // analyze key\n    std::string type_name;\n    float grid_size;\n    float tile_size;\n    analyseKey(id_to_key_[id], &type_name, &grid_size, &tile_size);\n\n    // add item\n    proto::config::MapLayerItem* item = dict.add_items();\n    item->set_layer_id(id);\n    item->set_type_name(type_name);\n    item->set_grid_size(grid_size);\n    item->set_tile_size(tile_size);\n  }\n\n  // write dict to file\n  return common::ProtoIO::writeProtoToTextFile(dict_file, dict);\n}\n\nvoid MapLayerDictionaryParser::composeKey(const std::string& type_name, const float& grid_size,\n                                          const float& tile_size, std::string* key) {\n  std::stringstream str_stream;\n  str_stream << type_name << \"_\" << static_cast<int>(grid_size * grid_size_ratio) << \"_\"\n             << static_cast<int>(tile_size);\n  *key = str_stream.str();\n}\n\nvoid MapLayerDictionaryParser::analyseKey(const std::string& key, std::string* type_name,\n                                          float* grid_size, float* tile_size) {\n  std::vector<std::string> substrs;\n  substrs.resize(3);\n\n  // achieve sub strings from key\n  size_t tail = key.size() - 1;\n  for (int i = 0; i < 2; i++) {\n    size_t pos = key.rfind('_', tail);\n    substrs[2 - i] = key.substr(pos + 1, tail - pos);\n    tail = pos - 1;\n  }\n  substrs[0] = key.substr(0, tail + 1);\n\n  // output\n  if (tile_size != nullptr) {\n    *tile_size = std::stof(substrs[2]);\n  }\n  if (grid_size != nullptr) {\n    *grid_size = std::stof(substrs[1]) / grid_size_ratio;\n  }\n  if (type_name != nullptr) {\n    *type_name = substrs[0];\n  }\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp"
		}
	}
]
I0402 15:45:07.304581  5535 json_parser.cpp:18] 
[
	12,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All rights reserved.\n// Authors: Yongjian Zhao (yongjian.zhao@allride.ai)\n\n#include <fstream>\n#include <iostream>\n#include <sstream>\n#include <vector>\n\n#include \"common/io/proto_io.h\"\n#include \"common/proto/config/config_map.pb.h\"\n#include \"map_layer_dictionary_parser.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstatic const float grid_size_ratio = 1000.0f;  // convert from m to mm,\n\nbool MapLayerDictionaryParser::load(const std::string& dict_file) {\n  proto::config::MapLayerDictionary dict;\n  if (!common::ProtoIO::readProtoFromTextFile(dict_file, &dict)) {\n    std::cerr << \"MapLayerDictionaryParser: failed to load from dictionary file!\" << std::endl;\n    std::cerr << \"dict_file: \" << dict_file << std::endl;\n    return false;\n  }\n\n  for (const auto& item : dict.items()) {\n    int layer_id = item.layer_id();\n    std::string type_name = item.type_name();\n    float grid_size = item.grid_size();\n    float tile_size = item.tile_size();\n\n    // compose the key\n    std::string key;\n    composeKey(type_name, grid_size, tile_size, &key);\n\n    // set unordered_map\n    id_to_key_[layer_id] = key;\n    key_to_id_[key] = layer_id;\n  }\n\n  return true;\n}\n\nbool MapLayerDictionaryParser::getInfoById(const int layer_id, std::string* type_name,\n                                           float* grid_size, float* tile_size) {\n  if (id_to_key_.count(layer_id) == 0) {\n    return false;\n  }\n\n  analyseKey(id_to_key_[layer_id], type_name, grid_size, tile_size);\n  return true;\n}\n\nbool MapLayerDictionaryParser::getIdByInfo(const std::string& type_name, const float& grid_size,\n                                           const float& tile_size, int* layer_id) {\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 0) {\n    return false;\n  }\n\n  *layer_id = key_to_id_[key];\n  return true;\n}\n\nfloat MapLayerDictionaryParser::getGridSize(const int layer_id) {\n  float grid_size;\n  getInfoById(layer_id, nullptr, &grid_size, nullptr);\n  return grid_size;\n}\n\nfloat MapLayerDictionaryParser::getTileSize(const int layer_id) {\n  float tile_size;\n  getInfoById(layer_id, nullptr, nullptr, &tile_size);\n  return tile_size;\n}\n\nstd::string MapLayerDictionaryParser::getTypeName(const int layer_id) {\n  std::string type_name;\n  getInfoById(layer_id, &type_name, nullptr, nullptr);\n  return type_name;\n}\n\nbool MapLayerDictionaryParser::addItem(const int layer_id, const std::string& type_name,\n                                       const float grid_size, const float tile_size) {\n  if (id_to_key_.count(layer_id) == 1) {\n    std::cerr << \"failed to add item: layer_id \" << layer_id << \" has already exited in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 1) {\n    std::cerr << \"failed to add item: layer configuration has already existed in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  id_to_key_[layer_id] = key;\n  key_to_id_[key] = layer_id;\n  return true;\n}\n\nbool MapLayerDictionaryParser::save(const std::string& dict_file) {\n  // sort layer id\n  std::vector<int> layer_ids;\n  for (auto& pair : id_to_key_) {\n    layer_ids.emplace_back(pair.first);\n  }\n  std::sort(layer_ids.begin(), layer_ids.end());\n\n  // add item to dict\n  proto::config::MapLayerDictionary dict;\n  for (auto& id : layer_ids) {\n    // analyze key\n    std::string type_name;\n    float grid_size;\n    float tile_size;\n    analyseKey(id_to_key_[id], &type_name, &grid_size, &tile_size);\n\n    // add item\n    proto::config::MapLayerItem* item = dict.add_items();\n    item->set_layer_id(id);\n    item->set_type_name(type_name);\n    item->set_grid_size(grid_size);\n    item->set_tile_size(tile_size);\n  }\n\n  // write dict to file\n  return common::ProtoIO::writeProtoToTextFile(dict_file, dict);\n}\n\nvoid MapLayerDictionaryParser::composeKey(const std::string& type_name, const float& grid_size,\n                                          const float& tile_size, std::string* key) {\n  std::stringstream str_stream;\n  str_stream << type_name << \"_\" << static_cast<int>(grid_size * grid_size_ratio) << \"_\"\n             << static_cast<int>(tile_size);\n  *key = str_stream.str();\n}\n\nvoid MapLayerDictionaryParser::analyseKey(const std::string& key, std::string* type_name,\n                                          float* grid_size, float* tile_size) {\n  std::vector<std::string> substrs;\n  substrs.resize(3);\n\n  // achieve sub strings from key\n  size_t tail = key.size() - 1;\n  for (int i = 0; i < 2; i++) {\n    size_t pos = key.rfind('_', tail);\n    substrs[2 - i] = key.substr(pos + 1, tail - pos);\n    tail = pos - 1;\n  }\n  substrs[0] = key.substr(0, tail + 1);\n\n  // output\n  if (tile_size != nullptr) {\n    *tile_size = std::stof(substrs[2]);\n  }\n  if (grid_size != nullptr) {\n    *grid_size = std::stof(substrs[1]) / grid_size_ratio;\n  }\n  if (type_name != nullptr) {\n    *type_name = substrs[0];\n  }\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp"
		}
	}
]
I0402 15:45:08.946746  5535 json_parser.cpp:18] 
[
	13,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All rights reserved.\n// Authors: Yongjian Zhao (yongjian.zhao@allride.ai)\n\n#include <fstream>\n#include <iostream>\n#include <sstream>\n#include <vector>\n\n#include \"common/io/proto_io.h\"\n#include \"common/proto/config/config_map.pb.h\"\n#include \"map_layer_dictionary_parser.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstatic const float grid_size_ratio = 1000.0f;  // convert from m to mm,\n\nbool MapLayerDictionaryParser::load(const std::string& dict_file) {\n  proto::config::MapLayerDictionary dict;\n  if (!common::ProtoIO::readProtoFromTextFile(dict_file, &dict)) {\n    std::cerr << \"MapLayerDictionaryParser: failed to load from dictionary file!\" << std::endl;\n    std::cerr << \"dict_file: \" << dict_file << std::endl;\n    return false;\n  }\n\n  for (const auto& item : dict.items()) {\n    int layer_id = item.layer_id();\n    std::string type_name = item.type_name();\n    float grid_size = item.grid_size();\n    float tile_size = item.tile_size();\n\n    // compose the key\n    std::string key;\n    composeKey(type_name, grid_size, tile_size, &key);\n\n    // set unordered_map\n    id_to_key_[layer_id] = key;\n    key_to_id_[key] = layer_id;\n  }\n\n  return true;\n}\n\nbool MapLayerDictionaryParser::getInfoById(const int layer_id, std::string* type_name,\n                                           float* grid_size, float* tile_size) {\n  if (id_to_key_.count(layer_id) == 0) {\n    return false;\n  }\n\n  analyseKey(id_to_key_[layer_id], type_name, grid_size, tile_size);\n  return true;\n}\n\nbool MapLayerDictionaryParser::getIdByInfo(const std::string& type_name, const float& grid_size,\n                                           const float& tile_size, int* layer_id) {\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 0) {\n    return false;\n  }\n\n  *layer_id = key_to_id_[key];\n  return true;\n}\n\nfloat MapLayerDictionaryParser::getGridSize(const int layer_id) {\n  float grid_size;\n  getInfoById(layer_id, nullptr, &grid_size, nullptr);\n  return grid_size;\n}\n\nfloat MapLayerDictionaryParser::getTileSize(const int layer_id) {\n  float tile_size;\n  getInfoById(layer_id, nullptr, nullptr, &tile_size);\n  return tile_size;\n}\n\nstd::string MapLayerDictionaryParser::getTypeName(const int layer_id) {\n  std::string type_name;\n  getInfoById(layer_id, &type_name, nullptr, nullptr);\n  return type_name;\n}\n\nbool MapLayerDictionaryParser::addItem(const int layer_id, const std::string& type_name,\n                                       const float grid_size, const float tile_size) {\n  if (id_to_key_.count(layer_id) == 1) {\n    std::cerr << \"failed to add item: layer_id \" << layer_id << \" has already exited in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 1) {\n    std::cerr << \"failed to add item: layer configuration has already existed in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  id_to_key_[layer_id] = key;\n  key_to_id_[key] = layer_id;\n  return true;\n}\n\nbool MapLayerDictionaryParser::save(const std::string& dict_file) {\n  // sort layer id\n  std::vector<int> layer_ids;\n  for (auto& pair : id_to_key_) {\n    layer_ids.emplace_back(pair.first);\n  }\n  std::sort(layer_ids.begin(), layer_ids.end());\n\n  // add item to dict\n  proto::config::MapLayerDictionary dict;\n  for (auto& id : layer_ids) {\n    // analyze key\n    std::string type_name;\n    float grid_size;\n    float tile_size;\n    analyseKey(id_to_key_[id], &type_name, &grid_size, &tile_size);\n\n    // add item\n    proto::config::MapLayerItem* item = dict.add_items();\n    item->set_layer_id(id);\n    item->set_type_name(type_name);\n    item->set_grid_size(grid_size);\n    item->set_tile_size(tile_size);\n  }\n\n  // write dict to file\n  return common::ProtoIO::writeProtoToTextFile(dict_file, dict);\n}\n\nvoid MapLayerDictionaryParser::composeKey(const std::string& type_name, const float& grid_size,\n                                          const float& tile_size, std::string* key) {\n  std::stringstream str_stream;\n  str_stream << type_name << \"_\" << static_cast<int>(grid_size * grid_size_ratio) << \"_\"\n             << static_cast<int>(tile_size);\n  *key = str_stream.str();\n}\n\nvoid MapLayerDictionaryParser::analyseKey(const std::string& key, std::string* type_name,\n                                          float* grid_size, float* tile_size) {\n  std::vector<std::string> substrs;\n  substrs.resize(3);\n\n  // achieve sub strings from key\n  size_t tail = key.size() - 1;\n  for (int i = 0; i < 2; i++) {\n    size_t pos = key.rfind('_', tail);\n    substrs[2 - i] = key.substr(pos + 1, tail - pos);\n    tail = pos - 1;\n  }\n  substrs[0] = key.substr(0, tail + 1);\n\n  // output\n  if (tile_size != nullptr) {\n    *tile_size = std::stof(substrs[2]);\n  }\n  if (grid_size != nullptr) {\n    *grid_size = std::stof(substrs[1]) / grid_size_ratio;\n  }\n  if (type_name != nullptr) {\n    *type_name = substrs[0];\n  }\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp"
		}
	}
]
I0402 15:45:08.967274  5535 json_parser.cpp:18] 
[
	14,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All rights reserved.\n// Authors: Yongjian Zhao (yongjian.zhao@allride.ai)\n\n#include <fstream>\n#include <iostream>\n#include <sstream>\n#include <vector>\n\n#include \"common/io/proto_io.h\"\n#include \"common/proto/config/config_map.pb.h\"\n#include \"map_layer_dictionary_parser.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstatic const float grid_size_ratio = 1000.0f;  // convert from m to mm,\n\nbool MapLayerDictionaryParser::load(const std::string& dict_file) {\n  proto::config::MapLayerDictionary dict;\n  if (!common::ProtoIO::readProtoFromTextFile(dict_file, &dict)) {\n    std::cerr << \"MapLayerDictionaryParser: failed to load from dictionary file!\" << std::endl;\n    std::cerr << \"dict_file: \" << dict_file << std::endl;\n    return false;\n  }\n\n  for (const auto& item : dict.items()) {\n    int layer_id = item.layer_id();\n    std::string type_name = item.type_name();\n    float grid_size = item.grid_size();\n    float tile_size = item.tile_size();\n\n    // compose the key\n    std::string key;\n    composeKey(type_name, grid_size, tile_size, &key);\n\n    // set unordered_map\n    id_to_key_[layer_id] = key;\n    key_to_id_[key] = layer_id;\n  }\n\n  return true;\n}\n\nbool MapLayerDictionaryParser::getInfoById(const int layer_id, std::string* type_name,\n                                           float* grid_size, float* tile_size) {\n  if (id_to_key_.count(layer_id) == 0) {\n    return false;\n  }\n\n  analyseKey(id_to_key_[layer_id], type_name, grid_size, tile_size);\n  return true;\n}\n\nbool MapLayerDictionaryParser::getIdByInfo(const std::string& type_name, const float& grid_size,\n                                           const float& tile_size, int* layer_id) {\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 0) {\n    return false;\n  }\n\n  *layer_id = key_to_id_[key];\n  return true;\n}\n\nfloat MapLayerDictionaryParser::getGridSize(const int layer_id) {\n  float grid_size;\n  getInfoById(layer_id, nullptr, &grid_size, nullptr);\n  return grid_size;\n}\n\nfloat MapLayerDictionaryParser::getTileSize(const int layer_id) {\n  float tile_size;\n  getInfoById(layer_id, nullptr, nullptr, &tile_size);\n  return tile_size;\n}\n\nstd::string MapLayerDictionaryParser::getTypeName(const int layer_id) {\n  std::string type_name;\n  getInfoById(layer_id, &type_name, nullptr, nullptr);\n  return type_name;\n}\n\nbool MapLayerDictionaryParser::addItem(const int layer_id, const std::string& type_name,\n                                       const float grid_size, const float tile_size) {\n  if (id_to_key_.count(layer_id) == 1) {\n    std::cerr << \"failed to add item: layer_id \" << layer_id << \" has already exited in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 1) {\n    std::cerr << \"failed to add item: layer configuration has already existed in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  id_to_key_[layer_id] = key;\n  key_to_id_[key] = layer_id;\n  return true;\n}\n\nbool MapLayerDictionaryParser::save(const std::string& dict_file) {\n  // sort layer id\n  std::vector<int> layer_ids;\n  for (auto& pair : id_to_key_) {\n    layer_ids.emplace_back(pair.first);\n  }\n  std::sort(layer_ids.begin(), layer_ids.end());\n\n  // add item to dict\n  proto::config::MapLayerDictionary dict;\n  for (auto& id : layer_ids) {\n    // analyze key\n    std::string type_name;\n    float grid_size;\n    float tile_size;\n    analyseKey(id_to_key_[id], &type_name, &grid_size, &tile_size);\n\n    // add item\n    proto::config::MapLayerItem* item = dict.add_items();\n    item->set_layer_id(id);\n    item->set_type_name(type_name);\n    item->set_grid_size(grid_size);\n    item->set_tile_size(tile_size);\n  }\n\n  // write dict to file\n  return common::ProtoIO::writeProtoToTextFile(dict_file, dict);\n}\n\nvoid MapLayerDictionaryParser::composeKey(const std::string& type_name, const float& grid_size,\n                                          const float& tile_size, std::string* key) {\n  std::stringstream str_stream;\n  str_stream << type_name << \"_\" << static_cast<int>(grid_size * grid_size_ratio) << \"_\"\n             << static_cast<int>(tile_size);\n  *key = str_stream.str();\n}\n\nvoid MapLayerDictionaryParser::analyseKey(const std::string& key, std::string* type_name,\n                                          float* grid_size, float* tile_size) {\n  std::vector<std::string> substrs;\n  substrs.resize(3);\n\n  // achieve sub strings from key\n  size_t tail = key.size() - 1;\n  for (int i = 0; i < 2; i++) {\n    size_t pos = key.rfind('_', tail);\n    substrs[2 - i] = key.substr(pos + 1, tail - pos);\n    tail = pos - 1;\n  }\n  substrs[0] = key.substr(0, tail + 1);\n\n  // output\n  if (tile_size != nullptr) {\n    *tile_size = std::stof(substrs[2]);\n  }\n  if (grid_size != nullptr) {\n    *grid_size = std::stof(substrs[1]) / grid_size_ratio;\n  }\n  if (type_name != nullptr) {\n    *type_name = substrs[0];\n  }\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp"
		}
	}
]
I0402 15:45:08.986476  5535 json_parser.cpp:18] 
[
	15,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All rights reserved.\n// Authors: Yongjian Zhao (yongjian.zhao@allride.ai)\n\n#include <fstream>\n#include <iostream>\n#include <sstream>\n#include <vector>\n\n#include \"common/io/proto_io.h\"\n#include \"common/proto/config/config_map.pb.h\"\n#include \"map_layer_dictionary_parser.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstatic const float grid_size_ratio = 1000.0f;  // convert from m to mm,\n\nbool MapLayerDictionaryParser::load(const std::string& dict_file) {\n  proto::config::MapLayerDictionary dict;\n  if (!common::ProtoIO::readProtoFromTextFile(dict_file, &dict)) {\n    std::cerr << \"MapLayerDictionaryParser: failed to load from dictionary file!\" << std::endl;\n    std::cerr << \"dict_file: \" << dict_file << std::endl;\n    return false;\n  }\n\n  for (const auto& item : dict.items()) {\n    int layer_id = item.layer_id();\n    std::string type_name = item.type_name();\n    float grid_size = item.grid_size();\n    float tile_size = item.tile_size();\n\n    // compose the key\n    std::string key;\n    composeKey(type_name, grid_size, tile_size, &key);\n\n    // set unordered_map\n    id_to_key_[layer_id] = key;\n    key_to_id_[key] = layer_id;\n  }\n\n  return true;\n}\n\nbool MapLayerDictionaryParser::getInfoById(const int layer_id, std::string* type_name,\n                                           float* grid_size, float* tile_size) {\n  if (id_to_key_.count(layer_id) == 0) {\n    return false;\n  }\n\n  analyseKey(id_to_key_[layer_id], type_name, grid_size, tile_size);\n  return true;\n}\n\nbool MapLayerDictionaryParser::getIdByInfo(const std::string& type_name, const float& grid_size,\n                                           const float& tile_size, int* layer_id) {\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 0) {\n    return false;\n  }\n\n  *layer_id = key_to_id_[key];\n  return true;\n}\n\nfloat MapLayerDictionaryParser::getGridSize(const int layer_id) {\n  float grid_size;\n  getInfoById(layer_id, nullptr, &grid_size, nullptr);\n  return grid_size;\n}\n\nfloat MapLayerDictionaryParser::getTileSize(const int layer_id) {\n  float tile_size;\n  getInfoById(layer_id, nullptr, nullptr, &tile_size);\n  return tile_size;\n}\n\nstd::string MapLayerDictionaryParser::getTypeName(const int layer_id) {\n  std::string type_name;\n  getInfoById(layer_id, &type_name, nullptr, nullptr);\n  return type_name;\n}\n\nbool MapLayerDictionaryParser::addItem(const int layer_id, const std::string& type_name,\n                                       const float grid_size, const float tile_size) {\n  if (id_to_key_.count(layer_id) == 1) {\n    std::cerr << \"failed to add item: layer_id \" << layer_id << \" has already exited in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 1) {\n    std::cerr << \"failed to add item: layer configuration has already existed in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  id_to_key_[layer_id] = key;\n  key_to_id_[key] = layer_id;\n  return true;\n}\n\nbool MapLayerDictionaryParser::save(const std::string& dict_file) {\n  // sort layer id\n  std::vector<int> layer_ids;\n  for (auto& pair : id_to_key_) {\n    layer_ids.emplace_back(pair.first);\n  }\n  std::sort(layer_ids.begin(), layer_ids.end());\n\n  // add item to dict\n  proto::config::MapLayerDictionary dict;\n  for (auto& id : layer_ids) {\n    // analyze key\n    std::string type_name;\n    float grid_size;\n    float tile_size;\n    analyseKey(id_to_key_[id], &type_name, &grid_size, &tile_size);\n\n    // add item\n    proto::config::MapLayerItem* item = dict.add_items();\n    item->set_layer_id(id);\n    item->set_type_name(type_name);\n    item->set_grid_size(grid_size);\n    item->set_tile_size(tile_size);\n  }\n\n  // write dict to file\n  return common::ProtoIO::writeProtoToTextFile(dict_file, dict);\n}\n\nvoid MapLayerDictionaryParser::composeKey(const std::string& type_name, const float& grid_size,\n                                          const float& tile_size, std::string* key) {\n  std::stringstream str_stream;\n  str_stream << type_name << \"_\" << static_cast<int>(grid_size * grid_size_ratio) << \"_\"\n             << static_cast<int>(tile_size);\n  *key = str_stream.str();\n}\n\nvoid MapLayerDictionaryParser::analyseKey(const std::string& key, std::string* type_name,\n                                          float* grid_size, float* tile_size) {\n  std::vector<std::string> substrs;\n  substrs.resize(3);\n\n  // achieve sub strings from key\n  size_t tail = key.size() - 1;\n  for (int i = 0; i < 2; i++) {\n    size_t pos = key.rfind('_', tail);\n    substrs[2 - i] = key.substr(pos + 1, tail - pos);\n    tail = pos - 1;\n  }\n  substrs[0] = key.substr(0, tail + 1);\n\n  // output\n  if (tile_size != nullptr) {\n    *tile_size = std::stof(substrs[2]);\n  }\n  if (grid_size != nullptr) {\n    *grid_size = std::stof(substrs[1]) / grid_size_ratio;\n  }\n  if (type_name != nullptr) {\n    *type_name = substrs[0];\n  }\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp"
		}
	}
]
I0402 15:45:09.005884  5535 json_parser.cpp:18] 
[
	16,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/intensity_map_builder.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All rights reserved.\n// Authors: Yongjian Zhao (yongjian.zhao@allride.ai)\n\n#include <priority_queue>\n#include <set>\n\n#include \"intensity_map_builder.h\"\n\nvoid ClusterSample::ClusterSample(const ClusterSmaple& other) {\n  this->point_num += other.point_num;\n\n  float other_weight = static_cast<float>(other.point_num) / this->point_num;\n  float this_weight = 1.0f - other_weight;\n\n  this->height = this_weight * this->height + other_weight * other.height;\n  this->intensity = this_weigh * this->intensity + other_weight * other.intensity;\n}\n\nvoid IntensityMapBuilder::buildIntensityMap(const std::string& output_folder) {\n  // To initialize grid2_samples_, each ndt3 grid is one ClusterSample\n  // for each grid2 sample, there are several Cluster\n\n  // height cluster for each grid2_sample\n  for (auto& grid2_smaple : grid2_samples_) {\n    heightCluster(&grid2_smaple.second);\n  }\n\n  // create image acoording to grid2_samples_\n  cv::Mat intensity_image;\n  createImage(&intensity_image);\n\n  // create intensity_map_info according to grid2_samples_\n  /* protoBufType intensity_map_info */\n  createHeightInfo(/*&intensity_map_info*/);\n\n  // save image and intensity_map_info\n  saveIntensityMap(output_folder, intensity_image /*, intensity_map_info*/);\n}\n\nvoid IntensityMapBuilder::heightCluster(std::vector<ClusterSample>* samples) {\n  size_t sample_num = samples->size();\n\n  // make existing_sample_id\n  std::set<size_t> existing_sample_id;\n  for (size_t i = 0; i < sample_num; i++) {\n    existing_sample_id.insert(i);\n  }\n\n  // make distance_queue\n  std::priority_queue<QueueElement, std::vector<QueueElement>, QueueElementCompare> distance_queue;\n  for (size_t i = 0; i < sample_num; i++) {\n    for (size_t j = i + 1; j < sample_num; j++) {\n      float distance = fabs(samples->at(i).height - samples->at(j).height);\n      distance_queue.emplace(distance, i, j);\n    }\n  }\n\n  // cluster\n  const float distance_th = 4.0f;\n  while (true) {\n    // find min_distance between each ClusterSample\n    QueueElement element = distance_queue.top() distance_queue.pop();\n    if (element.distance > distance_th) {\n      break;\n    }\n\n    if (existing_sample_id.count(element.small_id) == 0) {\n      continue;\n    }\n\n    if (existing_sample_id.count(element.big_id) == 0) {\n      continue;\n    }\n\n    // merge two nearest samples\n    samples->at(element.small_id).merge(samples->at(element.big_id));\n    existing_sample_id.erase(element.big_id);\n    sample_num--;\n  }\n\n  if (existing_sample_id.size() != sample_num) {\n    std::cout << \"error: existing_sample_id.size() does not equal to sample_num!\" << std::endl;\n  }\n\n  // save cluster result\n  // need test\n  size_t i = 0;\n  for (size_t id& existing_sample_id) {\n    samples->at<i> = samples->at(id);\n  }\n  samples->resize(sample_num);\n}\n\nvoid IntensityMapBuilder::createImage(cv::Mat* image) {\n  // get necessary information from ndt_map_data_\n  int min_tile_id_x = 0, max_tile_id_x = 10;\n  int min_tile_id_y = 0, max_tile_id_y = 10;\n  float min_height = 0, max_height = 10;\n  float min_intensity = 0, max_intensity = 255;\n\n  int image_width =\n      static_cast<int>((max_tile_id_x - min_tile_id_x + 1) * param_.tile_size / param_.grid_size);\n  int image_height =\n      static_cast<int>((max_tile_id_y - min_tile_id_y + 1) * param_.tile_size / param_.grid_size);\n\n  // make image\n  cv::Mat blank_image = cv::Mat::zeros(image_height, image_width, CV_U8C3);\n  blank_image.copyTo(*image);\n  for (auto grid2_sample : grid2_samples_) {\n    // set pixel value\n  }\n}\n\nvoid IntensityMapBuilder::createHeightInfo(/* protoBufType *intensity_map_info */) {}\n\nbool IntensityMapBuilder::saveIntensityMap(const std::string& output_folder, const cv::Mat& image\n                                           /*const protoBufType *intensity_map_info */) {\n  // check or make output folder\n\n  // save image\n  std::string image_name = output_folder + \"/intensity_image.png\";\n  cv::imwrite(image_name, image);\n\n  // save intensity_map_info\n\n  return true;\n}\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/intensity_map_builder.cpp"
		}
	}
]
I0402 15:45:09.060981  5535 json_parser.cpp:18] 
[
	17,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/intensity_map_builder.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All rights reserved.\n// Authors: Yongjian Zhao (yongjian.zhao@allride.ai)\n\n#include <priority_queue>\n#include <set>\n\n#include \"intensity_map_builder.h\"\n\nvoid ClusterSample::ClusterSample(const ClusterSmaple& other) {\n  this->point_num += other.point_num;\n\n  float other_weight = static_cast<float>(other.point_num) / this->point_num;\n  float this_weight = 1.0f - other_weight;\n\n  this->height = this_weight * this->height + other_weight * other.height;\n  this->intensity = this_weigh * this->intensity + other_weight * other.intensity;\n}\n\nvoid IntensityMapBuilder::buildIntensityMap(const std::string& output_folder) {\n  // To initialize grid2_samples_, each ndt3 grid is one ClusterSample\n  // for each grid2 sample, there are several Cluster\n\n  // height cluster for each grid2_sample\n  for (auto& grid2_smaple : grid2_samples_) {\n    heightCluster(&grid2_smaple.second);\n  }\n\n  // create image acoording to grid2_samples_\n  cv::Mat intensity_image;\n  createImage(&intensity_image);\n\n  // create intensity_map_info according to grid2_samples_\n  /* protoBufType intensity_map_info */\n  createHeightInfo(/*&intensity_map_info*/);\n\n  // save image and intensity_map_info\n  saveIntensityMap(output_folder, intensity_image /*, intensity_map_info*/);\n}\n\nvoid IntensityMapBuilder::heightCluster(std::vector<ClusterSample>* samples) {\n  size_t sample_num = samples->size();\n\n  // make existing_sample_id\n  std::set<size_t> existing_sample_id;\n  for (size_t i = 0; i < sample_num; i++) {\n    existing_sample_id.insert(i);\n  }\n\n  // make distance_queue\n  std::priority_queue<QueueElement, std::vector<QueueElement>, QueueElementCompare> distance_queue;\n  for (size_t i = 0; i < sample_num; i++) {\n    for (size_t j = i + 1; j < sample_num; j++) {\n      float distance = fabs(samples->at(i).height - samples->at(j).height);\n      distance_queue.emplace(distance, i, j);\n    }\n  }\n\n  // cluster\n  const float distance_th = 4.0f;\n  while (true) {\n    // find min_distance between each ClusterSample\n    QueueElement element = distance_queue.top() distance_queue.pop();\n    if (element.distance > distance_th) {\n      break;\n    }\n\n    if (existing_sample_id.count(element.small_id) == 0) {\n      continue;\n    }\n\n    if (existing_sample_id.count(element.big_id) == 0) {\n      continue;\n    }\n\n    // merge two nearest samples\n    samples->at(element.small_id).merge(samples->at(element.big_id));\n    existing_sample_id.erase(element.big_id);\n    sample_num--;\n  }\n\n  if (existing_sample_id.size() != sample_num) {\n    std::cout << \"error: existing_sample_id.size() does not equal to sample_num!\" << std::endl;\n  }\n\n  // save cluster result\n  // need test\n  size_t i = 0;\n  for (size_t id& existing_sample_id) {\n    samples->at<i> = samples->at(id);\n  }\n  samples->resize(sample_num);\n}\n\nvoid IntensityMapBuilder::createImage(cv::Mat* image) {\n  // get necessary information from ndt_map_data_\n  int min_tile_id_x = 0, max_tile_id_x = 10;\n  int min_tile_id_y = 0, max_tile_id_y = 10;\n  float min_height = 0, max_height = 10;\n  float min_intensity = 0, max_intensity = 255;\n\n  int image_width =\n      static_cast<int>((max_tile_id_x - min_tile_id_x + 1) * param_.tile_size / param_.grid_size);\n  int image_height =\n      static_cast<int>((max_tile_id_y - min_tile_id_y + 1) * param_.tile_size / param_.grid_size);\n\n  // make image\n  cv::Mat blank_image = cv::Mat::zeros(image_height, image_width, CV_U8C3);\n  blank_image.copyTo(*image);\n  for (auto grid2_sample : grid2_samples_) {\n    // set pixel value\n  }\n}\n\nvoid IntensityMapBuilder::createHeightInfo(/* protoBufType *intensity_map_info */) {}\n\nbool IntensityMapBuilder::saveIntensityMap(const std::string& output_folder, const cv::Mat& image\n                                           /*const protoBufType *intensity_map_info */) {\n  // check or make output folder\n\n  // save image\n  std::string image_name = output_folder + \"/intensity_image.png\";\n  cv::imwrite(image_name, image);\n\n  // save intensity_map_info\n\n  return true;\n}\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/intensity_map_builder.cpp"
		}
	}
]
I0402 15:45:20.777742  5535 json_parser.cpp:18] 
[
	18,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/intensity_map_builder.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All rights reserved.\n// Authors: Yongjian Zhao (yongjian.zhao@allride.ai)\n\n#include <priority_queue>\n#include <set>\n\n#include \"intensity_map_builder.h\"\n\nvoid ClusterSample::ClusterSample(const ClusterSmaple& other) {\n  this->point_num += other.point_num;\n\n  float other_weight = static_cast<float>(other.point_num) / this->point_num;\n  float this_weight = 1.0f - other_weight;\n\n  this->height = this_weight * this->height + other_weight * other.height;\n  this->intensity = this_weigh * this->intensity + other_weight * other.intensity;\n}\n\nvoid IntensityMapBuilder::buildIntensityMap(const std::string& output_folder) {\n  // To initialize grid2_samples_, each ndt3 grid is one ClusterSample\n  // for each grid2 sample, there are several Cluster\n\n  // height cluster for each grid2_sample\n  for (auto& grid2_smaple : grid2_samples_) {\n    heightCluster(&grid2_smaple.second);\n  }\n\n  // create image acoording to grid2_samples_\n  cv::Mat intensity_image;\n  createImage(&intensity_image);\n\n  // create intensity_map_info according to grid2_samples_\n  /* protoBufType intensity_map_info */\n  createHeightInfo(/*&intensity_map_info*/);\n\n  // save image and intensity_map_info\n  saveIntensityMap(output_folder, intensity_image /*, intensity_map_info*/);\n}\n\nvoid IntensityMapBuilder::heightCluster(std::vector<ClusterSample>* samples) {\n  size_t sample_num = samples->size();\n\n  // make existing_sample_id\n  std::set<size_t> existing_sample_id;\n  for (size_t i = 0; i < sample_num; i++) {\n    existing_sample_id.insert(i);\n  }\n\n  // make distance_queue\n  std::priority_queue<QueueElement, std::vector<QueueElement>, QueueElementCompare> distance_queue;\n  for (size_t i = 0; i < sample_num; i++) {\n    for (size_t j = i + 1; j < sample_num; j++) {\n      float distance = fabs(samples->at(i).height - samples->at(j).height);\n      distance_queue.emplace(distance, i, j);\n    }\n  }\n\n  // cluster\n  const float distance_th = 4.0f;\n  while (true) {\n    // find min_distance between each ClusterSample\n    QueueElement element = distance_queue.top() distance_queue.pop();\n    if (element.distance > distance_th) {\n      break;\n    }\n\n    if (existing_sample_id.count(element.small_id) == 0) {\n      continue;\n    }\n\n    if (existing_sample_id.count(element.big_id) == 0) {\n      continue;\n    }\n\n    // merge two nearest samples\n    samples->at(element.small_id).merge(samples->at(element.big_id));\n    existing_sample_id.erase(element.big_id);\n    sample_num--;\n  }\n\n  if (existing_sample_id.size() != sample_num) {\n    std::cout << \"error: existing_sample_id.size() does not equal to sample_num!\" << std::endl;\n  }\n\n  // save cluster result\n  // need test\n  size_t i = 0;\n  for (size_t id& existing_sample_id) {\n    samples->at<i> = samples->at(id);\n  }\n  samples->resize(sample_num);\n}\n\nvoid IntensityMapBuilder::createImage(cv::Mat* image) {\n  // get necessary information from ndt_map_data_\n  int min_tile_id_x = 0, max_tile_id_x = 10;\n  int min_tile_id_y = 0, max_tile_id_y = 10;\n  float min_height = 0, max_height = 10;\n  float min_intensity = 0, max_intensity = 255;\n\n  int image_width =\n      static_cast<int>((max_tile_id_x - min_tile_id_x + 1) * param_.tile_size / param_.grid_size);\n  int image_height =\n      static_cast<int>((max_tile_id_y - min_tile_id_y + 1) * param_.tile_size / param_.grid_size);\n\n  // make image\n  cv::Mat blank_image = cv::Mat::zeros(image_height, image_width, CV_U8C3);\n  blank_image.copyTo(*image);\n  for (auto grid2_sample : grid2_samples_) {\n    // set pixel value\n  }\n}\n\nvoid IntensityMapBuilder::createHeightInfo(/* protoBufType *intensity_map_info */) {}\n\nbool IntensityMapBuilder::saveIntensityMap(const std::string& output_folder, const cv::Mat& image\n                                           /*const protoBufType *intensity_map_info */) {\n  // check or make output folder\n\n  // save image\n  std::string image_name = output_folder + \"/intensity_image.png\";\n  cv::imwrite(image_name, image);\n\n  // save intensity_map_info\n\n  return true;\n}\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/intensity_map_builder.cpp"
		}
	}
]
I0402 15:45:27.339282  5535 json_parser.cpp:18] 
[
	19,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/intensity_map_builder.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All rights reserved.\n// Authors: Yongjian Zhao (yongjian.zhao@allride.ai)\n\n#include <priority_queue>\n#include <set>\n\n#include \"intensity_map_builder.h\"\n\nvoid ClusterSample::ClusterSample(const ClusterSmaple& other) {\n  this->point_num += other.point_num;\n\n  float other_weight = static_cast<float>(other.point_num) / this->point_num;\n  float this_weight = 1.0f - other_weight;\n\n  this->height = this_weight * this->height + other_weight * other.height;\n  this->intensity = this_weigh * this->intensity + other_weight * other.intensity;\n}\n\nvoid IntensityMapBuilder::buildIntensityMap(const std::string& output_folder) {\n  // To initialize grid2_samples_, each ndt3 grid is one ClusterSample\n  // for each grid2 sample, there are several Cluster\n\n  // height cluster for each grid2_sample\n  for (auto& grid2_smaple : grid2_samples_) {\n    heightCluster(&grid2_smaple.second);\n  }\n\n  // create image acoording to grid2_samples_\n  cv::Mat intensity_image;\n  createImage(&intensity_image);\n\n  // create intensity_map_info according to grid2_samples_\n  /* protoBufType intensity_map_info */\n  createHeightInfo(/*&intensity_map_info*/);\n\n  // save image and intensity_map_info\n  saveIntensityMap(output_folder, intensity_image /*, intensity_map_info*/);\n}\n\nvoid IntensityMapBuilder::heightCluster(std::vector<ClusterSample>* samples) {\n  size_t sample_num = samples->size();\n\n  // make existing_sample_id\n  std::set<size_t> existing_sample_id;\n  for (size_t i = 0; i < sample_num; i++) {\n    existing_sample_id.insert(i);\n  }\n\n  // make distance_queue\n  std::priority_queue<QueueElement, std::vector<QueueElement>, QueueElementCompare> distance_queue;\n  for (size_t i = 0; i < sample_num; i++) {\n    for (size_t j = i + 1; j < sample_num; j++) {\n      float distance = fabs(samples->at(i).height - samples->at(j).height);\n      distance_queue.emplace(distance, i, j);\n    }\n  }\n\n  // cluster\n  const float distance_th = 4.0f;\n  while (true) {\n    // find min_distance between each ClusterSample\n    QueueElement element = distance_queue.top() distance_queue.pop();\n    if (element.distance > distance_th) {\n      break;\n    }\n\n    if (existing_sample_id.count(element.small_id) == 0) {\n      continue;\n    }\n\n    if (existing_sample_id.count(element.big_id) == 0) {\n      continue;\n    }\n\n    // merge two nearest samples\n    samples->at(element.small_id).merge(samples->at(element.big_id));\n    existing_sample_id.erase(element.big_id);\n    sample_num--;\n  }\n\n  if (existing_sample_id.size() != sample_num) {\n    std::cout << \"error: existing_sample_id.size() does not equal to sample_num!\" << std::endl;\n  }\n\n  // save cluster result\n  // need test\n  size_t i = 0;\n  for (size_t id& existing_sample_id) {\n    samples->at<i> = samples->at(id);\n  }\n  samples->resize(sample_num);\n}\n\nvoid IntensityMapBuilder::createImage(cv::Mat* image) {\n  // get necessary information from ndt_map_data_\n  int min_tile_id_x = 0, max_tile_id_x = 10;\n  int min_tile_id_y = 0, max_tile_id_y = 10;\n  float min_height = 0, max_height = 10;\n  float min_intensity = 0, max_intensity = 255;\n\n  int image_width =\n      static_cast<int>((max_tile_id_x - min_tile_id_x + 1) * param_.tile_size / param_.grid_size);\n  int image_height =\n      static_cast<int>((max_tile_id_y - min_tile_id_y + 1) * param_.tile_size / param_.grid_size);\n\n  // make image\n  cv::Mat blank_image = cv::Mat::zeros(image_height, image_width, CV_U8C3);\n  blank_image.copyTo(*image);\n  for (auto grid2_sample : grid2_samples_) {\n    // set pixel value\n  }\n}\n\nvoid IntensityMapBuilder::createHeightInfo(/* protoBufType *intensity_map_info */) {}\n\nbool IntensityMapBuilder::saveIntensityMap(const std::string& output_folder, const cv::Mat& image\n                                           /*const protoBufType *intensity_map_info */) {\n  // check or make output folder\n\n  // save image\n  std::string image_name = output_folder + \"/intensity_image.png\";\n  cv::imwrite(image_name, image);\n\n  // save intensity_map_info\n\n  return true;\n}\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/intensity_map_builder.cpp"
		}
	}
]
I0402 15:45:27.352947  5535 json_parser.cpp:18] 
[
	20,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/intensity_map_builder.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All rights reserved.\n// Authors: Yongjian Zhao (yongjian.zhao@allride.ai)\n\n#include <priority_queue>\n#include <set>\n\n#include \"intensity_map_builder.h\"\n\nvoid ClusterSample::ClusterSample(const ClusterSmaple& other) {\n  this->point_num += other.point_num;\n\n  float other_weight = static_cast<float>(other.point_num) / this->point_num;\n  float this_weight = 1.0f - other_weight;\n\n  this->height = this_weight * this->height + other_weight * other.height;\n  this->intensity = this_weigh * this->intensity + other_weight * other.intensity;\n}\n\nvoid IntensityMapBuilder::buildIntensityMap(const std::string& output_folder) {\n  // To initialize grid2_samples_, each ndt3 grid is one ClusterSample\n  // for each grid2 sample, there are several Cluster\n\n  // height cluster for each grid2_sample\n  for (auto& grid2_smaple : grid2_samples_) {\n    heightCluster(&grid2_smaple.second);\n  }\n\n  // create image acoording to grid2_samples_\n  cv::Mat intensity_image;\n  createImage(&intensity_image);\n\n  // create intensity_map_info according to grid2_samples_\n  /* protoBufType intensity_map_info */\n  createHeightInfo(/*&intensity_map_info*/);\n\n  // save image and intensity_map_info\n  saveIntensityMap(output_folder, intensity_image /*, intensity_map_info*/);\n}\n\nvoid IntensityMapBuilder::heightCluster(std::vector<ClusterSample>* samples) {\n  size_t sample_num = samples->size();\n\n  // make existing_sample_id\n  std::set<size_t> existing_sample_id;\n  for (size_t i = 0; i < sample_num; i++) {\n    existing_sample_id.insert(i);\n  }\n\n  // make distance_queue\n  std::priority_queue<QueueElement, std::vector<QueueElement>, QueueElementCompare> distance_queue;\n  for (size_t i = 0; i < sample_num; i++) {\n    for (size_t j = i + 1; j < sample_num; j++) {\n      float distance = fabs(samples->at(i).height - samples->at(j).height);\n      distance_queue.emplace(distance, i, j);\n    }\n  }\n\n  // cluster\n  const float distance_th = 4.0f;\n  while (true) {\n    // find min_distance between each ClusterSample\n    QueueElement element = distance_queue.top() distance_queue.pop();\n    if (element.distance > distance_th) {\n      break;\n    }\n\n    if (existing_sample_id.count(element.small_id) == 0) {\n      continue;\n    }\n\n    if (existing_sample_id.count(element.big_id) == 0) {\n      continue;\n    }\n\n    // merge two nearest samples\n    samples->at(element.small_id).merge(samples->at(element.big_id));\n    existing_sample_id.erase(element.big_id);\n    sample_num--;\n  }\n\n  if (existing_sample_id.size() != sample_num) {\n    std::cout << \"error: existing_sample_id.size() does not equal to sample_num!\" << std::endl;\n  }\n\n  // save cluster result\n  // need test\n  size_t i = 0;\n  for (size_t id& existing_sample_id) {\n    samples->at<i> = samples->at(id);\n  }\n  samples->resize(sample_num);\n}\n\nvoid IntensityMapBuilder::createImage(cv::Mat* image) {\n  // get necessary information from ndt_map_data_\n  int min_tile_id_x = 0, max_tile_id_x = 10;\n  int min_tile_id_y = 0, max_tile_id_y = 10;\n  float min_height = 0, max_height = 10;\n  float min_intensity = 0, max_intensity = 255;\n\n  int image_width =\n      static_cast<int>((max_tile_id_x - min_tile_id_x + 1) * param_.tile_size / param_.grid_size);\n  int image_height =\n      static_cast<int>((max_tile_id_y - min_tile_id_y + 1) * param_.tile_size / param_.grid_size);\n\n  // make image\n  cv::Mat blank_image = cv::Mat::zeros(image_height, image_width, CV_U8C3);\n  blank_image.copyTo(*image);\n  for (auto grid2_sample : grid2_samples_) {\n    // set pixel value\n  }\n}\n\nvoid IntensityMapBuilder::createHeightInfo(/* protoBufType *intensity_map_info */) {}\n\nbool IntensityMapBuilder::saveIntensityMap(const std::string& output_folder, const cv::Mat& image\n                                           /*const protoBufType *intensity_map_info */) {\n  // check or make output folder\n\n  // save image\n  std::string image_name = output_folder + \"/intensity_image.png\";\n  cv::imwrite(image_name, image);\n\n  // save intensity_map_info\n\n  return true;\n}\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/intensity_map_builder.cpp"
		}
	}
]
I0402 15:45:27.363896  5535 json_parser.cpp:18] 
[
	21,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/intensity_map_builder.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All rights reserved.\n// Authors: Yongjian Zhao (yongjian.zhao@allride.ai)\n\n#include <priority_queue>\n#include <set>\n\n#include \"intensity_map_builder.h\"\n\nvoid ClusterSample::ClusterSample(const ClusterSmaple& other) {\n  this->point_num += other.point_num;\n\n  float other_weight = static_cast<float>(other.point_num) / this->point_num;\n  float this_weight = 1.0f - other_weight;\n\n  this->height = this_weight * this->height + other_weight * other.height;\n  this->intensity = this_weigh * this->intensity + other_weight * other.intensity;\n}\n\nvoid IntensityMapBuilder::buildIntensityMap(const std::string& output_folder) {\n  // To initialize grid2_samples_, each ndt3 grid is one ClusterSample\n  // for each grid2 sample, there are several Cluster\n\n  // height cluster for each grid2_sample\n  for (auto& grid2_smaple : grid2_samples_) {\n    heightCluster(&grid2_smaple.second);\n  }\n\n  // create image acoording to grid2_samples_\n  cv::Mat intensity_image;\n  createImage(&intensity_image);\n\n  // create intensity_map_info according to grid2_samples_\n  /* protoBufType intensity_map_info */\n  createHeightInfo(/*&intensity_map_info*/);\n\n  // save image and intensity_map_info\n  saveIntensityMap(output_folder, intensity_image /*, intensity_map_info*/);\n}\n\nvoid IntensityMapBuilder::heightCluster(std::vector<ClusterSample>* samples) {\n  size_t sample_num = samples->size();\n\n  // make existing_sample_id\n  std::set<size_t> existing_sample_id;\n  for (size_t i = 0; i < sample_num; i++) {\n    existing_sample_id.insert(i);\n  }\n\n  // make distance_queue\n  std::priority_queue<QueueElement, std::vector<QueueElement>, QueueElementCompare> distance_queue;\n  for (size_t i = 0; i < sample_num; i++) {\n    for (size_t j = i + 1; j < sample_num; j++) {\n      float distance = fabs(samples->at(i).height - samples->at(j).height);\n      distance_queue.emplace(distance, i, j);\n    }\n  }\n\n  // cluster\n  const float distance_th = 4.0f;\n  while (true) {\n    // find min_distance between each ClusterSample\n    QueueElement element = distance_queue.top() distance_queue.pop();\n    if (element.distance > distance_th) {\n      break;\n    }\n\n    if (existing_sample_id.count(element.small_id) == 0) {\n      continue;\n    }\n\n    if (existing_sample_id.count(element.big_id) == 0) {\n      continue;\n    }\n\n    // merge two nearest samples\n    samples->at(element.small_id).merge(samples->at(element.big_id));\n    existing_sample_id.erase(element.big_id);\n    sample_num--;\n  }\n\n  if (existing_sample_id.size() != sample_num) {\n    std::cout << \"error: existing_sample_id.size() does not equal to sample_num!\" << std::endl;\n  }\n\n  // save cluster result\n  // need test\n  size_t i = 0;\n  for (size_t id& existing_sample_id) {\n    samples->at<i> = samples->at(id);\n  }\n  samples->resize(sample_num);\n}\n\nvoid IntensityMapBuilder::createImage(cv::Mat* image) {\n  // get necessary information from ndt_map_data_\n  int min_tile_id_x = 0, max_tile_id_x = 10;\n  int min_tile_id_y = 0, max_tile_id_y = 10;\n  float min_height = 0, max_height = 10;\n  float min_intensity = 0, max_intensity = 255;\n\n  int image_width =\n      static_cast<int>((max_tile_id_x - min_tile_id_x + 1) * param_.tile_size / param_.grid_size);\n  int image_height =\n      static_cast<int>((max_tile_id_y - min_tile_id_y + 1) * param_.tile_size / param_.grid_size);\n\n  // make image\n  cv::Mat blank_image = cv::Mat::zeros(image_height, image_width, CV_U8C3);\n  blank_image.copyTo(*image);\n  for (auto grid2_sample : grid2_samples_) {\n    // set pixel value\n  }\n}\n\nvoid IntensityMapBuilder::createHeightInfo(/* protoBufType *intensity_map_info */) {}\n\nbool IntensityMapBuilder::saveIntensityMap(const std::string& output_folder, const cv::Mat& image\n                                           /*const protoBufType *intensity_map_info */) {\n  // check or make output folder\n\n  // save image\n  std::string image_name = output_folder + \"/intensity_image.png\";\n  cv::imwrite(image_name, image);\n\n  // save intensity_map_info\n\n  return true;\n}\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/intensity_map_builder.cpp"
		}
	}
]
I0402 15:45:27.459075  5535 json_parser.cpp:18] 
[
	22,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/lmdb_database.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nbool LmdbDatabase::open(const std::string& path, LocalDatabase::MODE mode) {}\nbool LmdbDatabase::isOpen() {}\nbool LmdbDatabase::close() {}\nbool LmdbDatabase::get(const std::string& key, std::string* value) {}\nbool LmdbDatabase::put(const std::string& key, const std::string& value) {}\nbool LmdbDatabase::exist(const std::string& key) {}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/lmdb_database.cpp"
		}
	}
]
I0402 15:45:27.598389  5535 json_parser.cpp:18] 
[
	23,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/lmdb_database.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nbool LmdbDatabase::open(const std::string& path, LocalDatabase::MODE mode) {}\nbool LmdbDatabase::isOpen() {}\nbool LmdbDatabase::close() {}\nbool LmdbDatabase::get(const std::string& key, std::string* value) {}\nbool LmdbDatabase::put(const std::string& key, const std::string& value) {}\nbool LmdbDatabase::exist(const std::string& key) {}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/lmdb_database.cpp"
		}
	}
]
I0402 15:45:28.787948  5535 json_parser.cpp:18] 
[
	24,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/lmdb_database.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nbool LmdbDatabase::open(const std::string& path, LocalDatabase::MODE mode) {}\nbool LmdbDatabase::isOpen() {}\nbool LmdbDatabase::close() {}\nbool LmdbDatabase::get(const std::string& key, std::string* value) {}\nbool LmdbDatabase::put(const std::string& key, const std::string& value) {}\nbool LmdbDatabase::exist(const std::string& key) {}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/lmdb_database.cpp"
		}
	}
]
I0402 15:45:28.806027  5535 json_parser.cpp:18] 
[
	25,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/lmdb_database.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nbool LmdbDatabase::open(const std::string& path, LocalDatabase::MODE mode) {}\nbool LmdbDatabase::isOpen() {}\nbool LmdbDatabase::close() {}\nbool LmdbDatabase::get(const std::string& key, std::string* value) {}\nbool LmdbDatabase::put(const std::string& key, const std::string& value) {}\nbool LmdbDatabase::exist(const std::string& key) {}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/lmdb_database.cpp"
		}
	}
]
I0402 15:45:28.817843  5535 json_parser.cpp:18] 
[
	26,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/lmdb_database.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nbool LmdbDatabase::open(const std::string& path, LocalDatabase::MODE mode) {}\nbool LmdbDatabase::isOpen() {}\nbool LmdbDatabase::close() {}\nbool LmdbDatabase::get(const std::string& key, std::string* value) {}\nbool LmdbDatabase::put(const std::string& key, const std::string& value) {}\nbool LmdbDatabase::exist(const std::string& key) {}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/lmdb_database.cpp"
		}
	}
]
I0402 15:45:28.913523  5535 json_parser.cpp:18] 
[
	27,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/lmdb_database.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include <string>\n\n#include \"local_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass LmdbDatabase : public LocalDatabase {\n public:\n  /// @brief implemention of LocalDatabase::open\n  /// @see LocalDatabase for more infomation\n  bool open(const std::string& path, LocalDatabase::MODE mode) override;\n\n  /// @brief implemention of LocalDatabase::isOpen\n  /// @see LocalDatabase for more infomation\n  bool isOpen() override;\n\n  /// @brief implemention of LocalDatabase::close\n  /// @see LocalDatabase for more infomation\n  bool close() override;\n\n  /// @brief implemention of LocalDatabase::get\n  /// @see LocalDatabase for more infomation\n  bool get(const std::string& key, std::string* value) override;\n\n  /// @brief implemention of LocalDatabase::put\n  /// @see LocalDatabase for more infomation\n  bool put(const std::string& key, const std::string& value) override;\n\n  /// @brief implemention of LocalDatabase::exist\n  /// @see LocalDatabase for more infomation\n  bool exist(const std::string& key) override;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/lmdb_database.h"
		}
	}
]
I0402 15:45:29.037281  5535 json_parser.cpp:18] 
[
	28,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/lmdb_database.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include <string>\n\n#include \"local_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass LmdbDatabase : public LocalDatabase {\n public:\n  /// @brief implemention of LocalDatabase::open\n  /// @see LocalDatabase for more infomation\n  bool open(const std::string& path, LocalDatabase::MODE mode) override;\n\n  /// @brief implemention of LocalDatabase::isOpen\n  /// @see LocalDatabase for more infomation\n  bool isOpen() override;\n\n  /// @brief implemention of LocalDatabase::close\n  /// @see LocalDatabase for more infomation\n  bool close() override;\n\n  /// @brief implemention of LocalDatabase::get\n  /// @see LocalDatabase for more infomation\n  bool get(const std::string& key, std::string* value) override;\n\n  /// @brief implemention of LocalDatabase::put\n  /// @see LocalDatabase for more infomation\n  bool put(const std::string& key, const std::string& value) override;\n\n  /// @brief implemention of LocalDatabase::exist\n  /// @see LocalDatabase for more infomation\n  bool exist(const std::string& key) override;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/lmdb_database.h"
		}
	}
]
I0402 15:45:30.393734  5535 json_parser.cpp:18] 
[
	29,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/lmdb_database.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include <string>\n\n#include \"local_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass LmdbDatabase : public LocalDatabase {\n public:\n  /// @brief implemention of LocalDatabase::open\n  /// @see LocalDatabase for more infomation\n  bool open(const std::string& path, LocalDatabase::MODE mode) override;\n\n  /// @brief implemention of LocalDatabase::isOpen\n  /// @see LocalDatabase for more infomation\n  bool isOpen() override;\n\n  /// @brief implemention of LocalDatabase::close\n  /// @see LocalDatabase for more infomation\n  bool close() override;\n\n  /// @brief implemention of LocalDatabase::get\n  /// @see LocalDatabase for more infomation\n  bool get(const std::string& key, std::string* value) override;\n\n  /// @brief implemention of LocalDatabase::put\n  /// @see LocalDatabase for more infomation\n  bool put(const std::string& key, const std::string& value) override;\n\n  /// @brief implemention of LocalDatabase::exist\n  /// @see LocalDatabase for more infomation\n  bool exist(const std::string& key) override;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/lmdb_database.h"
		}
	}
]
I0402 15:45:30.411718  5535 json_parser.cpp:18] 
[
	30,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/lmdb_database.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include <string>\n\n#include \"local_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass LmdbDatabase : public LocalDatabase {\n public:\n  /// @brief implemention of LocalDatabase::open\n  /// @see LocalDatabase for more infomation\n  bool open(const std::string& path, LocalDatabase::MODE mode) override;\n\n  /// @brief implemention of LocalDatabase::isOpen\n  /// @see LocalDatabase for more infomation\n  bool isOpen() override;\n\n  /// @brief implemention of LocalDatabase::close\n  /// @see LocalDatabase for more infomation\n  bool close() override;\n\n  /// @brief implemention of LocalDatabase::get\n  /// @see LocalDatabase for more infomation\n  bool get(const std::string& key, std::string* value) override;\n\n  /// @brief implemention of LocalDatabase::put\n  /// @see LocalDatabase for more infomation\n  bool put(const std::string& key, const std::string& value) override;\n\n  /// @brief implemention of LocalDatabase::exist\n  /// @see LocalDatabase for more infomation\n  bool exist(const std::string& key) override;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/lmdb_database.h"
		}
	}
]
I0402 15:45:30.423835  5535 json_parser.cpp:18] 
[
	31,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/lmdb_database.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include <string>\n\n#include \"local_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass LmdbDatabase : public LocalDatabase {\n public:\n  /// @brief implemention of LocalDatabase::open\n  /// @see LocalDatabase for more infomation\n  bool open(const std::string& path, LocalDatabase::MODE mode) override;\n\n  /// @brief implemention of LocalDatabase::isOpen\n  /// @see LocalDatabase for more infomation\n  bool isOpen() override;\n\n  /// @brief implemention of LocalDatabase::close\n  /// @see LocalDatabase for more infomation\n  bool close() override;\n\n  /// @brief implemention of LocalDatabase::get\n  /// @see LocalDatabase for more infomation\n  bool get(const std::string& key, std::string* value) override;\n\n  /// @brief implemention of LocalDatabase::put\n  /// @see LocalDatabase for more infomation\n  bool put(const std::string& key, const std::string& value) override;\n\n  /// @brief implemention of LocalDatabase::exist\n  /// @see LocalDatabase for more infomation\n  bool exist(const std::string& key) override;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/lmdb_database.h"
		}
	}
]
I0402 15:45:30.514469  5535 json_parser.cpp:18] 
[
	32,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/local_database.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include <string>\n\nnamespace allride {\nnamespace mapping {\n\nclass LocalDatabase {\n public:\n  enum MODE { READ, WRITE, NEW };\n\n  /// @brief open the database\n  /// @param[in] the file path of the database file\n  /// @param[in] open mode\n  /// @return true on succeed, else false\n  virtual bool open(const std::string& path, MODE mode) = 0;\n\n  /// @brief check whether database is opened\n  /// @return true on opened, else false\n  virtual bool isOpen() = 0;\n\n  /// @brief close the database\n  /// @return true on succeed, else false\n  virtual bool close() = 0;\n\n  /// @brief get value from database\n  /// @param[in] key the key of the value to be got\n  /// @param[out] value stores the value got\n  /// @return true on succeed, else false\n  virtual bool get(const std::string& key, std::string* value) = 0;\n\n  /// @brief put key-value pair into database\n  /// @param[in] key the key of key-value pair\n  /// @param[out] value the value of key-value pair\n  /// @return true on succeed, else false\n  virtual bool put(const std::string& key, const std::string& value) = 0;\n\n  /// @brief check whether a key exist in database\n  /// @param[in] key the key to check\n  /// @return true on exist, else false\n  virtual bool exist(const std::string& key) = 0;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/local_database.h"
		}
	}
]
I0402 15:45:30.637405  5535 json_parser.cpp:18] 
[
	33,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/local_database.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include <string>\n\nnamespace allride {\nnamespace mapping {\n\nclass LocalDatabase {\n public:\n  enum MODE { READ, WRITE, NEW };\n\n  /// @brief open the database\n  /// @param[in] the file path of the database file\n  /// @param[in] open mode\n  /// @return true on succeed, else false\n  virtual bool open(const std::string& path, MODE mode) = 0;\n\n  /// @brief check whether database is opened\n  /// @return true on opened, else false\n  virtual bool isOpen() = 0;\n\n  /// @brief close the database\n  /// @return true on succeed, else false\n  virtual bool close() = 0;\n\n  /// @brief get value from database\n  /// @param[in] key the key of the value to be got\n  /// @param[out] value stores the value got\n  /// @return true on succeed, else false\n  virtual bool get(const std::string& key, std::string* value) = 0;\n\n  /// @brief put key-value pair into database\n  /// @param[in] key the key of key-value pair\n  /// @param[out] value the value of key-value pair\n  /// @return true on succeed, else false\n  virtual bool put(const std::string& key, const std::string& value) = 0;\n\n  /// @brief check whether a key exist in database\n  /// @param[in] key the key to check\n  /// @return true on exist, else false\n  virtual bool exist(const std::string& key) = 0;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/local_database.h"
		}
	}
]
I0402 15:45:31.329780  5535 json_parser.cpp:18] 
[
	34,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/local_database.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include <string>\n\nnamespace allride {\nnamespace mapping {\n\nclass LocalDatabase {\n public:\n  enum MODE { READ, WRITE, NEW };\n\n  /// @brief open the database\n  /// @param[in] the file path of the database file\n  /// @param[in] open mode\n  /// @return true on succeed, else false\n  virtual bool open(const std::string& path, MODE mode) = 0;\n\n  /// @brief check whether database is opened\n  /// @return true on opened, else false\n  virtual bool isOpen() = 0;\n\n  /// @brief close the database\n  /// @return true on succeed, else false\n  virtual bool close() = 0;\n\n  /// @brief get value from database\n  /// @param[in] key the key of the value to be got\n  /// @param[out] value stores the value got\n  /// @return true on succeed, else false\n  virtual bool get(const std::string& key, std::string* value) = 0;\n\n  /// @brief put key-value pair into database\n  /// @param[in] key the key of key-value pair\n  /// @param[out] value the value of key-value pair\n  /// @return true on succeed, else false\n  virtual bool put(const std::string& key, const std::string& value) = 0;\n\n  /// @brief check whether a key exist in database\n  /// @param[in] key the key to check\n  /// @return true on exist, else false\n  virtual bool exist(const std::string& key) = 0;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/local_database.h"
		}
	}
]
I0402 15:45:31.347554  5535 json_parser.cpp:18] 
[
	35,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/local_database.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include <string>\n\nnamespace allride {\nnamespace mapping {\n\nclass LocalDatabase {\n public:\n  enum MODE { READ, WRITE, NEW };\n\n  /// @brief open the database\n  /// @param[in] the file path of the database file\n  /// @param[in] open mode\n  /// @return true on succeed, else false\n  virtual bool open(const std::string& path, MODE mode) = 0;\n\n  /// @brief check whether database is opened\n  /// @return true on opened, else false\n  virtual bool isOpen() = 0;\n\n  /// @brief close the database\n  /// @return true on succeed, else false\n  virtual bool close() = 0;\n\n  /// @brief get value from database\n  /// @param[in] key the key of the value to be got\n  /// @param[out] value stores the value got\n  /// @return true on succeed, else false\n  virtual bool get(const std::string& key, std::string* value) = 0;\n\n  /// @brief put key-value pair into database\n  /// @param[in] key the key of key-value pair\n  /// @param[out] value the value of key-value pair\n  /// @return true on succeed, else false\n  virtual bool put(const std::string& key, const std::string& value) = 0;\n\n  /// @brief check whether a key exist in database\n  /// @param[in] key the key to check\n  /// @return true on exist, else false\n  virtual bool exist(const std::string& key) = 0;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/local_database.h"
		}
	}
]
I0402 15:45:31.359601  5535 json_parser.cpp:18] 
[
	36,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/local_database.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include <string>\n\nnamespace allride {\nnamespace mapping {\n\nclass LocalDatabase {\n public:\n  enum MODE { READ, WRITE, NEW };\n\n  /// @brief open the database\n  /// @param[in] the file path of the database file\n  /// @param[in] open mode\n  /// @return true on succeed, else false\n  virtual bool open(const std::string& path, MODE mode) = 0;\n\n  /// @brief check whether database is opened\n  /// @return true on opened, else false\n  virtual bool isOpen() = 0;\n\n  /// @brief close the database\n  /// @return true on succeed, else false\n  virtual bool close() = 0;\n\n  /// @brief get value from database\n  /// @param[in] key the key of the value to be got\n  /// @param[out] value stores the value got\n  /// @return true on succeed, else false\n  virtual bool get(const std::string& key, std::string* value) = 0;\n\n  /// @brief put key-value pair into database\n  /// @param[in] key the key of key-value pair\n  /// @param[out] value the value of key-value pair\n  /// @return true on succeed, else false\n  virtual bool put(const std::string& key, const std::string& value) = 0;\n\n  /// @brief check whether a key exist in database\n  /// @param[in] key the key to check\n  /// @return true on exist, else false\n  virtual bool exist(const std::string& key) = 0;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/local_database.h"
		}
	}
]
I0402 15:45:31.374898  5535 json_parser.cpp:18] 
[
	37,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All rights reserved.\n// Authors: Yongjian Zhao (yongjian.zhao@allride.ai)\n\n#include <fstream>\n#include <iostream>\n#include <sstream>\n#include <vector>\n\n#include \"common/io/proto_io.h\"\n#include \"common/proto/config/config_map.pb.h\"\n#include \"map_layer_dictionary_parser.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstatic const float grid_size_ratio = 1000.0f;  // convert from m to mm,\n\nbool MapLayerDictionaryParser::load(const std::string& dict_file) {\n  proto::config::MapLayerDictionary dict;\n  if (!common::ProtoIO::readProtoFromTextFile(dict_file, &dict)) {\n    std::cerr << \"MapLayerDictionaryParser: failed to load from dictionary file!\" << std::endl;\n    std::cerr << \"dict_file: \" << dict_file << std::endl;\n    return false;\n  }\n\n  for (const auto& item : dict.items()) {\n    int layer_id = item.layer_id();\n    std::string type_name = item.type_name();\n    float grid_size = item.grid_size();\n    float tile_size = item.tile_size();\n\n    // compose the key\n    std::string key;\n    composeKey(type_name, grid_size, tile_size, &key);\n\n    // set unordered_map\n    id_to_key_[layer_id] = key;\n    key_to_id_[key] = layer_id;\n  }\n\n  return true;\n}\n\nbool MapLayerDictionaryParser::getInfoById(const int layer_id, std::string* type_name,\n                                           float* grid_size, float* tile_size) {\n  if (id_to_key_.count(layer_id) == 0) {\n    return false;\n  }\n\n  analyseKey(id_to_key_[layer_id], type_name, grid_size, tile_size);\n  return true;\n}\n\nbool MapLayerDictionaryParser::getIdByInfo(const std::string& type_name, const float& grid_size,\n                                           const float& tile_size, int* layer_id) {\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 0) {\n    return false;\n  }\n\n  *layer_id = key_to_id_[key];\n  return true;\n}\n\nfloat MapLayerDictionaryParser::getGridSize(const int layer_id) {\n  float grid_size;\n  getInfoById(layer_id, nullptr, &grid_size, nullptr);\n  return grid_size;\n}\n\nfloat MapLayerDictionaryParser::getTileSize(const int layer_id) {\n  float tile_size;\n  getInfoById(layer_id, nullptr, nullptr, &tile_size);\n  return tile_size;\n}\n\nstd::string MapLayerDictionaryParser::getTypeName(const int layer_id) {\n  std::string type_name;\n  getInfoById(layer_id, &type_name, nullptr, nullptr);\n  return type_name;\n}\n\nbool MapLayerDictionaryParser::addItem(const int layer_id, const std::string& type_name,\n                                       const float grid_size, const float tile_size) {\n  if (id_to_key_.count(layer_id) == 1) {\n    std::cerr << \"failed to add item: layer_id \" << layer_id << \" has already exited in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 1) {\n    std::cerr << \"failed to add item: layer configuration has already existed in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  id_to_key_[layer_id] = key;\n  key_to_id_[key] = layer_id;\n  return true;\n}\n\nbool MapLayerDictionaryParser::save(const std::string& dict_file) {\n  // sort layer id\n  std::vector<int> layer_ids;\n  for (auto& pair : id_to_key_) {\n    layer_ids.emplace_back(pair.first);\n  }\n  std::sort(layer_ids.begin(), layer_ids.end());\n\n  // add item to dict\n  proto::config::MapLayerDictionary dict;\n  for (auto& id : layer_ids) {\n    // analyze key\n    std::string type_name;\n    float grid_size;\n    float tile_size;\n    analyseKey(id_to_key_[id], &type_name, &grid_size, &tile_size);\n\n    // add item\n    proto::config::MapLayerItem* item = dict.add_items();\n    item->set_layer_id(id);\n    item->set_type_name(type_name);\n    item->set_grid_size(grid_size);\n    item->set_tile_size(tile_size);\n  }\n\n  // write dict to file\n  return common::ProtoIO::writeProtoToTextFile(dict_file, dict);\n}\n\nvoid MapLayerDictionaryParser::composeKey(const std::string& type_name, const float& grid_size,\n                                          const float& tile_size, std::string* key) {\n  std::stringstream str_stream;\n  str_stream << type_name << \"_\" << static_cast<int>(grid_size * grid_size_ratio) << \"_\"\n             << static_cast<int>(tile_size);\n  *key = str_stream.str();\n}\n\nvoid MapLayerDictionaryParser::analyseKey(const std::string& key, std::string* type_name,\n                                          float* grid_size, float* tile_size) {\n  std::vector<std::string> substrs;\n  substrs.resize(3);\n\n  // achieve sub strings from key\n  size_t tail = key.size() - 1;\n  for (int i = 0; i < 2; i++) {\n    size_t pos = key.rfind('_', tail);\n    substrs[2 - i] = key.substr(pos + 1, tail - pos);\n    tail = pos - 1;\n  }\n  substrs[0] = key.substr(0, tail + 1);\n\n  // output\n  if (tile_size != nullptr) {\n    *tile_size = std::stof(substrs[2]);\n  }\n  if (grid_size != nullptr) {\n    *grid_size = std::stof(substrs[1]) / grid_size_ratio;\n  }\n  if (type_name != nullptr) {\n    *type_name = substrs[0];\n  }\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp"
		}
	}
]
I0402 15:45:31.395023  5535 json_parser.cpp:18] 
[
	38,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All rights reserved.\n// Authors: Yongjian Zhao (yongjian.zhao@allride.ai)\n\n#include <fstream>\n#include <iostream>\n#include <sstream>\n#include <vector>\n\n#include \"common/io/proto_io.h\"\n#include \"common/proto/config/config_map.pb.h\"\n#include \"map_layer_dictionary_parser.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstatic const float grid_size_ratio = 1000.0f;  // convert from m to mm,\n\nbool MapLayerDictionaryParser::load(const std::string& dict_file) {\n  proto::config::MapLayerDictionary dict;\n  if (!common::ProtoIO::readProtoFromTextFile(dict_file, &dict)) {\n    std::cerr << \"MapLayerDictionaryParser: failed to load from dictionary file!\" << std::endl;\n    std::cerr << \"dict_file: \" << dict_file << std::endl;\n    return false;\n  }\n\n  for (const auto& item : dict.items()) {\n    int layer_id = item.layer_id();\n    std::string type_name = item.type_name();\n    float grid_size = item.grid_size();\n    float tile_size = item.tile_size();\n\n    // compose the key\n    std::string key;\n    composeKey(type_name, grid_size, tile_size, &key);\n\n    // set unordered_map\n    id_to_key_[layer_id] = key;\n    key_to_id_[key] = layer_id;\n  }\n\n  return true;\n}\n\nbool MapLayerDictionaryParser::getInfoById(const int layer_id, std::string* type_name,\n                                           float* grid_size, float* tile_size) {\n  if (id_to_key_.count(layer_id) == 0) {\n    return false;\n  }\n\n  analyseKey(id_to_key_[layer_id], type_name, grid_size, tile_size);\n  return true;\n}\n\nbool MapLayerDictionaryParser::getIdByInfo(const std::string& type_name, const float& grid_size,\n                                           const float& tile_size, int* layer_id) {\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 0) {\n    return false;\n  }\n\n  *layer_id = key_to_id_[key];\n  return true;\n}\n\nfloat MapLayerDictionaryParser::getGridSize(const int layer_id) {\n  float grid_size;\n  getInfoById(layer_id, nullptr, &grid_size, nullptr);\n  return grid_size;\n}\n\nfloat MapLayerDictionaryParser::getTileSize(const int layer_id) {\n  float tile_size;\n  getInfoById(layer_id, nullptr, nullptr, &tile_size);\n  return tile_size;\n}\n\nstd::string MapLayerDictionaryParser::getTypeName(const int layer_id) {\n  std::string type_name;\n  getInfoById(layer_id, &type_name, nullptr, nullptr);\n  return type_name;\n}\n\nbool MapLayerDictionaryParser::addItem(const int layer_id, const std::string& type_name,\n                                       const float grid_size, const float tile_size) {\n  if (id_to_key_.count(layer_id) == 1) {\n    std::cerr << \"failed to add item: layer_id \" << layer_id << \" has already exited in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 1) {\n    std::cerr << \"failed to add item: layer configuration has already existed in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  id_to_key_[layer_id] = key;\n  key_to_id_[key] = layer_id;\n  return true;\n}\n\nbool MapLayerDictionaryParser::save(const std::string& dict_file) {\n  // sort layer id\n  std::vector<int> layer_ids;\n  for (auto& pair : id_to_key_) {\n    layer_ids.emplace_back(pair.first);\n  }\n  std::sort(layer_ids.begin(), layer_ids.end());\n\n  // add item to dict\n  proto::config::MapLayerDictionary dict;\n  for (auto& id : layer_ids) {\n    // analyze key\n    std::string type_name;\n    float grid_size;\n    float tile_size;\n    analyseKey(id_to_key_[id], &type_name, &grid_size, &tile_size);\n\n    // add item\n    proto::config::MapLayerItem* item = dict.add_items();\n    item->set_layer_id(id);\n    item->set_type_name(type_name);\n    item->set_grid_size(grid_size);\n    item->set_tile_size(tile_size);\n  }\n\n  // write dict to file\n  return common::ProtoIO::writeProtoToTextFile(dict_file, dict);\n}\n\nvoid MapLayerDictionaryParser::composeKey(const std::string& type_name, const float& grid_size,\n                                          const float& tile_size, std::string* key) {\n  std::stringstream str_stream;\n  str_stream << type_name << \"_\" << static_cast<int>(grid_size * grid_size_ratio) << \"_\"\n             << static_cast<int>(tile_size);\n  *key = str_stream.str();\n}\n\nvoid MapLayerDictionaryParser::analyseKey(const std::string& key, std::string* type_name,\n                                          float* grid_size, float* tile_size) {\n  std::vector<std::string> substrs;\n  substrs.resize(3);\n\n  // achieve sub strings from key\n  size_t tail = key.size() - 1;\n  for (int i = 0; i < 2; i++) {\n    size_t pos = key.rfind('_', tail);\n    substrs[2 - i] = key.substr(pos + 1, tail - pos);\n    tail = pos - 1;\n  }\n  substrs[0] = key.substr(0, tail + 1);\n\n  // output\n  if (tile_size != nullptr) {\n    *tile_size = std::stof(substrs[2]);\n  }\n  if (grid_size != nullptr) {\n    *grid_size = std::stof(substrs[1]) / grid_size_ratio;\n  }\n  if (type_name != nullptr) {\n    *type_name = substrs[0];\n  }\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp"
		}
	}
]
I0402 15:45:35.232951  5535 json_parser.cpp:18] 
[
	39,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All rights reserved.\n// Authors: Yongjian Zhao (yongjian.zhao@allride.ai)\n\n#include <fstream>\n#include <iostream>\n#include <sstream>\n#include <vector>\n\n#include \"common/io/proto_io.h\"\n#include \"common/proto/config/config_map.pb.h\"\n#include \"map_layer_dictionary_parser.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstatic const float grid_size_ratio = 1000.0f;  // convert from m to mm,\n\nbool MapLayerDictionaryParser::load(const std::string& dict_file) {\n  proto::config::MapLayerDictionary dict;\n  if (!common::ProtoIO::readProtoFromTextFile(dict_file, &dict)) {\n    std::cerr << \"MapLayerDictionaryParser: failed to load from dictionary file!\" << std::endl;\n    std::cerr << \"dict_file: \" << dict_file << std::endl;\n    return false;\n  }\n\n  for (const auto& item : dict.items()) {\n    int layer_id = item.layer_id();\n    std::string type_name = item.type_name();\n    float grid_size = item.grid_size();\n    float tile_size = item.tile_size();\n\n    // compose the key\n    std::string key;\n    composeKey(type_name, grid_size, tile_size, &key);\n\n    // set unordered_map\n    id_to_key_[layer_id] = key;\n    key_to_id_[key] = layer_id;\n  }\n\n  return true;\n}\n\nbool MapLayerDictionaryParser::getInfoById(const int layer_id, std::string* type_name,\n                                           float* grid_size, float* tile_size) {\n  if (id_to_key_.count(layer_id) == 0) {\n    return false;\n  }\n\n  analyseKey(id_to_key_[layer_id], type_name, grid_size, tile_size);\n  return true;\n}\n\nbool MapLayerDictionaryParser::getIdByInfo(const std::string& type_name, const float& grid_size,\n                                           const float& tile_size, int* layer_id) {\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 0) {\n    return false;\n  }\n\n  *layer_id = key_to_id_[key];\n  return true;\n}\n\nfloat MapLayerDictionaryParser::getGridSize(const int layer_id) {\n  float grid_size;\n  getInfoById(layer_id, nullptr, &grid_size, nullptr);\n  return grid_size;\n}\n\nfloat MapLayerDictionaryParser::getTileSize(const int layer_id) {\n  float tile_size;\n  getInfoById(layer_id, nullptr, nullptr, &tile_size);\n  return tile_size;\n}\n\nstd::string MapLayerDictionaryParser::getTypeName(const int layer_id) {\n  std::string type_name;\n  getInfoById(layer_id, &type_name, nullptr, nullptr);\n  return type_name;\n}\n\nbool MapLayerDictionaryParser::addItem(const int layer_id, const std::string& type_name,\n                                       const float grid_size, const float tile_size) {\n  if (id_to_key_.count(layer_id) == 1) {\n    std::cerr << \"failed to add item: layer_id \" << layer_id << \" has already exited in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 1) {\n    std::cerr << \"failed to add item: layer configuration has already existed in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  id_to_key_[layer_id] = key;\n  key_to_id_[key] = layer_id;\n  return true;\n}\n\nbool MapLayerDictionaryParser::save(const std::string& dict_file) {\n  // sort layer id\n  std::vector<int> layer_ids;\n  for (auto& pair : id_to_key_) {\n    layer_ids.emplace_back(pair.first);\n  }\n  std::sort(layer_ids.begin(), layer_ids.end());\n\n  // add item to dict\n  proto::config::MapLayerDictionary dict;\n  for (auto& id : layer_ids) {\n    // analyze key\n    std::string type_name;\n    float grid_size;\n    float tile_size;\n    analyseKey(id_to_key_[id], &type_name, &grid_size, &tile_size);\n\n    // add item\n    proto::config::MapLayerItem* item = dict.add_items();\n    item->set_layer_id(id);\n    item->set_type_name(type_name);\n    item->set_grid_size(grid_size);\n    item->set_tile_size(tile_size);\n  }\n\n  // write dict to file\n  return common::ProtoIO::writeProtoToTextFile(dict_file, dict);\n}\n\nvoid MapLayerDictionaryParser::composeKey(const std::string& type_name, const float& grid_size,\n                                          const float& tile_size, std::string* key) {\n  std::stringstream str_stream;\n  str_stream << type_name << \"_\" << static_cast<int>(grid_size * grid_size_ratio) << \"_\"\n             << static_cast<int>(tile_size);\n  *key = str_stream.str();\n}\n\nvoid MapLayerDictionaryParser::analyseKey(const std::string& key, std::string* type_name,\n                                          float* grid_size, float* tile_size) {\n  std::vector<std::string> substrs;\n  substrs.resize(3);\n\n  // achieve sub strings from key\n  size_t tail = key.size() - 1;\n  for (int i = 0; i < 2; i++) {\n    size_t pos = key.rfind('_', tail);\n    substrs[2 - i] = key.substr(pos + 1, tail - pos);\n    tail = pos - 1;\n  }\n  substrs[0] = key.substr(0, tail + 1);\n\n  // output\n  if (tile_size != nullptr) {\n    *tile_size = std::stof(substrs[2]);\n  }\n  if (grid_size != nullptr) {\n    *grid_size = std::stof(substrs[1]) / grid_size_ratio;\n  }\n  if (type_name != nullptr) {\n    *type_name = substrs[0];\n  }\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp"
		}
	}
]
I0402 15:45:35.253660  5535 json_parser.cpp:18] 
[
	40,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All rights reserved.\n// Authors: Yongjian Zhao (yongjian.zhao@allride.ai)\n\n#include <fstream>\n#include <iostream>\n#include <sstream>\n#include <vector>\n\n#include \"common/io/proto_io.h\"\n#include \"common/proto/config/config_map.pb.h\"\n#include \"map_layer_dictionary_parser.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstatic const float grid_size_ratio = 1000.0f;  // convert from m to mm,\n\nbool MapLayerDictionaryParser::load(const std::string& dict_file) {\n  proto::config::MapLayerDictionary dict;\n  if (!common::ProtoIO::readProtoFromTextFile(dict_file, &dict)) {\n    std::cerr << \"MapLayerDictionaryParser: failed to load from dictionary file!\" << std::endl;\n    std::cerr << \"dict_file: \" << dict_file << std::endl;\n    return false;\n  }\n\n  for (const auto& item : dict.items()) {\n    int layer_id = item.layer_id();\n    std::string type_name = item.type_name();\n    float grid_size = item.grid_size();\n    float tile_size = item.tile_size();\n\n    // compose the key\n    std::string key;\n    composeKey(type_name, grid_size, tile_size, &key);\n\n    // set unordered_map\n    id_to_key_[layer_id] = key;\n    key_to_id_[key] = layer_id;\n  }\n\n  return true;\n}\n\nbool MapLayerDictionaryParser::getInfoById(const int layer_id, std::string* type_name,\n                                           float* grid_size, float* tile_size) {\n  if (id_to_key_.count(layer_id) == 0) {\n    return false;\n  }\n\n  analyseKey(id_to_key_[layer_id], type_name, grid_size, tile_size);\n  return true;\n}\n\nbool MapLayerDictionaryParser::getIdByInfo(const std::string& type_name, const float& grid_size,\n                                           const float& tile_size, int* layer_id) {\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 0) {\n    return false;\n  }\n\n  *layer_id = key_to_id_[key];\n  return true;\n}\n\nfloat MapLayerDictionaryParser::getGridSize(const int layer_id) {\n  float grid_size;\n  getInfoById(layer_id, nullptr, &grid_size, nullptr);\n  return grid_size;\n}\n\nfloat MapLayerDictionaryParser::getTileSize(const int layer_id) {\n  float tile_size;\n  getInfoById(layer_id, nullptr, nullptr, &tile_size);\n  return tile_size;\n}\n\nstd::string MapLayerDictionaryParser::getTypeName(const int layer_id) {\n  std::string type_name;\n  getInfoById(layer_id, &type_name, nullptr, nullptr);\n  return type_name;\n}\n\nbool MapLayerDictionaryParser::addItem(const int layer_id, const std::string& type_name,\n                                       const float grid_size, const float tile_size) {\n  if (id_to_key_.count(layer_id) == 1) {\n    std::cerr << \"failed to add item: layer_id \" << layer_id << \" has already exited in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 1) {\n    std::cerr << \"failed to add item: layer configuration has already existed in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  id_to_key_[layer_id] = key;\n  key_to_id_[key] = layer_id;\n  return true;\n}\n\nbool MapLayerDictionaryParser::save(const std::string& dict_file) {\n  // sort layer id\n  std::vector<int> layer_ids;\n  for (auto& pair : id_to_key_) {\n    layer_ids.emplace_back(pair.first);\n  }\n  std::sort(layer_ids.begin(), layer_ids.end());\n\n  // add item to dict\n  proto::config::MapLayerDictionary dict;\n  for (auto& id : layer_ids) {\n    // analyze key\n    std::string type_name;\n    float grid_size;\n    float tile_size;\n    analyseKey(id_to_key_[id], &type_name, &grid_size, &tile_size);\n\n    // add item\n    proto::config::MapLayerItem* item = dict.add_items();\n    item->set_layer_id(id);\n    item->set_type_name(type_name);\n    item->set_grid_size(grid_size);\n    item->set_tile_size(tile_size);\n  }\n\n  // write dict to file\n  return common::ProtoIO::writeProtoToTextFile(dict_file, dict);\n}\n\nvoid MapLayerDictionaryParser::composeKey(const std::string& type_name, const float& grid_size,\n                                          const float& tile_size, std::string* key) {\n  std::stringstream str_stream;\n  str_stream << type_name << \"_\" << static_cast<int>(grid_size * grid_size_ratio) << \"_\"\n             << static_cast<int>(tile_size);\n  *key = str_stream.str();\n}\n\nvoid MapLayerDictionaryParser::analyseKey(const std::string& key, std::string* type_name,\n                                          float* grid_size, float* tile_size) {\n  std::vector<std::string> substrs;\n  substrs.resize(3);\n\n  // achieve sub strings from key\n  size_t tail = key.size() - 1;\n  for (int i = 0; i < 2; i++) {\n    size_t pos = key.rfind('_', tail);\n    substrs[2 - i] = key.substr(pos + 1, tail - pos);\n    tail = pos - 1;\n  }\n  substrs[0] = key.substr(0, tail + 1);\n\n  // output\n  if (tile_size != nullptr) {\n    *tile_size = std::stof(substrs[2]);\n  }\n  if (grid_size != nullptr) {\n    *grid_size = std::stof(substrs[1]) / grid_size_ratio;\n  }\n  if (type_name != nullptr) {\n    *type_name = substrs[0];\n  }\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp"
		}
	}
]
I0402 15:45:35.271594  5535 json_parser.cpp:18] 
[
	41,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All rights reserved.\n// Authors: Yongjian Zhao (yongjian.zhao@allride.ai)\n\n#include <fstream>\n#include <iostream>\n#include <sstream>\n#include <vector>\n\n#include \"common/io/proto_io.h\"\n#include \"common/proto/config/config_map.pb.h\"\n#include \"map_layer_dictionary_parser.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstatic const float grid_size_ratio = 1000.0f;  // convert from m to mm,\n\nbool MapLayerDictionaryParser::load(const std::string& dict_file) {\n  proto::config::MapLayerDictionary dict;\n  if (!common::ProtoIO::readProtoFromTextFile(dict_file, &dict)) {\n    std::cerr << \"MapLayerDictionaryParser: failed to load from dictionary file!\" << std::endl;\n    std::cerr << \"dict_file: \" << dict_file << std::endl;\n    return false;\n  }\n\n  for (const auto& item : dict.items()) {\n    int layer_id = item.layer_id();\n    std::string type_name = item.type_name();\n    float grid_size = item.grid_size();\n    float tile_size = item.tile_size();\n\n    // compose the key\n    std::string key;\n    composeKey(type_name, grid_size, tile_size, &key);\n\n    // set unordered_map\n    id_to_key_[layer_id] = key;\n    key_to_id_[key] = layer_id;\n  }\n\n  return true;\n}\n\nbool MapLayerDictionaryParser::getInfoById(const int layer_id, std::string* type_name,\n                                           float* grid_size, float* tile_size) {\n  if (id_to_key_.count(layer_id) == 0) {\n    return false;\n  }\n\n  analyseKey(id_to_key_[layer_id], type_name, grid_size, tile_size);\n  return true;\n}\n\nbool MapLayerDictionaryParser::getIdByInfo(const std::string& type_name, const float& grid_size,\n                                           const float& tile_size, int* layer_id) {\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 0) {\n    return false;\n  }\n\n  *layer_id = key_to_id_[key];\n  return true;\n}\n\nfloat MapLayerDictionaryParser::getGridSize(const int layer_id) {\n  float grid_size;\n  getInfoById(layer_id, nullptr, &grid_size, nullptr);\n  return grid_size;\n}\n\nfloat MapLayerDictionaryParser::getTileSize(const int layer_id) {\n  float tile_size;\n  getInfoById(layer_id, nullptr, nullptr, &tile_size);\n  return tile_size;\n}\n\nstd::string MapLayerDictionaryParser::getTypeName(const int layer_id) {\n  std::string type_name;\n  getInfoById(layer_id, &type_name, nullptr, nullptr);\n  return type_name;\n}\n\nbool MapLayerDictionaryParser::addItem(const int layer_id, const std::string& type_name,\n                                       const float grid_size, const float tile_size) {\n  if (id_to_key_.count(layer_id) == 1) {\n    std::cerr << \"failed to add item: layer_id \" << layer_id << \" has already exited in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  std::string key;\n  composeKey(type_name, grid_size, tile_size, &key);\n  if (key_to_id_.count(key) == 1) {\n    std::cerr << \"failed to add item: layer configuration has already existed in dictionary!\"\n              << std::endl;\n    return false;\n  }\n\n  id_to_key_[layer_id] = key;\n  key_to_id_[key] = layer_id;\n  return true;\n}\n\nbool MapLayerDictionaryParser::save(const std::string& dict_file) {\n  // sort layer id\n  std::vector<int> layer_ids;\n  for (auto& pair : id_to_key_) {\n    layer_ids.emplace_back(pair.first);\n  }\n  std::sort(layer_ids.begin(), layer_ids.end());\n\n  // add item to dict\n  proto::config::MapLayerDictionary dict;\n  for (auto& id : layer_ids) {\n    // analyze key\n    std::string type_name;\n    float grid_size;\n    float tile_size;\n    analyseKey(id_to_key_[id], &type_name, &grid_size, &tile_size);\n\n    // add item\n    proto::config::MapLayerItem* item = dict.add_items();\n    item->set_layer_id(id);\n    item->set_type_name(type_name);\n    item->set_grid_size(grid_size);\n    item->set_tile_size(tile_size);\n  }\n\n  // write dict to file\n  return common::ProtoIO::writeProtoToTextFile(dict_file, dict);\n}\n\nvoid MapLayerDictionaryParser::composeKey(const std::string& type_name, const float& grid_size,\n                                          const float& tile_size, std::string* key) {\n  std::stringstream str_stream;\n  str_stream << type_name << \"_\" << static_cast<int>(grid_size * grid_size_ratio) << \"_\"\n             << static_cast<int>(tile_size);\n  *key = str_stream.str();\n}\n\nvoid MapLayerDictionaryParser::analyseKey(const std::string& key, std::string* type_name,\n                                          float* grid_size, float* tile_size) {\n  std::vector<std::string> substrs;\n  substrs.resize(3);\n\n  // achieve sub strings from key\n  size_t tail = key.size() - 1;\n  for (int i = 0; i < 2; i++) {\n    size_t pos = key.rfind('_', tail);\n    substrs[2 - i] = key.substr(pos + 1, tail - pos);\n    tail = pos - 1;\n  }\n  substrs[0] = key.substr(0, tail + 1);\n\n  // output\n  if (tile_size != nullptr) {\n    *tile_size = std::stof(substrs[2]);\n  }\n  if (grid_size != nullptr) {\n    *grid_size = std::stof(substrs[1]) / grid_size_ratio;\n  }\n  if (type_name != nullptr) {\n    *type_name = substrs[0];\n  }\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.cpp"
		}
	}
]
I0402 15:45:35.348100  5535 json_parser.cpp:18] 
[
	42,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All rights reserved.\n// Authors: Yongjian Zhao (yongjian.zhao@allride.ai)\n\n#pragma once\n\n#include <string>\n#include <unordered_map>\n\n#include \"common/proto/config/config_map.pb.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass MapLayerDictionaryParser {\n public:\n  MapLayerDictionaryParser() = default;\n  ~MapLayerDictionaryParser() = default;\n\n  // interface for using dictionary\n  bool load(const std::string& dict_file);\n\n  bool getInfoById(const int layer_id, std::string* type_name, float* grid_size, float* tile_size);\n\n  float getGridSize(const int layer_id);\n\n  float getTileSize(const int layer_id);\n\n  std::string getTypeName(const int layer_id);\n\n  bool getIdByInfo(const std::string& type_name, const float& grid_size, const float& tile_size,\n                   int* layer_id);\n\n  // interface for making dictionary,\n  bool addItem(const int layer_id, const std::string& type_name, const float grid_size,\n               const float tile_size);\n\n  bool save(const std::string& dict_file);\n\n private:\n  void composeKey(const std::string& type_name, const float& grid_size, const float& tile_size,\n                  std::string* key);\n\n  void analyseKey(const std::string& key, std::string* type_name, float* grid_size,\n                  float* tile_size);\n\n  std::unordered_map<int, std::string> id_to_key_;\n  std::unordered_map<std::string, int> key_to_id_;\n};\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.h"
		}
	}
]
I0402 15:45:35.533646  5535 json_parser.cpp:18] 
[
	43,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All rights reserved.\n// Authors: Yongjian Zhao (yongjian.zhao@allride.ai)\n\n#pragma once\n\n#include <string>\n#include <unordered_map>\n\n#include \"common/proto/config/config_map.pb.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass MapLayerDictionaryParser {\n public:\n  MapLayerDictionaryParser() = default;\n  ~MapLayerDictionaryParser() = default;\n\n  // interface for using dictionary\n  bool load(const std::string& dict_file);\n\n  bool getInfoById(const int layer_id, std::string* type_name, float* grid_size, float* tile_size);\n\n  float getGridSize(const int layer_id);\n\n  float getTileSize(const int layer_id);\n\n  std::string getTypeName(const int layer_id);\n\n  bool getIdByInfo(const std::string& type_name, const float& grid_size, const float& tile_size,\n                   int* layer_id);\n\n  // interface for making dictionary,\n  bool addItem(const int layer_id, const std::string& type_name, const float grid_size,\n               const float tile_size);\n\n  bool save(const std::string& dict_file);\n\n private:\n  void composeKey(const std::string& type_name, const float& grid_size, const float& tile_size,\n                  std::string* key);\n\n  void analyseKey(const std::string& key, std::string* type_name, float* grid_size,\n                  float* tile_size);\n\n  std::unordered_map<int, std::string> id_to_key_;\n  std::unordered_map<std::string, int> key_to_id_;\n};\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.h"
		}
	}
]
I0402 15:45:37.107484  5535 json_parser.cpp:18] 
[
	44,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All rights reserved.\n// Authors: Yongjian Zhao (yongjian.zhao@allride.ai)\n\n#pragma once\n\n#include <string>\n#include <unordered_map>\n\n#include \"common/proto/config/config_map.pb.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass MapLayerDictionaryParser {\n public:\n  MapLayerDictionaryParser() = default;\n  ~MapLayerDictionaryParser() = default;\n\n  // interface for using dictionary\n  bool load(const std::string& dict_file);\n\n  bool getInfoById(const int layer_id, std::string* type_name, float* grid_size, float* tile_size);\n\n  float getGridSize(const int layer_id);\n\n  float getTileSize(const int layer_id);\n\n  std::string getTypeName(const int layer_id);\n\n  bool getIdByInfo(const std::string& type_name, const float& grid_size, const float& tile_size,\n                   int* layer_id);\n\n  // interface for making dictionary,\n  bool addItem(const int layer_id, const std::string& type_name, const float grid_size,\n               const float tile_size);\n\n  bool save(const std::string& dict_file);\n\n private:\n  void composeKey(const std::string& type_name, const float& grid_size, const float& tile_size,\n                  std::string* key);\n\n  void analyseKey(const std::string& key, std::string* type_name, float* grid_size,\n                  float* tile_size);\n\n  std::unordered_map<int, std::string> id_to_key_;\n  std::unordered_map<std::string, int> key_to_id_;\n};\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.h"
		}
	}
]
I0402 15:45:37.124119  5535 json_parser.cpp:18] 
[
	45,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All rights reserved.\n// Authors: Yongjian Zhao (yongjian.zhao@allride.ai)\n\n#pragma once\n\n#include <string>\n#include <unordered_map>\n\n#include \"common/proto/config/config_map.pb.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass MapLayerDictionaryParser {\n public:\n  MapLayerDictionaryParser() = default;\n  ~MapLayerDictionaryParser() = default;\n\n  // interface for using dictionary\n  bool load(const std::string& dict_file);\n\n  bool getInfoById(const int layer_id, std::string* type_name, float* grid_size, float* tile_size);\n\n  float getGridSize(const int layer_id);\n\n  float getTileSize(const int layer_id);\n\n  std::string getTypeName(const int layer_id);\n\n  bool getIdByInfo(const std::string& type_name, const float& grid_size, const float& tile_size,\n                   int* layer_id);\n\n  // interface for making dictionary,\n  bool addItem(const int layer_id, const std::string& type_name, const float grid_size,\n               const float tile_size);\n\n  bool save(const std::string& dict_file);\n\n private:\n  void composeKey(const std::string& type_name, const float& grid_size, const float& tile_size,\n                  std::string* key);\n\n  void analyseKey(const std::string& key, std::string* type_name, float* grid_size,\n                  float* tile_size);\n\n  std::unordered_map<int, std::string> id_to_key_;\n  std::unordered_map<std::string, int> key_to_id_;\n};\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.h"
		}
	}
]
I0402 15:45:37.138048  5535 json_parser.cpp:18] 
[
	46,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All rights reserved.\n// Authors: Yongjian Zhao (yongjian.zhao@allride.ai)\n\n#pragma once\n\n#include <string>\n#include <unordered_map>\n\n#include \"common/proto/config/config_map.pb.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass MapLayerDictionaryParser {\n public:\n  MapLayerDictionaryParser() = default;\n  ~MapLayerDictionaryParser() = default;\n\n  // interface for using dictionary\n  bool load(const std::string& dict_file);\n\n  bool getInfoById(const int layer_id, std::string* type_name, float* grid_size, float* tile_size);\n\n  float getGridSize(const int layer_id);\n\n  float getTileSize(const int layer_id);\n\n  std::string getTypeName(const int layer_id);\n\n  bool getIdByInfo(const std::string& type_name, const float& grid_size, const float& tile_size,\n                   int* layer_id);\n\n  // interface for making dictionary,\n  bool addItem(const int layer_id, const std::string& type_name, const float grid_size,\n               const float tile_size);\n\n  bool save(const std::string& dict_file);\n\n private:\n  void composeKey(const std::string& type_name, const float& grid_size, const float& tile_size,\n                  std::string* key);\n\n  void analyseKey(const std::string& key, std::string* type_name, float* grid_size,\n                  float* tile_size);\n\n  std::unordered_map<int, std::string> id_to_key_;\n  std::unordered_map<std::string, int> key_to_id_;\n};\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_layer_dictionary_parser.h"
		}
	}
]
I0402 15:45:37.232508  5535 json_parser.cpp:18] 
[
	47,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_scope.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#include \"map_scope.h\"\n\nnamespace allride {\nnamespace mapping {\n\nMapScope::MapScope() { corner_min.setZero(); }\n\nMapScope::MapScope(Eigen::Vector3f center, float range) {\n  corner_min = center - range / 2.0 * Eigen::Vector3f().setOnes();\n  corner_max = center + range / 2.0 * Eigen::Vector3f().setOnes();\n}\n\nMapScope::MapScope(Eigen::Vector3f corner0, Eigen::Vector3f corner1) {\n  float x_min = std::min(corner0.x(), corner1.x());\n  float y_min = std::min(corner0.y(), corner1.y());\n  float z_min = std::min(corner0.z(), corner1.z());\n\n  float x_max = std::max(corner0.x(), corner1.x());\n  float y_max = std::max(corner0.y(), corner1.y());\n  float z_max = std::max(corner0.z(), corner1.z());\n\n  corner_min = Eigen::Vector3f(x_min, y_min, z_min);\n  corner_max = Eigen::Vector3f(x_max, y_max, z_max);\n}\n\nconst Eigen::Vector3f& MapScope::getCornerMin() const { return corner_min; }\n\nconst Eigen::Vector3f& MapScope::getCornerMax() const { return corner_max; }\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_scope.cpp"
		}
	}
]
I0402 15:45:37.306169  5535 json_parser.cpp:18] 
[
	48,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_scope.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#include \"map_scope.h\"\n\nnamespace allride {\nnamespace mapping {\n\nMapScope::MapScope() { corner_min.setZero(); }\n\nMapScope::MapScope(Eigen::Vector3f center, float range) {\n  corner_min = center - range / 2.0 * Eigen::Vector3f().setOnes();\n  corner_max = center + range / 2.0 * Eigen::Vector3f().setOnes();\n}\n\nMapScope::MapScope(Eigen::Vector3f corner0, Eigen::Vector3f corner1) {\n  float x_min = std::min(corner0.x(), corner1.x());\n  float y_min = std::min(corner0.y(), corner1.y());\n  float z_min = std::min(corner0.z(), corner1.z());\n\n  float x_max = std::max(corner0.x(), corner1.x());\n  float y_max = std::max(corner0.y(), corner1.y());\n  float z_max = std::max(corner0.z(), corner1.z());\n\n  corner_min = Eigen::Vector3f(x_min, y_min, z_min);\n  corner_max = Eigen::Vector3f(x_max, y_max, z_max);\n}\n\nconst Eigen::Vector3f& MapScope::getCornerMin() const { return corner_min; }\n\nconst Eigen::Vector3f& MapScope::getCornerMax() const { return corner_max; }\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_scope.cpp"
		}
	}
]
I0402 15:45:39.673722  5535 json_parser.cpp:18] 
[
	49,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_scope.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#include \"map_scope.h\"\n\nnamespace allride {\nnamespace mapping {\n\nMapScope::MapScope() { corner_min.setZero(); }\n\nMapScope::MapScope(Eigen::Vector3f center, float range) {\n  corner_min = center - range / 2.0 * Eigen::Vector3f().setOnes();\n  corner_max = center + range / 2.0 * Eigen::Vector3f().setOnes();\n}\n\nMapScope::MapScope(Eigen::Vector3f corner0, Eigen::Vector3f corner1) {\n  float x_min = std::min(corner0.x(), corner1.x());\n  float y_min = std::min(corner0.y(), corner1.y());\n  float z_min = std::min(corner0.z(), corner1.z());\n\n  float x_max = std::max(corner0.x(), corner1.x());\n  float y_max = std::max(corner0.y(), corner1.y());\n  float z_max = std::max(corner0.z(), corner1.z());\n\n  corner_min = Eigen::Vector3f(x_min, y_min, z_min);\n  corner_max = Eigen::Vector3f(x_max, y_max, z_max);\n}\n\nconst Eigen::Vector3f& MapScope::getCornerMin() const { return corner_min; }\n\nconst Eigen::Vector3f& MapScope::getCornerMax() const { return corner_max; }\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_scope.cpp"
		}
	}
]
I0402 15:45:39.691828  5535 json_parser.cpp:18] 
[
	50,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_scope.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#include \"map_scope.h\"\n\nnamespace allride {\nnamespace mapping {\n\nMapScope::MapScope() { corner_min.setZero(); }\n\nMapScope::MapScope(Eigen::Vector3f center, float range) {\n  corner_min = center - range / 2.0 * Eigen::Vector3f().setOnes();\n  corner_max = center + range / 2.0 * Eigen::Vector3f().setOnes();\n}\n\nMapScope::MapScope(Eigen::Vector3f corner0, Eigen::Vector3f corner1) {\n  float x_min = std::min(corner0.x(), corner1.x());\n  float y_min = std::min(corner0.y(), corner1.y());\n  float z_min = std::min(corner0.z(), corner1.z());\n\n  float x_max = std::max(corner0.x(), corner1.x());\n  float y_max = std::max(corner0.y(), corner1.y());\n  float z_max = std::max(corner0.z(), corner1.z());\n\n  corner_min = Eigen::Vector3f(x_min, y_min, z_min);\n  corner_max = Eigen::Vector3f(x_max, y_max, z_max);\n}\n\nconst Eigen::Vector3f& MapScope::getCornerMin() const { return corner_min; }\n\nconst Eigen::Vector3f& MapScope::getCornerMax() const { return corner_max; }\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_scope.cpp"
		}
	}
]
I0402 15:45:39.704109  5535 json_parser.cpp:18] 
[
	51,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_scope.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#include \"map_scope.h\"\n\nnamespace allride {\nnamespace mapping {\n\nMapScope::MapScope() { corner_min.setZero(); }\n\nMapScope::MapScope(Eigen::Vector3f center, float range) {\n  corner_min = center - range / 2.0 * Eigen::Vector3f().setOnes();\n  corner_max = center + range / 2.0 * Eigen::Vector3f().setOnes();\n}\n\nMapScope::MapScope(Eigen::Vector3f corner0, Eigen::Vector3f corner1) {\n  float x_min = std::min(corner0.x(), corner1.x());\n  float y_min = std::min(corner0.y(), corner1.y());\n  float z_min = std::min(corner0.z(), corner1.z());\n\n  float x_max = std::max(corner0.x(), corner1.x());\n  float y_max = std::max(corner0.y(), corner1.y());\n  float z_max = std::max(corner0.z(), corner1.z());\n\n  corner_min = Eigen::Vector3f(x_min, y_min, z_min);\n  corner_max = Eigen::Vector3f(x_max, y_max, z_max);\n}\n\nconst Eigen::Vector3f& MapScope::getCornerMin() const { return corner_min; }\n\nconst Eigen::Vector3f& MapScope::getCornerMax() const { return corner_max; }\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_scope.cpp"
		}
	}
]
I0402 15:45:39.732233  5535 json_parser.cpp:18] 
[
	52,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_scope.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/eigen_types.h\"\n\nnamespace allride {\nnamespace mapping {\n\n/// @brief specify a three dimension region\nclass MapScope {\n public:\n  MapScope();\n  MapScope(Eigen::Vector3f center, float range);\n  MapScope(Eigen::Vector3f corner0, Eigen::Vector3f corner1);\n\n  const Eigen::Vector3f& getCornerMin() const;\n  const Eigen::Vector3f& getCornerMax() const;\n\n protected:\n  Eigen::Vector3f corner_min;\n  Eigen::Vector3f corner_max;\n};\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_scope.h"
		}
	}
]
I0402 15:45:39.798627  5535 json_parser.cpp:18] 
[
	53,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_scope.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/eigen_types.h\"\n\nnamespace allride {\nnamespace mapping {\n\n/// @brief specify a three dimension region\nclass MapScope {\n public:\n  MapScope();\n  MapScope(Eigen::Vector3f center, float range);\n  MapScope(Eigen::Vector3f corner0, Eigen::Vector3f corner1);\n\n  const Eigen::Vector3f& getCornerMin() const;\n  const Eigen::Vector3f& getCornerMax() const;\n\n protected:\n  Eigen::Vector3f corner_min;\n  Eigen::Vector3f corner_max;\n};\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_scope.h"
		}
	}
]
I0402 15:45:42.240578  5535 json_parser.cpp:18] 
[
	54,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_scope.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/eigen_types.h\"\n\nnamespace allride {\nnamespace mapping {\n\n/// @brief specify a three dimension region\nclass MapScope {\n public:\n  MapScope();\n  MapScope(Eigen::Vector3f center, float range);\n  MapScope(Eigen::Vector3f corner0, Eigen::Vector3f corner1);\n\n  const Eigen::Vector3f& getCornerMin() const;\n  const Eigen::Vector3f& getCornerMax() const;\n\n protected:\n  Eigen::Vector3f corner_min;\n  Eigen::Vector3f corner_max;\n};\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_scope.h"
		}
	}
]
I0402 15:45:42.257468  5535 json_parser.cpp:18] 
[
	55,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_scope.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/eigen_types.h\"\n\nnamespace allride {\nnamespace mapping {\n\n/// @brief specify a three dimension region\nclass MapScope {\n public:\n  MapScope();\n  MapScope(Eigen::Vector3f center, float range);\n  MapScope(Eigen::Vector3f corner0, Eigen::Vector3f corner1);\n\n  const Eigen::Vector3f& getCornerMin() const;\n  const Eigen::Vector3f& getCornerMax() const;\n\n protected:\n  Eigen::Vector3f corner_min;\n  Eigen::Vector3f corner_max;\n};\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_scope.h"
		}
	}
]
I0402 15:45:42.269238  5535 json_parser.cpp:18] 
[
	56,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_scope.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/eigen_types.h\"\n\nnamespace allride {\nnamespace mapping {\n\n/// @brief specify a three dimension region\nclass MapScope {\n public:\n  MapScope();\n  MapScope(Eigen::Vector3f center, float range);\n  MapScope(Eigen::Vector3f corner0, Eigen::Vector3f corner1);\n\n  const Eigen::Vector3f& getCornerMin() const;\n  const Eigen::Vector3f& getCornerMax() const;\n\n protected:\n  Eigen::Vector3f corner_min;\n  Eigen::Vector3f corner_max;\n};\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_scope.h"
		}
	}
]
I0402 15:45:42.372753  5535 json_parser.cpp:18] 
[
	57,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/ndt_map_builder.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All rights reserved.\n// Authors: Yongjian Zhao (yongjian.zhao@allride.ai)\n\n#include <vector>\n\n#include <rosbag/bag.h>\n#include <rosbag/message_instance.h>\n#include <rosbag/view.h>\n#include <boost/filesystem.hpp>\n\n#include \"common/geometry/eigen_types.h\"\n#include \"common/geometry/se3.h\"\n#include \"ndt_map_builder.h\"\n\nbool NdtMapBuilder::initialize(const MappingParameter& param) {\n  param_ = param;\n\n  // check existence of rosbag file\n  boost::filesystem::path pcd_bag_path(param_.pcd_rosbag);\n  if (!pcd_bag_path.exists() || !pcd_bag_path.is_regular_file() ||\n      pcd_bag_path.extension() != \".bag\") {\n    std::cout << \"missing pcd_rosbag_file: \" << param_.pcd_rosbag << std::endl;\n    return false;\n  }\n  boost::filesystem::path pose_bag_path(param_.pose_rosbag);\n  if (!pose_bag_path.exists() || !pose_bag_path.is_regular_file() ||\n      pose_bag_path.extension() != \".bag\") {\n    std::cout << \"missing pose_rosbag_file: \" << param_.pose_rosbag << std::endl;\n    return false;\n  }\n\n  // load lidar pose\n  if (!loadLidarPose(param_.pose_rosbag, param_.pose_topic)) {\n    std::cout << \"failed to load lidar pose with topic: \" << param_.pose_topic << std::endl;\n    return false;\n  }\n\n  if (!param_.existing_ndt_map.empty() && !loadNdtMap()) {\n    std::cout << \"failed to load offline ndt map: \" << param_.existing_ndt_map << std::endl;\n    return false;\n  }\n\n  return true;\n}\n\nvoid NdtMapBuilder::buildNdtMap(const std::string& output_folder) {\n  rosbag::Bag bag;\n  bag.open(param_.pcd_rosbag);\n  std::vector<std::string> topics(1, param_.pcd_rosbag);\n  rosbag::View view(bag, rosbag::TopicQuery(topics));\n  for (const rosbag::MessageInstance& m : view) {\n    // get pcd from message\n    std::unique_ptr<PointCloudXYZIRT> pcd;\n\n    // point cloud preprocess\n    pcdPreProcess(param_.type, pcd.get());\n\n    // add pcd to map\n  }\n\n  // ndt map postprocess\n  ndtPosetProcess(param_.type);\n\n  // save map to database\n  saveNdtMap(output_folder);\n}\n\nvoid NdtMapBuilder::pcdPreProcess(const MapType& type, PointCloudXYZIRT* pcd) {\n  switch (type) {\n    case COMMON_NDT:\n\n      break;\n\n    case FEATURE_NDT:\n\n      break;\n\n    case INTENSITY:\n\n      break;\n  }\n}\n\nvoid NdtMapBuilder::ndtPostProcess(const MapType& type) {\n  switch (type) {\n    case COMMON_NDT:\n\n      break;\n\n    case FEATURE_NDT:\n\n      break;\n\n    case INTENSITY:\n\n      break;\n  }\n}\n\nbool NdtMapBuilder::loadLidarPose(const std::string& rosbag_name, const std::string& pose_topic) {\n  rosbag::Bag bag;\n  bag.open(rosbag_name);\n  std::vector<std::string> topics(1, pose_topic);\n  rosbag::View view(bag, rosbag::TopicQuery(topics));\n  for (const rosbag::MessageInstance& m : view) {\n    // get pose from message\n    Time stamp = 0;\n    common::geometry::SE3 pose;\n\n    lidar_poses_[stamp] = pose;\n  }\n\n  bag.close();\n\n  return !lidar_poses_.empty();\n}\n\nbool NdtMapBuilder::loadNdtMap(const std::string& existing_map) { return true; }\n\nbool NdtMapBuilder::saveNdtMap(const std::string& output_folder) { return true; }\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/ndt_map_builder.cpp"
		}
	}
]
I0402 15:45:44.381937  5535 json_parser.cpp:18] 
[
	58,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/ndt_map_builder.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All rights reserved.\n// Authors: Yongjian Zhao (yongjian.zhao@allride.ai)\n\n#include <vector>\n\n#include <rosbag/bag.h>\n#include <rosbag/message_instance.h>\n#include <rosbag/view.h>\n#include <boost/filesystem.hpp>\n\n#include \"common/geometry/eigen_types.h\"\n#include \"common/geometry/se3.h\"\n#include \"ndt_map_builder.h\"\n\nbool NdtMapBuilder::initialize(const MappingParameter& param) {\n  param_ = param;\n\n  // check existence of rosbag file\n  boost::filesystem::path pcd_bag_path(param_.pcd_rosbag);\n  if (!pcd_bag_path.exists() || !pcd_bag_path.is_regular_file() ||\n      pcd_bag_path.extension() != \".bag\") {\n    std::cout << \"missing pcd_rosbag_file: \" << param_.pcd_rosbag << std::endl;\n    return false;\n  }\n  boost::filesystem::path pose_bag_path(param_.pose_rosbag);\n  if (!pose_bag_path.exists() || !pose_bag_path.is_regular_file() ||\n      pose_bag_path.extension() != \".bag\") {\n    std::cout << \"missing pose_rosbag_file: \" << param_.pose_rosbag << std::endl;\n    return false;\n  }\n\n  // load lidar pose\n  if (!loadLidarPose(param_.pose_rosbag, param_.pose_topic)) {\n    std::cout << \"failed to load lidar pose with topic: \" << param_.pose_topic << std::endl;\n    return false;\n  }\n\n  if (!param_.existing_ndt_map.empty() && !loadNdtMap()) {\n    std::cout << \"failed to load offline ndt map: \" << param_.existing_ndt_map << std::endl;\n    return false;\n  }\n\n  return true;\n}\n\nvoid NdtMapBuilder::buildNdtMap(const std::string& output_folder) {\n  rosbag::Bag bag;\n  bag.open(param_.pcd_rosbag);\n  std::vector<std::string> topics(1, param_.pcd_rosbag);\n  rosbag::View view(bag, rosbag::TopicQuery(topics));\n  for (const rosbag::MessageInstance& m : view) {\n    // get pcd from message\n    std::unique_ptr<PointCloudXYZIRT> pcd;\n\n    // point cloud preprocess\n    pcdPreProcess(param_.type, pcd.get());\n\n    // add pcd to map\n  }\n\n  // ndt map postprocess\n  ndtPosetProcess(param_.type);\n\n  // save map to database\n  saveNdtMap(output_folder);\n}\n\nvoid NdtMapBuilder::pcdPreProcess(const MapType& type, PointCloudXYZIRT* pcd) {\n  switch (type) {\n    case COMMON_NDT:\n\n      break;\n\n    case FEATURE_NDT:\n\n      break;\n\n    case INTENSITY:\n\n      break;\n  }\n}\n\nvoid NdtMapBuilder::ndtPostProcess(const MapType& type) {\n  switch (type) {\n    case COMMON_NDT:\n\n      break;\n\n    case FEATURE_NDT:\n\n      break;\n\n    case INTENSITY:\n\n      break;\n  }\n}\n\nbool NdtMapBuilder::loadLidarPose(const std::string& rosbag_name, const std::string& pose_topic) {\n  rosbag::Bag bag;\n  bag.open(rosbag_name);\n  std::vector<std::string> topics(1, pose_topic);\n  rosbag::View view(bag, rosbag::TopicQuery(topics));\n  for (const rosbag::MessageInstance& m : view) {\n    // get pose from message\n    Time stamp = 0;\n    common::geometry::SE3 pose;\n\n    lidar_poses_[stamp] = pose;\n  }\n\n  bag.close();\n\n  return !lidar_poses_.empty();\n}\n\nbool NdtMapBuilder::loadNdtMap(const std::string& existing_map) { return true; }\n\nbool NdtMapBuilder::saveNdtMap(const std::string& output_folder) { return true; }\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/ndt_map_builder.cpp"
		}
	}
]
I0402 15:45:52.666290  5535 json_parser.cpp:18] 
[
	59,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/ndt_map_builder.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All rights reserved.\n// Authors: Yongjian Zhao (yongjian.zhao@allride.ai)\n\n#include <vector>\n\n#include <rosbag/bag.h>\n#include <rosbag/message_instance.h>\n#include <rosbag/view.h>\n#include <boost/filesystem.hpp>\n\n#include \"common/geometry/eigen_types.h\"\n#include \"common/geometry/se3.h\"\n#include \"ndt_map_builder.h\"\n\nbool NdtMapBuilder::initialize(const MappingParameter& param) {\n  param_ = param;\n  \n\n  // check existence of rosbag file\n  boost::filesystem::path pcd_bag_path(param_.pcd_rosbag);\n  if (!pcd_bag_path.exists() || !pcd_bag_path.is_regular_file() ||\n      pcd_bag_path.extension() != \".bag\") {\n    std::cout << \"missing pcd_rosbag_file: \" << param_.pcd_rosbag << std::endl;\n    return false;\n  }\n  boost::filesystem::path pose_bag_path(param_.pose_rosbag);\n  if (!pose_bag_path.exists() || !pose_bag_path.is_regular_file() ||\n      pose_bag_path.extension() != \".bag\") {\n    std::cout << \"missing pose_rosbag_file: \" << param_.pose_rosbag << std::endl;\n    return false;\n  }\n\n  // load lidar pose\n  if (!loadLidarPose(param_.pose_rosbag, param_.pose_topic)) {\n    std::cout << \"failed to load lidar pose with topic: \" << param_.pose_topic << std::endl;\n    return false;\n  }\n\n  if (!param_.existing_ndt_map.empty() && !loadNdtMap()) {\n    std::cout << \"failed to load offline ndt map: \" << param_.existing_ndt_map << std::endl;\n    return false;\n  }\n\n  return true;\n}\n\nvoid NdtMapBuilder::buildNdtMap(const std::string& output_folder) {\n  rosbag::Bag bag;\n  bag.open(param_.pcd_rosbag);\n  std::vector<std::string> topics(1, param_.pcd_rosbag);\n  rosbag::View view(bag, rosbag::TopicQuery(topics));\n  for (const rosbag::MessageInstance& m : view) {\n    // get pcd from message\n    std::unique_ptr<PointCloudXYZIRT> pcd;\n\n    // point cloud preprocess\n    pcdPreProcess(param_.type, pcd.get());\n\n    // add pcd to map\n  }\n\n  // ndt map postprocess\n  ndtPosetProcess(param_.type);\n\n  // save map to database\n  saveNdtMap(output_folder);\n}\n\nvoid NdtMapBuilder::pcdPreProcess(const MapType& type, PointCloudXYZIRT* pcd) {\n  switch (type) {\n    case COMMON_NDT:\n\n      break;\n\n    case FEATURE_NDT:\n\n      break;\n\n    case INTENSITY:\n\n      break;\n  }\n}\n\nvoid NdtMapBuilder::ndtPostProcess(const MapType& type) {\n  switch (type) {\n    case COMMON_NDT:\n\n      break;\n\n    case FEATURE_NDT:\n\n      break;\n\n    case INTENSITY:\n\n      break;\n  }\n}\n\nbool NdtMapBuilder::loadLidarPose(const std::string& rosbag_name, const std::string& pose_topic) {\n  rosbag::Bag bag;\n  bag.open(rosbag_name);\n  std::vector<std::string> topics(1, pose_topic);\n  rosbag::View view(bag, rosbag::TopicQuery(topics));\n  for (const rosbag::MessageInstance& m : view) {\n    // get pose from message\n    Time stamp = 0;\n    common::geometry::SE3 pose;\n\n    lidar_poses_[stamp] = pose;\n  }\n\n  bag.close();\n\n  return !lidar_poses_.empty();\n}\n\nbool NdtMapBuilder::loadNdtMap(const std::string& existing_map) { return true; }\n\nbool NdtMapBuilder::saveNdtMap(const std::string& output_folder) { return true; }\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/ndt_map_builder.cpp"
		}
	}
]
I0402 15:45:53.903446  5535 json_parser.cpp:18] 
[
	60,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/ndt_map_builder.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All rights reserved.\n// Authors: Yongjian Zhao (yongjian.zhao@allride.ai)\n\n#include <vector>\n\n#include <rosbag/bag.h>\n#include <rosbag/message_instance.h>\n#include <rosbag/view.h>\n#include <boost/filesystem.hpp>\n\n#include \"common/geometry/eigen_types.h\"\n#include \"common/geometry/se3.h\"\n#include \"ndt_map_builder.h\"\n\nbool NdtMapBuilder::initialize(const MappingParameter& param) {\n  param_ = param;\n\n\n  // check existence of rosbag file\n  boost::filesystem::path pcd_bag_path(param_.pcd_rosbag);\n  if (!pcd_bag_path.exists() || !pcd_bag_path.is_regular_file() ||\n      pcd_bag_path.extension() != \".bag\") {\n    std::cout << \"missing pcd_rosbag_file: \" << param_.pcd_rosbag << std::endl;\n    return false;\n  }\n  boost::filesystem::path pose_bag_path(param_.pose_rosbag);\n  if (!pose_bag_path.exists() || !pose_bag_path.is_regular_file() ||\n      pose_bag_path.extension() != \".bag\") {\n    std::cout << \"missing pose_rosbag_file: \" << param_.pose_rosbag << std::endl;\n    return false;\n  }\n\n  // load lidar pose\n  if (!loadLidarPose(param_.pose_rosbag, param_.pose_topic)) {\n    std::cout << \"failed to load lidar pose with topic: \" << param_.pose_topic << std::endl;\n    return false;\n  }\n\n  if (!param_.existing_ndt_map.empty() && !loadNdtMap()) {\n    std::cout << \"failed to load offline ndt map: \" << param_.existing_ndt_map << std::endl;\n    return false;\n  }\n\n  return true;\n}\n\nvoid NdtMapBuilder::buildNdtMap(const std::string& output_folder) {\n  rosbag::Bag bag;\n  bag.open(param_.pcd_rosbag);\n  std::vector<std::string> topics(1, param_.pcd_rosbag);\n  rosbag::View view(bag, rosbag::TopicQuery(topics));\n  for (const rosbag::MessageInstance& m : view) {\n    // get pcd from message\n    std::unique_ptr<PointCloudXYZIRT> pcd;\n\n    // point cloud preprocess\n    pcdPreProcess(param_.type, pcd.get());\n\n    // add pcd to map\n  }\n\n  // ndt map postprocess\n  ndtPosetProcess(param_.type);\n\n  // save map to database\n  saveNdtMap(output_folder);\n}\n\nvoid NdtMapBuilder::pcdPreProcess(const MapType& type, PointCloudXYZIRT* pcd) {\n  switch (type) {\n    case COMMON_NDT:\n\n      break;\n\n    case FEATURE_NDT:\n\n      break;\n\n    case INTENSITY:\n\n      break;\n  }\n}\n\nvoid NdtMapBuilder::ndtPostProcess(const MapType& type) {\n  switch (type) {\n    case COMMON_NDT:\n\n      break;\n\n    case FEATURE_NDT:\n\n      break;\n\n    case INTENSITY:\n\n      break;\n  }\n}\n\nbool NdtMapBuilder::loadLidarPose(const std::string& rosbag_name, const std::string& pose_topic) {\n  rosbag::Bag bag;\n  bag.open(rosbag_name);\n  std::vector<std::string> topics(1, pose_topic);\n  rosbag::View view(bag, rosbag::TopicQuery(topics));\n  for (const rosbag::MessageInstance& m : view) {\n    // get pose from message\n    Time stamp = 0;\n    common::geometry::SE3 pose;\n\n    lidar_poses_[stamp] = pose;\n  }\n\n  bag.close();\n\n  return !lidar_poses_.empty();\n}\n\nbool NdtMapBuilder::loadNdtMap(const std::string& existing_map) { return true; }\n\nbool NdtMapBuilder::saveNdtMap(const std::string& output_folder) { return true; }\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/ndt_map_builder.cpp"
		}
	}
]
I0402 15:45:54.004119  5535 json_parser.cpp:18] 
[
	61,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/ndt_map_builder.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All rights reserved.\n// Authors: Yongjian Zhao (yongjian.zhao@allride.ai)\n\n#include <vector>\n\n#include <rosbag/bag.h>\n#include <rosbag/message_instance.h>\n#include <rosbag/view.h>\n#include <boost/filesystem.hpp>\n\n#include \"common/geometry/eigen_types.h\"\n#include \"common/geometry/se3.h\"\n#include \"ndt_map_builder.h\"\n\nbool NdtMapBuilder::initialize(const MappingParameter& param) {\n  param_ = param;\n\n\n  // check existence of rosbag file\n  boost::filesystem::path pcd_bag_path(param_.pcd_rosbag);\n  if (!pcd_bag_path.exists() || !pcd_bag_path.is_regular_file() ||\n      pcd_bag_path.extension() != \".bag\") {\n    std::cout << \"missing pcd_rosbag_file: \" << param_.pcd_rosbag << std::endl;\n    return false;\n  }\n  boost::filesystem::path pose_bag_path(param_.pose_rosbag);\n  if (!pose_bag_path.exists() || !pose_bag_path.is_regular_file() ||\n      pose_bag_path.extension() != \".bag\") {\n    std::cout << \"missing pose_rosbag_file: \" << param_.pose_rosbag << std::endl;\n    return false;\n  }\n\n  // load lidar pose\n  if (!loadLidarPose(param_.pose_rosbag, param_.pose_topic)) {\n    std::cout << \"failed to load lidar pose with topic: \" << param_.pose_topic << std::endl;\n    return false;\n  }\n\n  if (!param_.existing_ndt_map.empty() && !loadNdtMap()) {\n    std::cout << \"failed to load offline ndt map: \" << param_.existing_ndt_map << std::endl;\n    return false;\n  }\n\n  return true;\n}\n\nvoid NdtMapBuilder::buildNdtMap(const std::string& output_folder) {\n  rosbag::Bag bag;\n  bag.open(param_.pcd_rosbag);\n  std::vector<std::string> topics(1, param_.pcd_rosbag);\n  rosbag::View view(bag, rosbag::TopicQuery(topics));\n  for (const rosbag::MessageInstance& m : view) {\n    // get pcd from message\n    std::unique_ptr<PointCloudXYZIRT> pcd;\n\n    // point cloud preprocess\n    pcdPreProcess(param_.type, pcd.get());\n\n    // add pcd to map\n  }\n\n  // ndt map postprocess\n  ndtPosetProcess(param_.type);\n\n  // save map to database\n  saveNdtMap(output_folder);\n}\n\nvoid NdtMapBuilder::pcdPreProcess(const MapType& type, PointCloudXYZIRT* pcd) {\n  switch (type) {\n    case COMMON_NDT:\n\n      break;\n\n    case FEATURE_NDT:\n\n      break;\n\n    case INTENSITY:\n\n      break;\n  }\n}\n\nvoid NdtMapBuilder::ndtPostProcess(const MapType& type) {\n  switch (type) {\n    case COMMON_NDT:\n\n      break;\n\n    case FEATURE_NDT:\n\n      break;\n\n    case INTENSITY:\n\n      break;\n  }\n}\n\nbool NdtMapBuilder::loadLidarPose(const std::string& rosbag_name, const std::string& pose_topic) {\n  rosbag::Bag bag;\n  bag.open(rosbag_name);\n  std::vector<std::string> topics(1, pose_topic);\n  rosbag::View view(bag, rosbag::TopicQuery(topics));\n  for (const rosbag::MessageInstance& m : view) {\n    // get pose from message\n    Time stamp = 0;\n    common::geometry::SE3 pose;\n\n    lidar_poses_[stamp] = pose;\n  }\n\n  bag.close();\n\n  return !lidar_poses_.empty();\n}\n\nbool NdtMapBuilder::loadNdtMap(const std::string& existing_map) { return true; }\n\nbool NdtMapBuilder::saveNdtMap(const std::string& output_folder) { return true; }\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/ndt_map_builder.cpp"
		}
	}
]
I0402 15:45:54.542567  5535 json_parser.cpp:18] 
[
	62,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/ndt_map_builder.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All rights reserved.\n// Authors: Yongjian Zhao (yongjian.zhao@allride.ai)\n\n#include <vector>\n\n#include <rosbag/bag.h>\n#include <rosbag/message_instance.h>\n#include <rosbag/view.h>\n#include <boost/filesystem.hpp>\n\n#include \"common/geometry/eigen_types.h\"\n#include \"common/geometry/se3.h\"\n#include \"ndt_map_builder.h\"\n\nbool NdtMapBuilder::initialize(const MappingParameter& param) {\n  param_ = param;\n\n  // check existence of rosbag file\n  boost::filesystem::path pcd_bag_path(param_.pcd_rosbag);\n  if (!pcd_bag_path.exists() || !pcd_bag_path.is_regular_file() ||\n      pcd_bag_path.extension() != \".bag\") {\n    std::cout << \"missing pcd_rosbag_file: \" << param_.pcd_rosbag << std::endl;\n    return false;\n  }\n  boost::filesystem::path pose_bag_path(param_.pose_rosbag);\n  if (!pose_bag_path.exists() || !pose_bag_path.is_regular_file() ||\n      pose_bag_path.extension() != \".bag\") {\n    std::cout << \"missing pose_rosbag_file: \" << param_.pose_rosbag << std::endl;\n    return false;\n  }\n\n  // load lidar pose\n  if (!loadLidarPose(param_.pose_rosbag, param_.pose_topic)) {\n    std::cout << \"failed to load lidar pose with topic: \" << param_.pose_topic << std::endl;\n    return false;\n  }\n\n  if (!param_.existing_ndt_map.empty() && !loadNdtMap()) {\n    std::cout << \"failed to load offline ndt map: \" << param_.existing_ndt_map << std::endl;\n    return false;\n  }\n\n  return true;\n}\n\nvoid NdtMapBuilder::buildNdtMap(const std::string& output_folder) {\n  rosbag::Bag bag;\n  bag.open(param_.pcd_rosbag);\n  std::vector<std::string> topics(1, param_.pcd_rosbag);\n  rosbag::View view(bag, rosbag::TopicQuery(topics));\n  for (const rosbag::MessageInstance& m : view) {\n    // get pcd from message\n    std::unique_ptr<PointCloudXYZIRT> pcd;\n\n    // point cloud preprocess\n    pcdPreProcess(param_.type, pcd.get());\n\n    // add pcd to map\n  }\n\n  // ndt map postprocess\n  ndtPosetProcess(param_.type);\n\n  // save map to database\n  saveNdtMap(output_folder);\n}\n\nvoid NdtMapBuilder::pcdPreProcess(const MapType& type, PointCloudXYZIRT* pcd) {\n  switch (type) {\n    case COMMON_NDT:\n\n      break;\n\n    case FEATURE_NDT:\n\n      break;\n\n    case INTENSITY:\n\n      break;\n  }\n}\n\nvoid NdtMapBuilder::ndtPostProcess(const MapType& type) {\n  switch (type) {\n    case COMMON_NDT:\n\n      break;\n\n    case FEATURE_NDT:\n\n      break;\n\n    case INTENSITY:\n\n      break;\n  }\n}\n\nbool NdtMapBuilder::loadLidarPose(const std::string& rosbag_name, const std::string& pose_topic) {\n  rosbag::Bag bag;\n  bag.open(rosbag_name);\n  std::vector<std::string> topics(1, pose_topic);\n  rosbag::View view(bag, rosbag::TopicQuery(topics));\n  for (const rosbag::MessageInstance& m : view) {\n    // get pose from message\n    Time stamp = 0;\n    common::geometry::SE3 pose;\n\n    lidar_poses_[stamp] = pose;\n  }\n\n  bag.close();\n\n  return !lidar_poses_.empty();\n}\n\nbool NdtMapBuilder::loadNdtMap(const std::string& existing_map) { return true; }\n\nbool NdtMapBuilder::saveNdtMap(const std::string& output_folder) { return true; }\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/ndt_map_builder.cpp"
		}
	}
]
I0402 15:46:01.033356  5535 json_parser.cpp:18] 
[
	63,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/ndt_map_builder.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All rights reserved.\n// Authors: Yongjian Zhao (yongjian.zhao@allride.ai)\n\n#include <vector>\n\n#include <rosbag/bag.h>\n#include <rosbag/message_instance.h>\n#include <rosbag/view.h>\n#include <boost/filesystem.hpp>\n\n#include \"common/geometry/eigen_types.h\"\n#include \"common/geometry/se3.h\"\n#include \"ndt_map_builder.h\"\n\nbool NdtMapBuilder::initialize(const MappingParameter& param) {\n  param_ = param;\n\n  // check existence of rosbag file\n  boost::filesystem::path pcd_bag_path(param_.pcd_rosbag);\n  if (!pcd_bag_path.exists() || !pcd_bag_path.is_regular_file() ||\n      pcd_bag_path.extension() != \".bag\") {\n    std::cout << \"missing pcd_rosbag_file: \" << param_.pcd_rosbag << std::endl;\n    return false;\n  }\n  boost::filesystem::path pose_bag_path(param_.pose_rosbag);\n  if (!pose_bag_path.exists() || !pose_bag_path.is_regular_file() ||\n      pose_bag_path.extension() != \".bag\") {\n    std::cout << \"missing pose_rosbag_file: \" << param_.pose_rosbag << std::endl;\n    return false;\n  }\n\n  // load lidar pose\n  if (!loadLidarPose(param_.pose_rosbag, param_.pose_topic)) {\n    std::cout << \"failed to load lidar pose with topic: \" << param_.pose_topic << std::endl;\n    return false;\n  }\n\n  if (!param_.existing_ndt_map.empty() && !loadNdtMap()) {\n    std::cout << \"failed to load offline ndt map: \" << param_.existing_ndt_map << std::endl;\n    return false;\n  }\n\n  return true;\n}\n\nvoid NdtMapBuilder::buildNdtMap(const std::string& output_folder) {\n  rosbag::Bag bag;\n  bag.open(param_.pcd_rosbag);\n  std::vector<std::string> topics(1, param_.pcd_rosbag);\n  rosbag::View view(bag, rosbag::TopicQuery(topics));\n  for (const rosbag::MessageInstance& m : view) {\n    // get pcd from message\n    std::unique_ptr<PointCloudXYZIRT> pcd;\n\n    // point cloud preprocess\n    pcdPreProcess(param_.type, pcd.get());\n\n    // add pcd to map\n  }\n\n  // ndt map postprocess\n  ndtPosetProcess(param_.type);\n\n  // save map to database\n  saveNdtMap(output_folder);\n}\n\nvoid NdtMapBuilder::pcdPreProcess(const MapType& type, PointCloudXYZIRT* pcd) {\n  switch (type) {\n    case COMMON_NDT:\n\n      break;\n\n    case FEATURE_NDT:\n\n      break;\n\n    case INTENSITY:\n\n      break;\n  }\n}\n\nvoid NdtMapBuilder::ndtPostProcess(const MapType& type) {\n  switch (type) {\n    case COMMON_NDT:\n\n      break;\n\n    case FEATURE_NDT:\n\n      break;\n\n    case INTENSITY:\n\n      break;\n  }\n}\n\nbool NdtMapBuilder::loadLidarPose(const std::string& rosbag_name, const std::string& pose_topic) {\n  rosbag::Bag bag;\n  bag.open(rosbag_name);\n  std::vector<std::string> topics(1, pose_topic);\n  rosbag::View view(bag, rosbag::TopicQuery(topics));\n  for (const rosbag::MessageInstance& m : view) {\n    // get pose from message\n    Time stamp = 0;\n    common::geometry::SE3 pose;\n\n    lidar_poses_[stamp] = pose;\n  }\n\n  bag.close();\n\n  return !lidar_poses_.empty();\n}\n\nbool NdtMapBuilder::loadNdtMap(const std::string& existing_map) { return true; }\n\nbool NdtMapBuilder::saveNdtMap(const std::string& output_folder) { return true; }\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/ndt_map_builder.cpp"
		}
	}
]
I0402 15:46:01.076601  5535 json_parser.cpp:18] 
[
	64,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/ndt_map_builder.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All rights reserved.\n// Authors: Yongjian Zhao (yongjian.zhao@allride.ai)\n\n#include <vector>\n\n#include <rosbag/bag.h>\n#include <rosbag/message_instance.h>\n#include <rosbag/view.h>\n#include <boost/filesystem.hpp>\n\n#include \"common/geometry/eigen_types.h\"\n#include \"common/geometry/se3.h\"\n#include \"ndt_map_builder.h\"\n\nbool NdtMapBuilder::initialize(const MappingParameter& param) {\n  param_ = param;\n\n  // check existence of rosbag file\n  boost::filesystem::path pcd_bag_path(param_.pcd_rosbag);\n  if (!pcd_bag_path.exists() || !pcd_bag_path.is_regular_file() ||\n      pcd_bag_path.extension() != \".bag\") {\n    std::cout << \"missing pcd_rosbag_file: \" << param_.pcd_rosbag << std::endl;\n    return false;\n  }\n  boost::filesystem::path pose_bag_path(param_.pose_rosbag);\n  if (!pose_bag_path.exists() || !pose_bag_path.is_regular_file() ||\n      pose_bag_path.extension() != \".bag\") {\n    std::cout << \"missing pose_rosbag_file: \" << param_.pose_rosbag << std::endl;\n    return false;\n  }\n\n  // load lidar pose\n  if (!loadLidarPose(param_.pose_rosbag, param_.pose_topic)) {\n    std::cout << \"failed to load lidar pose with topic: \" << param_.pose_topic << std::endl;\n    return false;\n  }\n\n  if (!param_.existing_ndt_map.empty() && !loadNdtMap()) {\n    std::cout << \"failed to load offline ndt map: \" << param_.existing_ndt_map << std::endl;\n    return false;\n  }\n\n  return true;\n}\n\nvoid NdtMapBuilder::buildNdtMap(const std::string& output_folder) {\n  rosbag::Bag bag;\n  bag.open(param_.pcd_rosbag);\n  std::vector<std::string> topics(1, param_.pcd_rosbag);\n  rosbag::View view(bag, rosbag::TopicQuery(topics));\n  for (const rosbag::MessageInstance& m : view) {\n    // get pcd from message\n    std::unique_ptr<PointCloudXYZIRT> pcd;\n\n    // point cloud preprocess\n    pcdPreProcess(param_.type, pcd.get());\n\n    // add pcd to map\n  }\n\n  // ndt map postprocess\n  ndtPosetProcess(param_.type);\n\n  // save map to database\n  saveNdtMap(output_folder);\n}\n\nvoid NdtMapBuilder::pcdPreProcess(const MapType& type, PointCloudXYZIRT* pcd) {\n  switch (type) {\n    case COMMON_NDT:\n\n      break;\n\n    case FEATURE_NDT:\n\n      break;\n\n    case INTENSITY:\n\n      break;\n  }\n}\n\nvoid NdtMapBuilder::ndtPostProcess(const MapType& type) {\n  switch (type) {\n    case COMMON_NDT:\n\n      break;\n\n    case FEATURE_NDT:\n\n      break;\n\n    case INTENSITY:\n\n      break;\n  }\n}\n\nbool NdtMapBuilder::loadLidarPose(const std::string& rosbag_name, const std::string& pose_topic) {\n  rosbag::Bag bag;\n  bag.open(rosbag_name);\n  std::vector<std::string> topics(1, pose_topic);\n  rosbag::View view(bag, rosbag::TopicQuery(topics));\n  for (const rosbag::MessageInstance& m : view) {\n    // get pose from message\n    Time stamp = 0;\n    common::geometry::SE3 pose;\n\n    lidar_poses_[stamp] = pose;\n  }\n\n  bag.close();\n\n  return !lidar_poses_.empty();\n}\n\nbool NdtMapBuilder::loadNdtMap(const std::string& existing_map) { return true; }\n\nbool NdtMapBuilder::saveNdtMap(const std::string& output_folder) { return true; }\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/ndt_map_builder.cpp"
		}
	}
]
I0402 15:46:01.143446  5535 json_parser.cpp:18] 
[
	66,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/ndt_map_builder.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All rights reserved.\n// Authors: Yongjian Zhao (yongjian.zhao@allride.ai)\n\n#pragma once\n\n#include <map>\n#include <memory>\n#include <string>\n#include <unordered_map>\n\n#include \"common/math/point_types.h\"\n#include \"local_database.h\"\n#include \"tile_data_storage.h\"\n#include \"tiler.h\"\n\nnamespace allride {\nnamespace mapping {\n\nenum MapType { COMMON_NDT = 0, FEATURE_NDT, INTENSITY };\n\ntypedef uint64_t Time;\n\nstruct MappingParameter {\n  MapType type;\n  float grid_size;\n  float tile_size;\n\n  std::stirng pcd_rosbag;\n  std::string pcd_topic;\n  std::string pose_rosbag;\n  std::string pose_topic;\n\n  std::string existing_ndt_map;\n};\n\nclass NdtMapBuilder {\n public:\n  NdtMapBuilder() = default;\n  ~NdtMapBuilder() = default;\n\n  bool initialize(const MappingParameter& param);\n\n  void buildNdtMap(const std::string& output_folder);\n\n protected:\n  MappingParameter param_;\n  std::unordered_map<Tiler::TileID, std::unique_ptr<TileDataStorage>> ndt_map_data_;\n\n private:\n  void pcdPreProcess(const MapType& type, PointCloudXYZIRT* pcd);\n\n  void ndtPostProcess(const MapType& type);\n\n  bool saveNdtMap(const std::string& output_folder);\n\n  bool loadLidarPose(const std::string& rosbag_name, const std::string& pose_topic);\n\n  bool loadNdtMap(const std::string& existing_map);\n\n  std::map<Time, common::geometry::SE3, Eigen::allocator_aligned<common::geometry::SE3>>\n      lidar_poses_;\n};\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/ndt_map_builder.h"
		}
	}
]
I0402 15:46:01.396376  5535 json_parser.cpp:18] 
[
	67,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/ndt_map_builder.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All rights reserved.\n// Authors: Yongjian Zhao (yongjian.zhao@allride.ai)\n\n#pragma once\n\n#include <map>\n#include <memory>\n#include <string>\n#include <unordered_map>\n\n#include \"common/math/point_types.h\"\n#include \"local_database.h\"\n#include \"tile_data_storage.h\"\n#include \"tiler.h\"\n\nnamespace allride {\nnamespace mapping {\n\nenum MapType { COMMON_NDT = 0, FEATURE_NDT, INTENSITY };\n\ntypedef uint64_t Time;\n\nstruct MappingParameter {\n  MapType type;\n  float grid_size;\n  float tile_size;\n\n  std::stirng pcd_rosbag;\n  std::string pcd_topic;\n  std::string pose_rosbag;\n  std::string pose_topic;\n\n  std::string existing_ndt_map;\n};\n\nclass NdtMapBuilder {\n public:\n  NdtMapBuilder() = default;\n  ~NdtMapBuilder() = default;\n\n  bool initialize(const MappingParameter& param);\n\n  void buildNdtMap(const std::string& output_folder);\n\n protected:\n  MappingParameter param_;\n  std::unordered_map<Tiler::TileID, std::unique_ptr<TileDataStorage>> ndt_map_data_;\n\n private:\n  void pcdPreProcess(const MapType& type, PointCloudXYZIRT* pcd);\n\n  void ndtPostProcess(const MapType& type);\n\n  bool saveNdtMap(const std::string& output_folder);\n\n  bool loadLidarPose(const std::string& rosbag_name, const std::string& pose_topic);\n\n  bool loadNdtMap(const std::string& existing_map);\n\n  std::map<Time, common::geometry::SE3, Eigen::allocator_aligned<common::geometry::SE3>>\n      lidar_poses_;\n};\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/ndt_map_builder.h"
		}
	}
]
I0402 15:46:03.110066  5535 json_parser.cpp:18] 
[
	68,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/ndt_map_builder.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All rights reserved.\n// Authors: Yongjian Zhao (yongjian.zhao@allride.ai)\n\n#pragma once\n\n#include <map>\n#include <memory>\n#include <string>\n#include <unordered_map>\n\n#include \"common/math/point_types.h\"\n#include \"local_database.h\"\n#include \"tile_data_storage.h\"\n#include \"tiler.h\"\n\nnamespace allride {\nnamespace mapping {\n\nenum MapType { COMMON_NDT = 0, FEATURE_NDT, INTENSITY };\n\ntypedef uint64_t Time;\n\nstruct MappingParameter {\n  MapType type;\n  float grid_size;\n  float tile_size;\n\n  std::stirng pcd_rosbag;\n  std::string pcd_topic;\n  std::string pose_rosbag;\n  std::string pose_topic;\n\n  std::string existing_ndt_map;\n};\n\nclass NdtMapBuilder {\n public:\n  NdtMapBuilder() = default;\n  ~NdtMapBuilder() = default;\n\n  bool initialize(const MappingParameter& param);\n\n  void buildNdtMap(const std::string& output_folder);\n\n protected:\n  MappingParameter param_;\n  std::unordered_map<Tiler::TileID, std::unique_ptr<TileDataStorage>> ndt_map_data_;\n\n private:\n  void pcdPreProcess(const MapType& type, PointCloudXYZIRT* pcd);\n\n  void ndtPostProcess(const MapType& type);\n\n  bool saveNdtMap(const std::string& output_folder);\n\n  bool loadLidarPose(const std::string& rosbag_name, const std::string& pose_topic);\n\n  bool loadNdtMap(const std::string& existing_map);\n\n  std::map<Time, common::geometry::SE3, Eigen::allocator_aligned<common::geometry::SE3>>\n      lidar_poses_;\n};\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/ndt_map_builder.h"
		}
	}
]
I0402 15:46:03.126878  5535 json_parser.cpp:18] 
[
	69,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/ndt_map_builder.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All rights reserved.\n// Authors: Yongjian Zhao (yongjian.zhao@allride.ai)\n\n#pragma once\n\n#include <map>\n#include <memory>\n#include <string>\n#include <unordered_map>\n\n#include \"common/math/point_types.h\"\n#include \"local_database.h\"\n#include \"tile_data_storage.h\"\n#include \"tiler.h\"\n\nnamespace allride {\nnamespace mapping {\n\nenum MapType { COMMON_NDT = 0, FEATURE_NDT, INTENSITY };\n\ntypedef uint64_t Time;\n\nstruct MappingParameter {\n  MapType type;\n  float grid_size;\n  float tile_size;\n\n  std::stirng pcd_rosbag;\n  std::string pcd_topic;\n  std::string pose_rosbag;\n  std::string pose_topic;\n\n  std::string existing_ndt_map;\n};\n\nclass NdtMapBuilder {\n public:\n  NdtMapBuilder() = default;\n  ~NdtMapBuilder() = default;\n\n  bool initialize(const MappingParameter& param);\n\n  void buildNdtMap(const std::string& output_folder);\n\n protected:\n  MappingParameter param_;\n  std::unordered_map<Tiler::TileID, std::unique_ptr<TileDataStorage>> ndt_map_data_;\n\n private:\n  void pcdPreProcess(const MapType& type, PointCloudXYZIRT* pcd);\n\n  void ndtPostProcess(const MapType& type);\n\n  bool saveNdtMap(const std::string& output_folder);\n\n  bool loadLidarPose(const std::string& rosbag_name, const std::string& pose_topic);\n\n  bool loadNdtMap(const std::string& existing_map);\n\n  std::map<Time, common::geometry::SE3, Eigen::allocator_aligned<common::geometry::SE3>>\n      lidar_poses_;\n};\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/ndt_map_builder.h"
		}
	}
]
I0402 15:46:03.140805  5535 json_parser.cpp:18] 
[
	70,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/ndt_map_builder.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All rights reserved.\n// Authors: Yongjian Zhao (yongjian.zhao@allride.ai)\n\n#pragma once\n\n#include <map>\n#include <memory>\n#include <string>\n#include <unordered_map>\n\n#include \"common/math/point_types.h\"\n#include \"local_database.h\"\n#include \"tile_data_storage.h\"\n#include \"tiler.h\"\n\nnamespace allride {\nnamespace mapping {\n\nenum MapType { COMMON_NDT = 0, FEATURE_NDT, INTENSITY };\n\ntypedef uint64_t Time;\n\nstruct MappingParameter {\n  MapType type;\n  float grid_size;\n  float tile_size;\n\n  std::stirng pcd_rosbag;\n  std::string pcd_topic;\n  std::string pose_rosbag;\n  std::string pose_topic;\n\n  std::string existing_ndt_map;\n};\n\nclass NdtMapBuilder {\n public:\n  NdtMapBuilder() = default;\n  ~NdtMapBuilder() = default;\n\n  bool initialize(const MappingParameter& param);\n\n  void buildNdtMap(const std::string& output_folder);\n\n protected:\n  MappingParameter param_;\n  std::unordered_map<Tiler::TileID, std::unique_ptr<TileDataStorage>> ndt_map_data_;\n\n private:\n  void pcdPreProcess(const MapType& type, PointCloudXYZIRT* pcd);\n\n  void ndtPostProcess(const MapType& type);\n\n  bool saveNdtMap(const std::string& output_folder);\n\n  bool loadLidarPose(const std::string& rosbag_name, const std::string& pose_topic);\n\n  bool loadNdtMap(const std::string& existing_map);\n\n  std::map<Time, common::geometry::SE3, Eigen::allocator_aligned<common::geometry::SE3>>\n      lidar_poses_;\n};\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/ndt_map_builder.h"
		}
	}
]
I0402 15:46:03.156092  5535 json_parser.cpp:18] 
[
	71,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/ndt_map_builder.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All rights reserved.\n// Authors: Yongjian Zhao (yongjian.zhao@allride.ai)\n\n#include <vector>\n\n#include <rosbag/bag.h>\n#include <rosbag/message_instance.h>\n#include <rosbag/view.h>\n#include <boost/filesystem.hpp>\n\n#include \"common/geometry/eigen_types.h\"\n#include \"common/geometry/se3.h\"\n#include \"ndt_map_builder.h\"\n\nbool NdtMapBuilder::initialize(const MappingParameter& param) {\n  param_ = param;\n\n  // check existence of rosbag file\n  boost::filesystem::path pcd_bag_path(param_.pcd_rosbag);\n  if (!pcd_bag_path.exists() || !pcd_bag_path.is_regular_file() ||\n      pcd_bag_path.extension() != \".bag\") {\n    std::cout << \"missing pcd_rosbag_file: \" << param_.pcd_rosbag << std::endl;\n    return false;\n  }\n  boost::filesystem::path pose_bag_path(param_.pose_rosbag);\n  if (!pose_bag_path.exists() || !pose_bag_path.is_regular_file() ||\n      pose_bag_path.extension() != \".bag\") {\n    std::cout << \"missing pose_rosbag_file: \" << param_.pose_rosbag << std::endl;\n    return false;\n  }\n\n  // load lidar pose\n  if (!loadLidarPose(param_.pose_rosbag, param_.pose_topic)) {\n    std::cout << \"failed to load lidar pose with topic: \" << param_.pose_topic << std::endl;\n    return false;\n  }\n\n  if (!param_.existing_ndt_map.empty() && !loadNdtMap()) {\n    std::cout << \"failed to load offline ndt map: \" << param_.existing_ndt_map << std::endl;\n    return false;\n  }\n\n  return true;\n}\n\nvoid NdtMapBuilder::buildNdtMap(const std::string& output_folder) {\n  rosbag::Bag bag;\n  bag.open(param_.pcd_rosbag);\n  std::vector<std::string> topics(1, param_.pcd_rosbag);\n  rosbag::View view(bag, rosbag::TopicQuery(topics));\n  for (const rosbag::MessageInstance& m : view) {\n    // get pcd from message\n    std::unique_ptr<PointCloudXYZIRT> pcd;\n\n    // point cloud preprocess\n    pcdPreProcess(param_.type, pcd.get());\n\n    // add pcd to map\n  }\n\n  // ndt map postprocess\n  ndtPosetProcess(param_.type);\n\n  // save map to database\n  saveNdtMap(output_folder);\n}\n\nvoid NdtMapBuilder::pcdPreProcess(const MapType& type, PointCloudXYZIRT* pcd) {\n  switch (type) {\n    case COMMON_NDT:\n\n      break;\n\n    case FEATURE_NDT:\n\n      break;\n\n    case INTENSITY:\n\n      break;\n  }\n}\n\nvoid NdtMapBuilder::ndtPostProcess(const MapType& type) {\n  switch (type) {\n    case COMMON_NDT:\n\n      break;\n\n    case FEATURE_NDT:\n\n      break;\n\n    case INTENSITY:\n\n      break;\n  }\n}\n\nbool NdtMapBuilder::loadLidarPose(const std::string& rosbag_name, const std::string& pose_topic) {\n  rosbag::Bag bag;\n  bag.open(rosbag_name);\n  std::vector<std::string> topics(1, pose_topic);\n  rosbag::View view(bag, rosbag::TopicQuery(topics));\n  for (const rosbag::MessageInstance& m : view) {\n    // get pose from message\n    Time stamp = 0;\n    common::geometry::SE3 pose;\n\n    lidar_poses_[stamp] = pose;\n  }\n\n  bag.close();\n\n  return !lidar_poses_.empty();\n}\n\nbool NdtMapBuilder::loadNdtMap(const std::string& existing_map) { return true; }\n\nbool NdtMapBuilder::saveNdtMap(const std::string& output_folder) { return true; }\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/ndt_map_builder.cpp"
		}
	}
]
I0402 15:46:03.223913  5535 json_parser.cpp:18] 
[
	72,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/ndt_map_builder.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All rights reserved.\n// Authors: Yongjian Zhao (yongjian.zhao@allride.ai)\n\n#include <vector>\n\n#include <rosbag/bag.h>\n#include <rosbag/message_instance.h>\n#include <rosbag/view.h>\n#include <boost/filesystem.hpp>\n\n#include \"common/geometry/eigen_types.h\"\n#include \"common/geometry/se3.h\"\n#include \"ndt_map_builder.h\"\n\nbool NdtMapBuilder::initialize(const MappingParameter& param) {\n  param_ = param;\n\n  // check existence of rosbag file\n  boost::filesystem::path pcd_bag_path(param_.pcd_rosbag);\n  if (!pcd_bag_path.exists() || !pcd_bag_path.is_regular_file() ||\n      pcd_bag_path.extension() != \".bag\") {\n    std::cout << \"missing pcd_rosbag_file: \" << param_.pcd_rosbag << std::endl;\n    return false;\n  }\n  boost::filesystem::path pose_bag_path(param_.pose_rosbag);\n  if (!pose_bag_path.exists() || !pose_bag_path.is_regular_file() ||\n      pose_bag_path.extension() != \".bag\") {\n    std::cout << \"missing pose_rosbag_file: \" << param_.pose_rosbag << std::endl;\n    return false;\n  }\n\n  // load lidar pose\n  if (!loadLidarPose(param_.pose_rosbag, param_.pose_topic)) {\n    std::cout << \"failed to load lidar pose with topic: \" << param_.pose_topic << std::endl;\n    return false;\n  }\n\n  if (!param_.existing_ndt_map.empty() && !loadNdtMap()) {\n    std::cout << \"failed to load offline ndt map: \" << param_.existing_ndt_map << std::endl;\n    return false;\n  }\n\n  return true;\n}\n\nvoid NdtMapBuilder::buildNdtMap(const std::string& output_folder) {\n  rosbag::Bag bag;\n  bag.open(param_.pcd_rosbag);\n  std::vector<std::string> topics(1, param_.pcd_rosbag);\n  rosbag::View view(bag, rosbag::TopicQuery(topics));\n  for (const rosbag::MessageInstance& m : view) {\n    // get pcd from message\n    std::unique_ptr<PointCloudXYZIRT> pcd;\n\n    // point cloud preprocess\n    pcdPreProcess(param_.type, pcd.get());\n\n    // add pcd to map\n  }\n\n  // ndt map postprocess\n  ndtPosetProcess(param_.type);\n\n  // save map to database\n  saveNdtMap(output_folder);\n}\n\nvoid NdtMapBuilder::pcdPreProcess(const MapType& type, PointCloudXYZIRT* pcd) {\n  switch (type) {\n    case COMMON_NDT:\n\n      break;\n\n    case FEATURE_NDT:\n\n      break;\n\n    case INTENSITY:\n\n      break;\n  }\n}\n\nvoid NdtMapBuilder::ndtPostProcess(const MapType& type) {\n  switch (type) {\n    case COMMON_NDT:\n\n      break;\n\n    case FEATURE_NDT:\n\n      break;\n\n    case INTENSITY:\n\n      break;\n  }\n}\n\nbool NdtMapBuilder::loadLidarPose(const std::string& rosbag_name, const std::string& pose_topic) {\n  rosbag::Bag bag;\n  bag.open(rosbag_name);\n  std::vector<std::string> topics(1, pose_topic);\n  rosbag::View view(bag, rosbag::TopicQuery(topics));\n  for (const rosbag::MessageInstance& m : view) {\n    // get pose from message\n    Time stamp = 0;\n    common::geometry::SE3 pose;\n\n    lidar_poses_[stamp] = pose;\n  }\n\n  bag.close();\n\n  return !lidar_poses_.empty();\n}\n\nbool NdtMapBuilder::loadNdtMap(const std::string& existing_map) { return true; }\n\nbool NdtMapBuilder::saveNdtMap(const std::string& output_folder) { return true; }\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/ndt_map_builder.cpp"
		}
	}
]
I0402 15:46:29.050822  5535 json_parser.cpp:18] 
[
	73,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/ndt_map_builder.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All rights reserved.\n// Authors: Yongjian Zhao (yongjian.zhao@allride.ai)\n\n#include <vector>\n\n#include <rosbag/bag.h>\n#include <rosbag/message_instance.h>\n#include <rosbag/view.h>\n#include <boost/filesystem.hpp>\n\n#include \"common/geometry/eigen_types.h\"\n#include \"common/geometry/se3.h\"\n#include \"ndt_map_builder.h\"\n\nbool NdtMapBuilder::initialize(const MappingParameter& param) {\n  param_ = param;\n\n  // check existence of rosbag file\n  boost::filesystem::path pcd_bag_path(param_.pcd_rosbag);\n  if (!pcd_bag_path.exists() || !pcd_bag_path.is_regular_file() ||\n      pcd_bag_path.extension() != \".bag\") {\n    std::cout << \"missing pcd_rosbag_file: \" << param_.pcd_rosbag << std::endl;\n    return false;\n  }\n  boost::filesystem::path pose_bag_path(param_.pose_rosbag);\n  if (!pose_bag_path.exists() || !pose_bag_path.is_regular_file() ||\n      pose_bag_path.extension() != \".bag\") {\n    std::cout << \"missing pose_rosbag_file: \" << param_.pose_rosbag << std::endl;\n    return false;\n  }\n\n  // load lidar pose\n  if (!loadLidarPose(param_.pose_rosbag, param_.pose_topic)) {\n    std::cout << \"failed to load lidar pose with topic: \" << param_.pose_topic << std::endl;\n    return false;\n  }\n\n  if (!param_.existing_ndt_map.empty() && !loadNdtMap()) {\n    std::cout << \"failed to load offline ndt map: \" << param_.existing_ndt_map << std::endl;\n    return false;\n  }\n\n  return true;\n}\n\nvoid NdtMapBuilder::buildNdtMap(const std::string& output_folder) {\n  rosbag::Bag bag;\n  bag.open(param_.pcd_rosbag);\n  std::vector<std::string> topics(1, param_.pcd_rosbag);\n  rosbag::View view(bag, rosbag::TopicQuery(topics));\n  for (const rosbag::MessageInstance& m : view) {\n    // get pcd from message\n    std::unique_ptr<PointCloudXYZIRT> pcd;\n\n    // point cloud preprocess\n    pcdPreProcess(param_.type, pcd.get());\n\n    // add pcd to map\n  }\n\n  // ndt map postprocess\n  ndtPosetProcess(param_.type);\n\n  // save map to database\n  saveNdtMap(output_folder);\n}\n\nvoid NdtMapBuilder::pcdPreProcess(const MapType& type, PointCloudXYZIRT* pcd) {\n  switch (type) {\n    case COMMON_NDT:\n\n      break;\n\n    case FEATURE_NDT:\n\n      break;\n\n    case INTENSITY:\n\n      break;\n  }\n}\n\nvoid NdtMapBuilder::ndtPostProcess(const MapType& type) {\n  switch (type) {\n    case COMMON_NDT:\n\n      break;\n\n    case FEATURE_NDT:\n\n      break;\n\n    case INTENSITY:\n\n      break;\n  }\n}\n\nbool NdtMapBuilder::loadLidarPose(const std::string& rosbag_name, const std::string& pose_topic) {\n  rosbag::Bag bag;\n  bag.open(rosbag_name);\n  std::vector<std::string> topics(1, pose_topic);\n  rosbag::View view(bag, rosbag::TopicQuery(topics));\n  for (const rosbag::MessageInstance& m : view) {\n    // get pose from message\n    Time stamp = 0;\n    common::geometry::SE3 pose;\n\n    lidar_poses_[stamp] = pose;\n  }\n\n  bag.close();\n\n  return !lidar_poses_.empty();\n}\n\nbool NdtMapBuilder::loadNdtMap(const std::string& existing_map) { return true; }\n\nbool NdtMapBuilder::saveNdtMap(const std::string& output_folder) { return true; }\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/ndt_map_builder.cpp"
		}
	}
]
I0402 15:46:29.095785  5535 json_parser.cpp:18] 
[
	74,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/ndt_map_builder.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All rights reserved.\n// Authors: Yongjian Zhao (yongjian.zhao@allride.ai)\n\n#include <vector>\n\n#include <rosbag/bag.h>\n#include <rosbag/message_instance.h>\n#include <rosbag/view.h>\n#include <boost/filesystem.hpp>\n\n#include \"common/geometry/eigen_types.h\"\n#include \"common/geometry/se3.h\"\n#include \"ndt_map_builder.h\"\n\nbool NdtMapBuilder::initialize(const MappingParameter& param) {\n  param_ = param;\n\n  // check existence of rosbag file\n  boost::filesystem::path pcd_bag_path(param_.pcd_rosbag);\n  if (!pcd_bag_path.exists() || !pcd_bag_path.is_regular_file() ||\n      pcd_bag_path.extension() != \".bag\") {\n    std::cout << \"missing pcd_rosbag_file: \" << param_.pcd_rosbag << std::endl;\n    return false;\n  }\n  boost::filesystem::path pose_bag_path(param_.pose_rosbag);\n  if (!pose_bag_path.exists() || !pose_bag_path.is_regular_file() ||\n      pose_bag_path.extension() != \".bag\") {\n    std::cout << \"missing pose_rosbag_file: \" << param_.pose_rosbag << std::endl;\n    return false;\n  }\n\n  // load lidar pose\n  if (!loadLidarPose(param_.pose_rosbag, param_.pose_topic)) {\n    std::cout << \"failed to load lidar pose with topic: \" << param_.pose_topic << std::endl;\n    return false;\n  }\n\n  if (!param_.existing_ndt_map.empty() && !loadNdtMap()) {\n    std::cout << \"failed to load offline ndt map: \" << param_.existing_ndt_map << std::endl;\n    return false;\n  }\n\n  return true;\n}\n\nvoid NdtMapBuilder::buildNdtMap(const std::string& output_folder) {\n  rosbag::Bag bag;\n  bag.open(param_.pcd_rosbag);\n  std::vector<std::string> topics(1, param_.pcd_rosbag);\n  rosbag::View view(bag, rosbag::TopicQuery(topics));\n  for (const rosbag::MessageInstance& m : view) {\n    // get pcd from message\n    std::unique_ptr<PointCloudXYZIRT> pcd;\n\n    // point cloud preprocess\n    pcdPreProcess(param_.type, pcd.get());\n\n    // add pcd to map\n  }\n\n  // ndt map postprocess\n  ndtPosetProcess(param_.type);\n\n  // save map to database\n  saveNdtMap(output_folder);\n}\n\nvoid NdtMapBuilder::pcdPreProcess(const MapType& type, PointCloudXYZIRT* pcd) {\n  switch (type) {\n    case COMMON_NDT:\n\n      break;\n\n    case FEATURE_NDT:\n\n      break;\n\n    case INTENSITY:\n\n      break;\n  }\n}\n\nvoid NdtMapBuilder::ndtPostProcess(const MapType& type) {\n  switch (type) {\n    case COMMON_NDT:\n\n      break;\n\n    case FEATURE_NDT:\n\n      break;\n\n    case INTENSITY:\n\n      break;\n  }\n}\n\nbool NdtMapBuilder::loadLidarPose(const std::string& rosbag_name, const std::string& pose_topic) {\n  rosbag::Bag bag;\n  bag.open(rosbag_name);\n  std::vector<std::string> topics(1, pose_topic);\n  rosbag::View view(bag, rosbag::TopicQuery(topics));\n  for (const rosbag::MessageInstance& m : view) {\n    // get pose from message\n    Time stamp = 0;\n    common::geometry::SE3 pose;\n\n    lidar_poses_[stamp] = pose;\n  }\n\n  bag.close();\n\n  return !lidar_poses_.empty();\n}\n\nbool NdtMapBuilder::loadNdtMap(const std::string& existing_map) { return true; }\n\nbool NdtMapBuilder::saveNdtMap(const std::string& output_folder) { return true; }\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/ndt_map_builder.cpp"
		}
	}
]
I0402 15:46:32.472448  5535 json_parser.cpp:18] 
[
	78,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_scope.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/eigen_types.h\"\n\nnamespace allride {\nnamespace mapping {\n\n/// @brief specify a three dimension region\nclass MapScope {\n public:\n  MapScope();\n  MapScope(Eigen::Vector3f center, float range);\n  MapScope(Eigen::Vector3f corner0, Eigen::Vector3f corner1);\n\n  const Eigen::Vector3f& getCornerMin() const;\n  const Eigen::Vector3f& getCornerMax() const;\n\n protected:\n  Eigen::Vector3f corner_min;\n  Eigen::Vector3f corner_max;\n};\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_scope.h"
		}
	}
]
I0402 15:46:32.490947  5535 json_parser.cpp:18] 
[
	79,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_scope.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/eigen_types.h\"\n\nnamespace allride {\nnamespace mapping {\n\n/// @brief specify a three dimension region\nclass MapScope {\n public:\n  MapScope();\n  MapScope(Eigen::Vector3f center, float range);\n  MapScope(Eigen::Vector3f corner0, Eigen::Vector3f corner1);\n\n  const Eigen::Vector3f& getCornerMin() const;\n  const Eigen::Vector3f& getCornerMax() const;\n\n protected:\n  Eigen::Vector3f corner_min;\n  Eigen::Vector3f corner_max;\n};\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_scope.h"
		}
	}
]
I0402 15:46:32.503357  5535 json_parser.cpp:18] 
[
	80,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_scope.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/eigen_types.h\"\n\nnamespace allride {\nnamespace mapping {\n\n/// @brief specify a three dimension region\nclass MapScope {\n public:\n  MapScope();\n  MapScope(Eigen::Vector3f center, float range);\n  MapScope(Eigen::Vector3f corner0, Eigen::Vector3f corner1);\n\n  const Eigen::Vector3f& getCornerMin() const;\n  const Eigen::Vector3f& getCornerMax() const;\n\n protected:\n  Eigen::Vector3f corner_min;\n  Eigen::Vector3f corner_max;\n};\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/map_scope.h"
		}
	}
]
I0402 15:46:32.519668  5535 json_parser.cpp:18] 
[
	81,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/ndt_map_builder.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All rights reserved.\n// Authors: Yongjian Zhao (yongjian.zhao@allride.ai)\n\n#include <vector>\n\n#include <rosbag/bag.h>\n#include <rosbag/message_instance.h>\n#include <rosbag/view.h>\n#include <boost/filesystem.hpp>\n\n#include \"common/geometry/eigen_types.h\"\n#include \"common/geometry/se3.h\"\n#include \"ndt_map_builder.h\"\n\nbool NdtMapBuilder::initialize(const MappingParameter& param) {\n  param_ = param;\n\n  // check existence of rosbag file\n  boost::filesystem::path pcd_bag_path(param_.pcd_rosbag);\n  if (!pcd_bag_path.exists() || !pcd_bag_path.is_regular_file() ||\n      pcd_bag_path.extension() != \".bag\") {\n    std::cout << \"missing pcd_rosbag_file: \" << param_.pcd_rosbag << std::endl;\n    return false;\n  }\n  boost::filesystem::path pose_bag_path(param_.pose_rosbag);\n  if (!pose_bag_path.exists() || !pose_bag_path.is_regular_file() ||\n      pose_bag_path.extension() != \".bag\") {\n    std::cout << \"missing pose_rosbag_file: \" << param_.pose_rosbag << std::endl;\n    return false;\n  }\n\n  // load lidar pose\n  if (!loadLidarPose(param_.pose_rosbag, param_.pose_topic)) {\n    std::cout << \"failed to load lidar pose with topic: \" << param_.pose_topic << std::endl;\n    return false;\n  }\n\n  if (!param_.existing_ndt_map.empty() && !loadNdtMap()) {\n    std::cout << \"failed to load offline ndt map: \" << param_.existing_ndt_map << std::endl;\n    return false;\n  }\n\n  return true;\n}\n\nvoid NdtMapBuilder::buildNdtMap(const std::string& output_folder) {\n  rosbag::Bag bag;\n  bag.open(param_.pcd_rosbag);\n  std::vector<std::string> topics(1, param_.pcd_rosbag);\n  rosbag::View view(bag, rosbag::TopicQuery(topics));\n  for (const rosbag::MessageInstance& m : view) {\n    // get pcd from message\n    std::unique_ptr<PointCloudXYZIRT> pcd;\n\n    // point cloud preprocess\n    pcdPreProcess(param_.type, pcd.get());\n\n    // add pcd to map\n  }\n\n  // ndt map postprocess\n  ndtPosetProcess(param_.type);\n\n  // save map to database\n  saveNdtMap(output_folder);\n}\n\nvoid NdtMapBuilder::pcdPreProcess(const MapType& type, PointCloudXYZIRT* pcd) {\n  switch (type) {\n    case COMMON_NDT:\n\n      break;\n\n    case FEATURE_NDT:\n\n      break;\n\n    case INTENSITY:\n\n      break;\n  }\n}\n\nvoid NdtMapBuilder::ndtPostProcess(const MapType& type) {\n  switch (type) {\n    case COMMON_NDT:\n\n      break;\n\n    case FEATURE_NDT:\n\n      break;\n\n    case INTENSITY:\n\n      break;\n  }\n}\n\nbool NdtMapBuilder::loadLidarPose(const std::string& rosbag_name, const std::string& pose_topic) {\n  rosbag::Bag bag;\n  bag.open(rosbag_name);\n  std::vector<std::string> topics(1, pose_topic);\n  rosbag::View view(bag, rosbag::TopicQuery(topics));\n  for (const rosbag::MessageInstance& m : view) {\n    // get pose from message\n    Time stamp = 0;\n    common::geometry::SE3 pose;\n\n    lidar_poses_[stamp] = pose;\n  }\n\n  bag.close();\n\n  return !lidar_poses_.empty();\n}\n\nbool NdtMapBuilder::loadNdtMap(const std::string& existing_map) { return true; }\n\nbool NdtMapBuilder::saveNdtMap(const std::string& output_folder) { return true; }\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/ndt_map_builder.cpp"
		}
	}
]
I0402 15:46:32.588470  5535 json_parser.cpp:18] 
[
	82,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/ndt_map_builder.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All rights reserved.\n// Authors: Yongjian Zhao (yongjian.zhao@allride.ai)\n\n#include <vector>\n\n#include <rosbag/bag.h>\n#include <rosbag/message_instance.h>\n#include <rosbag/view.h>\n#include <boost/filesystem.hpp>\n\n#include \"common/geometry/eigen_types.h\"\n#include \"common/geometry/se3.h\"\n#include \"ndt_map_builder.h\"\n\nbool NdtMapBuilder::initialize(const MappingParameter& param) {\n  param_ = param;\n\n  // check existence of rosbag file\n  boost::filesystem::path pcd_bag_path(param_.pcd_rosbag);\n  if (!pcd_bag_path.exists() || !pcd_bag_path.is_regular_file() ||\n      pcd_bag_path.extension() != \".bag\") {\n    std::cout << \"missing pcd_rosbag_file: \" << param_.pcd_rosbag << std::endl;\n    return false;\n  }\n  boost::filesystem::path pose_bag_path(param_.pose_rosbag);\n  if (!pose_bag_path.exists() || !pose_bag_path.is_regular_file() ||\n      pose_bag_path.extension() != \".bag\") {\n    std::cout << \"missing pose_rosbag_file: \" << param_.pose_rosbag << std::endl;\n    return false;\n  }\n\n  // load lidar pose\n  if (!loadLidarPose(param_.pose_rosbag, param_.pose_topic)) {\n    std::cout << \"failed to load lidar pose with topic: \" << param_.pose_topic << std::endl;\n    return false;\n  }\n\n  if (!param_.existing_ndt_map.empty() && !loadNdtMap()) {\n    std::cout << \"failed to load offline ndt map: \" << param_.existing_ndt_map << std::endl;\n    return false;\n  }\n\n  return true;\n}\n\nvoid NdtMapBuilder::buildNdtMap(const std::string& output_folder) {\n  rosbag::Bag bag;\n  bag.open(param_.pcd_rosbag);\n  std::vector<std::string> topics(1, param_.pcd_rosbag);\n  rosbag::View view(bag, rosbag::TopicQuery(topics));\n  for (const rosbag::MessageInstance& m : view) {\n    // get pcd from message\n    std::unique_ptr<PointCloudXYZIRT> pcd;\n\n    // point cloud preprocess\n    pcdPreProcess(param_.type, pcd.get());\n\n    // add pcd to map\n  }\n\n  // ndt map postprocess\n  ndtPosetProcess(param_.type);\n\n  // save map to database\n  saveNdtMap(output_folder);\n}\n\nvoid NdtMapBuilder::pcdPreProcess(const MapType& type, PointCloudXYZIRT* pcd) {\n  switch (type) {\n    case COMMON_NDT:\n\n      break;\n\n    case FEATURE_NDT:\n\n      break;\n\n    case INTENSITY:\n\n      break;\n  }\n}\n\nvoid NdtMapBuilder::ndtPostProcess(const MapType& type) {\n  switch (type) {\n    case COMMON_NDT:\n\n      break;\n\n    case FEATURE_NDT:\n\n      break;\n\n    case INTENSITY:\n\n      break;\n  }\n}\n\nbool NdtMapBuilder::loadLidarPose(const std::string& rosbag_name, const std::string& pose_topic) {\n  rosbag::Bag bag;\n  bag.open(rosbag_name);\n  std::vector<std::string> topics(1, pose_topic);\n  rosbag::View view(bag, rosbag::TopicQuery(topics));\n  for (const rosbag::MessageInstance& m : view) {\n    // get pose from message\n    Time stamp = 0;\n    common::geometry::SE3 pose;\n\n    lidar_poses_[stamp] = pose;\n  }\n\n  bag.close();\n\n  return !lidar_poses_.empty();\n}\n\nbool NdtMapBuilder::loadNdtMap(const std::string& existing_map) { return true; }\n\nbool NdtMapBuilder::saveNdtMap(const std::string& output_folder) { return true; }\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/ndt_map_builder.cpp"
		}
	}
]
I0402 15:46:37.733058  5535 json_parser.cpp:18] 
[
	83,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/ndt_map_builder.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All rights reserved.\n// Authors: Yongjian Zhao (yongjian.zhao@allride.ai)\n\n#include <vector>\n\n#include <rosbag/bag.h>\n#include <rosbag/message_instance.h>\n#include <rosbag/view.h>\n#include <boost/filesystem.hpp>\n\n#include \"common/geometry/eigen_types.h\"\n#include \"common/geometry/se3.h\"\n#include \"ndt_map_builder.h\"\n\nbool NdtMapBuilder::initialize(const MappingParameter& param) {\n  param_ = param;\n\n  // check existence of rosbag file\n  boost::filesystem::path pcd_bag_path(param_.pcd_rosbag);\n  if (!pcd_bag_path.exists() || !pcd_bag_path.is_regular_file() ||\n      pcd_bag_path.extension() != \".bag\") {\n    std::cout << \"missing pcd_rosbag_file: \" << param_.pcd_rosbag << std::endl;\n    return false;\n  }\n  boost::filesystem::path pose_bag_path(param_.pose_rosbag);\n  if (!pose_bag_path.exists() || !pose_bag_path.is_regular_file() ||\n      pose_bag_path.extension() != \".bag\") {\n    std::cout << \"missing pose_rosbag_file: \" << param_.pose_rosbag << std::endl;\n    return false;\n  }\n\n  // load lidar pose\n  if (!loadLidarPose(param_.pose_rosbag, param_.pose_topic)) {\n    std::cout << \"failed to load lidar pose with topic: \" << param_.pose_topic << std::endl;\n    return false;\n  }\n\n  if (!param_.existing_ndt_map.empty() && !loadNdtMap()) {\n    std::cout << \"failed to load offline ndt map: \" << param_.existing_ndt_map << std::endl;\n    return false;\n  }\n\n  return true;\n}\n\nvoid NdtMapBuilder::buildNdtMap(const std::string& output_folder) {\n  rosbag::Bag bag;\n  bag.open(param_.pcd_rosbag);\n  std::vector<std::string> topics(1, param_.pcd_rosbag);\n  rosbag::View view(bag, rosbag::TopicQuery(topics));\n  for (const rosbag::MessageInstance& m : view) {\n    // get pcd from message\n    std::unique_ptr<PointCloudXYZIRT> pcd;\n\n    // point cloud preprocess\n    pcdPreProcess(param_.type, pcd.get());\n\n    // add pcd to map\n  }\n\n  // ndt map postprocess\n  ndtPosetProcess(param_.type);\n\n  // save map to database\n  saveNdtMap(output_folder);\n}\n\nvoid NdtMapBuilder::pcdPreProcess(const MapType& type, PointCloudXYZIRT* pcd) {\n  switch (type) {\n    case COMMON_NDT:\n\n      break;\n\n    case FEATURE_NDT:\n\n      break;\n\n    case INTENSITY:\n\n      break;\n  }\n}\n\nvoid NdtMapBuilder::ndtPostProcess(const MapType& type) {\n  switch (type) {\n    case COMMON_NDT:\n\n      break;\n\n    case FEATURE_NDT:\n\n      break;\n\n    case INTENSITY:\n\n      break;\n  }\n}\n\nbool NdtMapBuilder::loadLidarPose(const std::string& rosbag_name, const std::string& pose_topic) {\n  rosbag::Bag bag;\n  bag.open(rosbag_name);\n  std::vector<std::string> topics(1, pose_topic);\n  rosbag::View view(bag, rosbag::TopicQuery(topics));\n  for (const rosbag::MessageInstance& m : view) {\n    // get pose from message\n    Time stamp = 0;\n    common::geometry::SE3 pose;\n\n    lidar_poses_[stamp] = pose;\n  }\n\n  bag.close();\n\n  return !lidar_poses_.empty();\n}\n\nbool NdtMapBuilder::loadNdtMap(const std::string& existing_map) { return true; }\n\nbool NdtMapBuilder::saveNdtMap(const std::string& output_folder) { return true; }\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/ndt_map_builder.cpp"
		}
	}
]
I0402 15:46:37.779165  5535 json_parser.cpp:18] 
[
	84,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/src/ndt_map_builder.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All rights reserved.\n// Authors: Yongjian Zhao (yongjian.zhao@allride.ai)\n\n#include <vector>\n\n#include <rosbag/bag.h>\n#include <rosbag/message_instance.h>\n#include <rosbag/view.h>\n#include <boost/filesystem.hpp>\n\n#include \"common/geometry/eigen_types.h\"\n#include \"common/geometry/se3.h\"\n#include \"ndt_map_builder.h\"\n\nbool NdtMapBuilder::initialize(const MappingParameter& param) {\n  param_ = param;\n\n  // check existence of rosbag file\n  boost::filesystem::path pcd_bag_path(param_.pcd_rosbag);\n  if (!pcd_bag_path.exists() || !pcd_bag_path.is_regular_file() ||\n      pcd_bag_path.extension() != \".bag\") {\n    std::cout << \"missing pcd_