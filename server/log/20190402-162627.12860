Log file created at: 2019/04/02 16:26:27
Running on machine: mr-pc
Log line format: [IWEF]mmdd hh:mm:ss.uuuuuu threadid file:line] msg
I0402 16:26:27.146486 12860 json_parser.cpp:18] 
[
	1,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\n#include \"glog/logging.h\"\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Parse failed\";\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Reparse failed\";\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n  \n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:26:28.546684 12860 json_parser.cpp:18] 
[
	2,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\n#include \"glog/logging.h\"\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Parse failed\";\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Reparse failed\";\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n\n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:26:28.569795 12860 json_parser.cpp:18] 
[
	3,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\n#include \"glog/logging.h\"\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Parse failed\";\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Reparse failed\";\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n\n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:26:28.589792 12860 json_parser.cpp:18] 
[
	4,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\n#include \"glog/logging.h\"\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Parse failed\";\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Reparse failed\";\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:29:41.074331 12860 json_parser.cpp:18] 
[
	5,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\n#include \"glog/logging.h\"\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Parse failed\";\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Reparse failed\";\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n  \n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:29:43.993397 12860 json_parser.cpp:18] 
[
	6,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\n#include \"glog/logging.h\"\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Parse failed\";\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Reparse failed\";\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  LOG()\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:29:44.031194 12860 json_parser.cpp:18] 
[
	7,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\n#include \"glog/logging.h\"\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Parse failed\";\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Reparse failed\";\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  LOG()\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:29:45.593271 12860 json_parser.cpp:18] 
[
	8,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\n#include \"glog/logging.h\"\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Parse failed\";\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Reparse failed\";\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  LOG(INFO)\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:29:45.616214 12860 json_parser.cpp:18] 
[
	9,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\n#include \"glog/logging.h\"\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Parse failed\";\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Reparse failed\";\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  LOG(INFO)\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:29:45.816670 12860 json_parser.cpp:18] 
[
	10,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\n#include \"glog/logging.h\"\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Parse failed\";\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Reparse failed\";\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  LOG(INFO\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:29:47.360505 12860 json_parser.cpp:18] 
[
	11,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\n#include \"glog/logging.h\"\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Parse failed\";\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Reparse failed\";\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  LOG(INFO\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:29:47.381211 12860 json_parser.cpp:18] 
[
	12,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\n#include \"glog/logging.h\"\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Parse failed\";\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Reparse failed\";\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  LOG(INFO\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:29:47.897179 12860 json_parser.cpp:18] 
[
	13,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\n#include \"glog/logging.h\"\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Parse failed\";\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Reparse failed\";\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  LOG(INFO\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:29:54.879614 12860 json_parser.cpp:18] 
[
	14,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\n#include \"glog/logging.h\"\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Parse failed\";\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Reparse failed\";\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  LOG(INFO)<<\"\"\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:29:54.965458 12860 json_parser.cpp:18] 
[
	15,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\n#include \"glog/logging.h\"\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Parse failed\";\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Reparse failed\";\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  LOG(INFO)<<\"\"\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:29:58.879132 12860 json_parser.cpp:18] 
[
	16,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\n#include \"glog/logging.h\"\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Parse failed\";\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Reparse failed\";\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  LOG(INFO)<<\"token number: \"\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:29:59.200206 12860 json_parser.cpp:18] 
[
	17,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\n#include \"glog/logging.h\"\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Parse failed\";\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Reparse failed\";\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  LOG(INFO)<<\"token number: \"\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:30:03.872715 12860 json_parser.cpp:18] 
[
	18,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\n#include \"glog/logging.h\"\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Parse failed\";\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Reparse failed\";\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  LOG(INFO)<<\"token number: \"<<num_tokens;\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:30:03.896737 12860 json_parser.cpp:18] 
[
	19,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\n#include \"glog/logging.h\"\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Parse failed\";\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Reparse failed\";\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  LOG(INFO)<<\"token number: \"<<num_tokens;\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n   