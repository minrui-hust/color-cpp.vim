Log file created at: 2019/04/02 16:31:37
Running on machine: mr-pc
Log line format: [IWEF]mmdd hh:mm:ss.uuuuuu threadid file:line] msg
I0402 16:31:37.685109 13364 json_parser.cpp:18] 
[
	1,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\n#include \"glog/logging.h\"\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Parse failed\";\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Reparse failed\";\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  LOG(INFO)<<\"token number: \"<<num_tokens;\n  \n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:31:38.580377 13412 TranslationUnit.cpp:182] token number: 1115
I0402 16:31:38.582623 13364 json_parser.cpp:18] 
[
	2,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\n#include \"glog/logging.h\"\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Parse failed\";\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Reparse failed\";\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  LOG(INFO)<<\"token number: \"<<num_tokens;\n\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:31:38.600265 13422 TranslationUnit.cpp:182] token number: 1115
I0402 16:32:02.661310 13364 json_parser.cpp:18] 
[
	5,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\n#include \"glog/logging.h\"\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Parse failed\";\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Reparse failed\";\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  LOG(INFO)<<\"token number: \"<<num_tokens;\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n      \n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:32:02.679966 13425 TranslationUnit.cpp:182] token number: 1115
I0402 16:32:04.747624 13364 json_parser.cpp:18] 
[
	6,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\n#include \"glog/logging.h\"\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Parse failed\";\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Reparse failed\";\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  LOG(INFO)<<\"token number: \"<<num_tokens;\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:32:04.777276 13431 TranslationUnit.cpp:182] token number: 1115
I0402 16:32:04.779664 13364 json_parser.cpp:18] 
[
	7,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\n#include \"glog/logging.h\"\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Parse failed\";\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Reparse failed\";\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  LOG(INFO)<<\"token number: \"<<num_tokens;\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:32:04.797271 13435 TranslationUnit.cpp:182] token number: 1115
I0402 16:32:04.799815 13364 json_parser.cpp:18] 
[
	8,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\n#include \"glog/logging.h\"\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Parse failed\";\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Reparse failed\";\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  LOG(INFO)<<\"token number: \"<<num_tokens;\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:32:04.817791 13440 TranslationUnit.cpp:182] token number: 1115
I0402 16:33:40.102156 13364 json_parser.cpp:18] 
[
	9,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\n#include \"glog/logging.h\"\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Parse failed\";\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Reparse failed\";\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  LOG(INFO)<<\"token number: \"<<num_tokens;\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n  LOG(INFO)<<\"token number: \"<<num_tokens;\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:33:40.121981 13452 TranslationUnit.cpp:182] token number: 1124
I0402 16:33:41.154348 13364 json_parser.cpp:18] 
[
	10,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\n#include \"glog/logging.h\"\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Parse failed\";\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Reparse failed\";\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  LOG(INFO)<<\"token number: \"<<num_tokens;\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n  LOG(INFO)<<\"token number: \"<<num_tokens;\n  \n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:33:41.173887 13456 TranslationUnit.cpp:182] token number: 1124
I0402 16:33:41.800873 13364 json_parser.cpp:18] 
[
	11,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\n#include \"glog/logging.h\"\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Parse failed\";\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Reparse failed\";\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  LOG(INFO)<<\"token number: \"<<num_tokens;\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n  LOG(INFO)<<\"token number: \"<<num_tokens;\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:33:41.819748 13462 TranslationUnit.cpp:182] token number: 1124
I0402 16:33:41.822178 13364 json_parser.cpp:18] 
[
	12,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\n#include \"glog/logging.h\"\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Parse failed\";\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Reparse failed\";\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  LOG(INFO)<<\"token number: \"<<num_tokens;\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n  LOG(INFO)<<\"token number: \"<<num_tokens;\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:33:41.848544 13466 TranslationUnit.cpp:182] token number: 1124
I0402 16:33:42.631013 13364 json_parser.cpp:18] 
[
	13,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\n#include \"glog/logging.h\"\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Parse failed\";\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Reparse failed\";\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  LOG(INFO)<<\"token number: \"<<num_tokens;\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    LOG(INFO)<<\"token number: \"<<num_tokens;\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:33:42.651024 13470 TranslationUnit.cpp:182] token number: 1124
I0402 16:33:46.246698 13364 json_parser.cpp:18] 
[
	14,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\n#include \"glog/logging.h\"\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Parse failed\";\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Reparse failed\";\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  LOG(INFO)<<\"token number: \"<<num_tokens;\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    LOG(INFO)<<\"token : \"<<num_tokens;\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:33:46.263942 13475 TranslationUnit.cpp:182] token number: 1124
I0402 16:33:46.781996 13364 json_parser.cpp:18] 
[
	15,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\n#include \"glog/logging.h\"\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Parse failed\";\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Reparse failed\";\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  LOG(INFO)<<\"token number: \"<<num_tokens;\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    LOG(INFO)<<\"token: \"<<num_tokens;\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:33:46.803158 13480 TranslationUnit.cpp:182] token number: 1124
I0402 16:34:00.198931 13364 json_parser.cpp:18] 
[
	16,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\n#include \"glog/logging.h\"\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Parse failed\";\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Reparse failed\";\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  LOG(INFO)<<\"token number: \"<<num_tokens;\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    LOG(INFO)<<\"token: \"<<;\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:34:00.216758 13487 TranslationUnit.cpp:182] token number: 1123
I0402 16:34:00.362360 13364 json_parser.cpp:18] 
[
	17,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\n#include \"glog/logging.h\"\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Parse failed\";\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Reparse failed\";\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  LOG(INFO)<<\"token number: \"<<num_tokens;\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    LOG(INFO)<<\"token: \"<<;\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:34:00.383008 13491 TranslationUnit.cpp:182] token number: 1123
I0402 16:34:02.886163 13364 json_parser.cpp:18] 
[
	18,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\n#include \"glog/logging.h\"\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Parse failed\";\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Reparse failed\";\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  LOG(INFO)<<\"token number: \"<<num_tokens;\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    LOG(INFO)<<\"token: \"<<text;\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:34:02.904505 13500 TranslationUnit.cpp:182] token number: 1124
I0402 16:34:02.907058 13364 json_parser.cpp:18] 
[
	19,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\n#include \"glog/logging.h\"\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Parse failed\";\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Reparse failed\";\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  LOG(INFO)<<\"token number: \"<<num_tokens;\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    LOG(INFO)<<\"token: \"<<text;\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:34:02.924582 13504 TranslationUnit.cpp:182] token number: 1124
I0402 16:34:10.087009 13364 json_parser.cpp:18] 
[
	20,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\n#include \"glog/logging.h\"\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Parse failed\";\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Reparse failed\";\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  LOG(INFO)<<\"token number: \"<<num_tokens;\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    LOG(INFO)<<\"token: \"<<text;\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    LOG(INFO)<<\"token: \"<<text;\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:34:10.107767 13508 TranslationUnit.cpp:182] token number: 1133
I0402 16:34:11.068585 13364 json_parser.cpp:18] 
[
	21,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\n#include \"glog/logging.h\"\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Parse failed\";\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Reparse failed\";\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  LOG(INFO)<<\"token number: \"<<num_tokens;\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    LOG(INFO)<<\"token: \"<<text;\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n      LOG(INFO)<<\"token: \"<<text;\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:34:11.086768 13515 TranslationUnit.cpp:182] token number: 1133
I0402 16:34:16.285451 13364 json_parser.cpp:18] 
[
	22,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\n#include \"glog/logging.h\"\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Parse failed\";\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Reparse failed\";\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  LOG(INFO)<<\"token number: \"<<num_tokens;\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    LOG(INFO)<<\"token: \"<<text;\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n      LOG(INFO)<<\"token \"<<text;\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:34:16.306141 13570 TranslationUnit.cpp:182] token number: 1133
I0402 16:34:17.734035 13364 json_parser.cpp:18] 
[
	23,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\n#include \"glog/logging.h\"\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Parse failed\";\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Reparse failed\";\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  LOG(INFO)<<\"token number: \"<<num_tokens;\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    LOG(INFO)<<\"token: \"<<text;\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n      LOG(INFO)<<\"\"<<text;\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:34:17.754686 13574 TranslationUnit.cpp:182] token number: 1133
I0402 16:34:17.863653 13364 json_parser.cpp:18] 
[
	24,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\n#include \"glog/logging.h\"\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Parse failed\";\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Reparse failed\";\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  LOG(INFO)<<\"token number: \"<<num_tokens;\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    LOG(INFO)<<\"token: \"<<text;\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n      LOG(INFO)<<\"\"<<text;\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:34:17.910535 13578 TranslationUnit.cpp:182] token number: 1133
I0402 16:34:23.767208 13364 json_parser.cpp:18] 
[
	25,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\n#include \"glog/logging.h\"\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Parse failed\";\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Reparse failed\";\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  LOG(INFO)<<\"token number: \"<<num_tokens;\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    LOG(INFO)<<\"token: \"<<text;\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n      LOG(INFO)<<\"Add highlith\"<<text;\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:34:23.785455 13581 TranslationUnit.cpp:182] token number: 1133
I0402 16:34:31.988171 13364 json_parser.cpp:18] 
[
	26,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\n#include \"glog/logging.h\"\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Parse failed\";\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Reparse failed\";\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  LOG(INFO)<<\"token number: \"<<num_tokens;\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    LOG(INFO)<<\"token: \"<<text;\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n      LOG(INFO)<<\"Add highlih\"<<text;\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:34:32.010479 13585 TranslationUnit.cpp:182] token number: 1133
I0402 16:34:32.145630 13364 json_parser.cpp:18] 
[
	27,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\n#include \"glog/logging.h\"\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Parse failed\";\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Reparse failed\";\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  LOG(INFO)<<\"token number: \"<<num_tokens;\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    LOG(INFO)<<\"token: \"<<text;\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n      LOG(INFO)<<\"Add highli\"<<text;\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:34:32.167223 13589 TranslationUnit.cpp:182] token number: 1133
I0402 16:34:32.254415 13364 json_parser.cpp:18] 
[
	28,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\n#include \"glog/logging.h\"\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Parse failed\";\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Reparse failed\";\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  LOG(INFO)<<\"token number: \"<<num_tokens;\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    LOG(INFO)<<\"token: \"<<text;\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n      LOG(INFO)<<\"Add highli\"<<text;\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:34:32.287901 13593 TranslationUnit.cpp:182] token number: 1133
I0402 16:34:33.613356 13364 json_parser.cpp:18] 
[
	29,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\n#include \"glog/logging.h\"\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Parse failed\";\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Reparse failed\";\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  LOG(INFO)<<\"token number: \"<<num_tokens;\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    LOG(INFO)<<\"token: \"<<text;\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n      LOG(INFO)<<\"Add highlight\"<<text;\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:34:33.631835 13596 TranslationUnit.cpp:182] token number: 1133
I0402 16:34:33.634286 13364 json_parser.cpp:18] 
[
	30,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\n#include \"glog/logging.h\"\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Parse failed\";\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Reparse failed\";\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  LOG(INFO)<<\"token number: \"<<num_tokens;\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    LOG(INFO)<<\"token: \"<<text;\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n      LOG(INFO)<<\"Add highlight\"<<text;\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:34:33.652024 13600 TranslationUnit.cpp:182] token number: 1133
I0402 16:34:34.264191 13364 json_parser.cpp:18] 
[
	31,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\n#include \"glog/logging.h\"\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Parse failed\";\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Reparse failed\";\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  LOG(INFO)<<\"token number: \"<<num_tokens;\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    LOG(INFO)<<\"token: \"<<text;\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n      LOG(INFO)<<\"Add highlight\"<<text;\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:34:34.285321 13603 TranslationUnit.cpp:182] token number: 1133
I0402 16:34:35.526533 13364 json_parser.cpp:18] 
[
	32,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\n#include \"glog/logging.h\"\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Parse failed\";\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Reparse failed\";\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  LOG(INFO)<<\"token number: \"<<num_tokens;\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    LOG(INFO)<<\"token: \"<<text;\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n      LOG(INFO)<<\"Add highlight: \"<<text;\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:34:35.547163 13606 TranslationUnit.cpp:182] token number: 1133
I0402 16:34:43.308647 13364 json_parser.cpp:18] 
[
	33,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\n#include \"glog/logging.h\"\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Parse failed\";\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Reparse failed\";\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  LOG(INFO)<<\"token number: \"<<num_tokens;\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    LOG(INFO)<<\"Token: \"<<text;\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n      LOG(INFO)<<\"Add highlight: \"<<text;\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
