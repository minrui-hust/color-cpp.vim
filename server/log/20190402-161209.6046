Log file created at: 2019/04/02 16:12:09
Running on machine: mr-pc
Log line format: [IWEF]mmdd hh:mm:ss.uuuuuu threadid file:line] msg
I0402 16:12:09.038404  6046 json_parser.cpp:18] 
[
	1,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/syntax_analyzer.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "#include \"syntax_analyzer.h\"\n#include <future>\n#include <iostream>\n#include <unistd.h>\n#include \"glog/logging.h\"\n\nSyntaxAnalyzer::SyntaxAnalyzer() {\n  Json::StreamWriterBuilder builer;\n  writer_ = std::unique_ptr<Json::StreamWriter>(builer.newStreamWriter());\n  clang_analyzer_ = std::make_unique<ClangAnalyzer>();\n}\n\nvoid SyntaxAnalyzer::processRequest(const Json::Value &request) {\n  std::string translation_unit_name = request[1][\"filename\"].asString();\n\n  UnsavedFile unsaved;\n  unsaved.filename_ = request[1][\"unsaved\"][\"filename\"].asString();\n  unsaved.contents_ = request[1][\"unsaved\"][\"content\"].asString();\n  unsaved.length_ = unsaved.contents_.size();\n  std::vector<UnsavedFile> unsaved_files{unsaved};\n\n  std::vector<std::string> flags;\n  for (auto const &flag : request[1][\"flags\"]) {\n    flags.emplace_back(flag.asString());\n  }\n\n  std::async(std::launch::async, [&]() {\n    auto highlights = clang_analyzer_->UpdateTranslationUnit(\n        translation_unit_name, unsaved_files, flags);\n\n    //LOG(INFO)<<\"Total highlight: \"<<highlights.size();\n\n    Json::Value response;\n    response[0] = 0;\n    response[1][\"filename\"] = translation_unit_name;\n    for (const auto &highlight : highlights) {\n      Json::Value value;\n      value[\"text\"] = highlight.text_;\n      value[\"type\"] = highlight.type_;\n      value[\"line\"] = highlight.line_;\n      value[\"col\"] = highlight.col_;\n      response[1][\"highlights\"].append(value);\n      //LOG(INFO)<<highlight.text_<<\" \"<<highlight.type_<<\" \"<<highlight.line_<<\" \"<<highlight.col_;\n    }\n\n    std::ostringstream oss;\n    writer_->write(response, &oss);\n    std::string rsp_str = oss.str();\n\n    //LOG(INFO)<<\"\\n\"<<rsp_str;\n\n    stdout_lock_.lock();\n    write(STDOUT_FILENO, rsp_str.c_str(), rsp_str.size());\n    stdout_lock_.unlock();\n  });\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/syntax_analyzer.cpp"
		}
	}
]
I0402 16:12:09.592516  6046 json_parser.cpp:18] 
[
	2,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/syntax_analyzer.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "#include \"syntax_analyzer.h\"\n#include <future>\n#include <iostream>\n#include <unistd.h>\n#include \"glog/logging.h\"\n\nSyntaxAnalyzer::SyntaxAnalyzer() {\n  Json::StreamWriterBuilder builer;\n  writer_ = std::unique_ptr<Json::StreamWriter>(builer.newStreamWriter());\n  clang_analyzer_ = std::make_unique<ClangAnalyzer>();\n}\n\nvoid SyntaxAnalyzer::processRequest(const Json::Value &request) {\n  std::string translation_unit_name = request[1][\"filename\"].asString();\n\n  UnsavedFile unsaved;\n  unsaved.filename_ = request[1][\"unsaved\"][\"filename\"].asString();\n  unsaved.contents_ = request[1][\"unsaved\"][\"content\"].asString();\n  unsaved.length_ = unsaved.contents_.size();\n  std::vector<UnsavedFile> unsaved_files{unsaved};\n\n  std::vector<std::string> flags;\n  for (auto const &flag : request[1][\"flags\"]) {\n    flags.emplace_back(flag.asString());\n  }\n\n  std::async(std::launch::async, [&]() {\n    auto highlights = clang_analyzer_->UpdateTranslationUnit(\n        translation_unit_name, unsaved_files, flags);\n\n    //LOG(INFO)<<\"Total highlight: \"<<highlights.size();\n\n    Json::Value response;\n    response[0] = 0;\n    response[1][\"filename\"] = translation_unit_name;\n    for (const auto &highlight : highlights) {\n      Json::Value value;\n      value[\"text\"] = highlight.text_;\n      value[\"type\"] = highlight.type_;\n      value[\"line\"] = highlight.line_;\n      value[\"col\"] = highlight.col_;\n      response[1][\"highlights\"].append(value);\n      //LOG(INFO)<<highlight.text_<<\" \"<<highlight.type_<<\" \"<<highlight.line_<<\" \"<<highlight.col_;\n    }\n\n    std::ostringstream oss;\n    writer_->write(response, &oss);\n    std::string rsp_str = oss.str();\n\n    //LOG(INFO)<<\"\\n\"<<rsp_str;\n\n    stdout_lock_.lock();\n    write(STDOUT_FILENO, rsp_str.c_str(), rsp_str.size());\n    stdout_lock_.unlock();\n  });\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/syntax_analyzer.cpp"
		}
	}
]
I0402 16:13:16.625177  6046 json_parser.cpp:18] 
[
	3,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/syntax_analyzer.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "#include \"syntax_analyzer.h\"\n#include <future>\n#include <iostream>\n#include <unistd.h>\n#include \"glog/logging.h\"\n\nSyntaxAnalyzer::SyntaxAnalyzer() {\n  Json::StreamWriterBuilder builer;\n  writer_ = std::unique_ptr<Json::StreamWriter>(builer.newStreamWriter());\n  clang_analyzer_ = std::make_unique<ClangAnalyzer>();\n}\n\nvoid SyntaxAnalyzer::processRequest(const Json::Value &request) {\n  std::string translation_unit_name = request[1][\"filename\"].asString();\n\n  UnsavedFile unsaved;\n  unsaved.filename_ = request[1][\"unsaved\"][\"filename\"].asString();\n  unsaved.contents_ = request[1][\"unsaved\"][\"content\"].asString();\n  unsaved.length_ = unsaved.contents_.size();\n  std::vector<UnsavedFile> unsaved_files{unsaved};\n\n  std::vector<std::string> flags;\n  for (auto const &flag : request[1][\"flags\"]) {\n    flags.emplace_back(flag.asString());\n  }\n\n  std::async(std::launch::async, [&]() {\n    auto highlights = clang_analyzer_->UpdateTranslationUnit(\n        translation_unit_name, unsaved_files, flags);\n\n    //LOG(INFO)<<\"Total highlight: \"<<highlights.size();\n\n    Json::Value response;\n    response[0] = 0;\n    response[1][\"filename\"] = translation_unit_name;\n    for (const auto &highlight : highlights) {\n      Json::Value value;\n      value[\"text\"] = highlight.text_;\n      value[\"type\"] = highlight.type_;\n      value[\"line\"] = highlight.line_;\n      value[\"col\"] = highlight.col_;\n      response[1][\"highlights\"].append(value);\n      //LOG(INFO)<<highlight.text_<<\" \"<<highlight.type_<<\" \"<<highlight.line_<<\" \"<<highlight.col_;\n    }\n\n    std::ostringstream oss;\n    writer_->write(response, &oss);\n    std::string rsp_str = oss.str();\n\n    //LOG(INFO)<<\"\\n\"<<rsp_str;\n\n    stdout_lock_.lock();\n    write(STDOUT_FILENO, rsp_str.c_str(), rsp_str.size());\n    stdout_lock_.unlock();\n  });\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/syntax_analyzer.cpp"
		}
	}
]
I0402 16:13:16.646701  6046 json_parser.cpp:18] 
[
	4,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/syntax_analyzer.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "#include \"syntax_analyzer.h\"\n#include <future>\n#include <iostream>\n#include <unistd.h>\n#include \"glog/logging.h\"\n\nSyntaxAnalyzer::SyntaxAnalyzer() {\n  Json::StreamWriterBuilder builer;\n  writer_ = std::unique_ptr<Json::StreamWriter>(builer.newStreamWriter());\n  clang_analyzer_ = std::make_unique<ClangAnalyzer>();\n}\n\nvoid SyntaxAnalyzer::processRequest(const Json::Value &request) {\n  std::string translation_unit_name = request[1][\"filename\"].asString();\n\n  UnsavedFile unsaved;\n  unsaved.filename_ = request[1][\"unsaved\"][\"filename\"].asString();\n  unsaved.contents_ = request[1][\"unsaved\"][\"content\"].asString();\n  unsaved.length_ = unsaved.contents_.size();\n  std::vector<UnsavedFile> unsaved_files{unsaved};\n\n  std::vector<std::string> flags;\n  for (auto const &flag : request[1][\"flags\"]) {\n    flags.emplace_back(flag.asString());\n  }\n\n  std::async(std::launch::async, [&]() {\n    auto highlights = clang_analyzer_->UpdateTranslationUnit(\n        translation_unit_name, unsaved_files, flags);\n\n    //LOG(INFO)<<\"Total highlight: \"<<highlights.size();\n\n    Json::Value response;\n    response[0] = 0;\n    response[1][\"filename\"] = translation_unit_name;\n    for (const auto &highlight : highlights) {\n      Json::Value value;\n      value[\"text\"] = highlight.text_;\n      value[\"type\"] = highlight.type_;\n      value[\"line\"] = highlight.line_;\n      value[\"col\"] = highlight.col_;\n      response[1][\"highlights\"].append(value);\n      //LOG(INFO)<<highlight.text_<<\" \"<<highlight.type_<<\" \"<<highlight.line_<<\" \"<<highlight.col_;\n    }\n\n    std::ostringstream oss;\n    writer_->write(response, &oss);\n    std::string rsp_str = oss.str();\n\n    //LOG(INFO)<<\"\\n\"<<rsp_str;\n\n    stdout_lock_.lock();\n    write(STDOUT_FILENO, rsp_str.c_str(), rsp_str.size());\n    stdout_lock_.unlock();\n  });\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/syntax_analyzer.cpp"
		}
	}
]
I0402 16:13:16.665766  6046 json_parser.cpp:18] 
[
	5,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/syntax_analyzer.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "#include \"syntax_analyzer.h\"\n#include <future>\n#include <iostream>\n#include <unistd.h>\n#include \"glog/logging.h\"\n\nSyntaxAnalyzer::SyntaxAnalyzer() {\n  Json::StreamWriterBuilder builer;\n  writer_ = std::unique_ptr<Json::StreamWriter>(builer.newStreamWriter());\n  clang_analyzer_ = std::make_unique<ClangAnalyzer>();\n}\n\nvoid SyntaxAnalyzer::processRequest(const Json::Value &request) {\n  std::string translation_unit_name = request[1][\"filename\"].asString();\n\n  UnsavedFile unsaved;\n  unsaved.filename_ = request[1][\"unsaved\"][\"filename\"].asString();\n  unsaved.contents_ = request[1][\"unsaved\"][\"content\"].asString();\n  unsaved.length_ = unsaved.contents_.size();\n  std::vector<UnsavedFile> unsaved_files{unsaved};\n\n  std::vector<std::string> flags;\n  for (auto const &flag : request[1][\"flags\"]) {\n    flags.emplace_back(flag.asString());\n  }\n\n  std::async(std::launch::async, [&]() {\n    auto highlights = clang_analyzer_->UpdateTranslationUnit(\n        translation_unit_name, unsaved_files, flags);\n\n    //LOG(INFO)<<\"Total highlight: \"<<highlights.size();\n\n    Json::Value response;\n    response[0] = 0;\n    response[1][\"filename\"] = translation_unit_name;\n    for (const auto &highlight : highlights) {\n      Json::Value value;\n      value[\"text\"] = highlight.text_;\n      value[\"type\"] = highlight.type_;\n      value[\"line\"] = highlight.line_;\n      value[\"col\"] = highlight.col_;\n      response[1][\"highlights\"].append(value);\n      //LOG(INFO)<<highlight.text_<<\" \"<<highlight.type_<<\" \"<<highlight.line_<<\" \"<<highlight.col_;\n    }\n\n    std::ostringstream oss;\n    writer_->write(response, &oss);\n    std::string rsp_str = oss.str();\n\n    //LOG(INFO)<<\"\\n\"<<rsp_str;\n\n    stdout_lock_.lock();\n    write(STDOUT_FILENO, rsp_str.c_str(), rsp_str.size());\n    stdout_lock_.unlock();\n  });\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/syntax_analyzer.cpp"
		}
	}
]
I0402 16:13:16.752456  6046 json_parser.cpp:18] 
[
	6,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestParsedInfo();\n}\n\nvoid TranslationUnit::UpdateLatestParsedInfo() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:13:17.554042  6046 json_parser.cpp:18] 
[
	7,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestParsedInfo();\n}\n\nvoid TranslationUnit::UpdateLatestParsedInfo() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:14:18.959882  6046 json_parser.cpp:18] 
[
	8,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestParsedInfo();\n}\n\nvoid TranslationUnit::UpdateLatestParsedInfo() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:14:18.977540  6046 json_parser.cpp:18] 
[
	9,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestParsedInfo();\n}\n\nvoid TranslationUnit::UpdateLatestParsedInfo() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:14:48.470880  6046 json_parser.cpp:18] 
[
	10,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestParsedInfo();\n}\n\nvoid TranslationUnit::UpdateLatestParsedInfo() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:14:50.383791  6046 json_parser.cpp:18] 
[
	11,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestParsedInfo();\n}\n\nvoid TranslationUnit::UpdateLatestParsedInfo() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:14:50.403648  6046 json_parser.cpp:18] 
[
	12,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestParsedInfo();\n}\n\nvoid TranslationUnit::UpdateLatestParsedInfo() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:15:01.831615  6046 json_parser.cpp:18] 
[
	13,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestParsedInfo();\n}\n\nvoid TranslationUnit::UpdateLatestParsedInfo() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:15:01.909476  6046 json_parser.cpp:18] 
[
	14,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestParsedInfo();\n}\n\nvoid TranslationUnit::UpdateLatestParsedInfo() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:15:01.984905  6046 json_parser.cpp:18] 
[
	17,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011, 2012 Google Inc.\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#ifndef TRANSLATIONUNIT_H_XQ7I6SVA\n#define TRANSLATIONUNIT_H_XQ7I6SVA\n\n#include \"UnsavedFile.h\"\n#include \"Location.h\"\n#include \"Highlight.h\"\n\n#include <clang-c/Index.h>\n\n#include <memory>\n#include <mutex>\n#include <string>\n#include <vector>\n\nstruct CompletionData;\n\nclass TranslationUnit {\npublic:\n\n  // This constructor creates an invalid, sentinel TU. All of it's methods\n  // return empty vectors, and IsCurrentlyUpdating always returns true so that\n  // no callers try to rely on the invalid TU.\n  TranslationUnit();\n  TranslationUnit( const TranslationUnit& ) = delete;\n  TranslationUnit& operator=( const TranslationUnit& ) = delete;\n\n  TranslationUnit(\n    const std::string &filename,\n    const std::vector< UnsavedFile > &unsaved_files,\n    const std::vector< std::string > &flags,\n    CXIndex clang_index );\n\n  ~TranslationUnit();\n\n  void Destroy();\n\n  bool IsCurrentlyUpdating() const;\n\n  std::vector<Highlight> Reparse(\n    const std::vector< UnsavedFile > &unsaved_files);\n\nprivate:\n  void Reparse( std::vector< CXUnsavedFile > &unsaved_files );\n\n  void Reparse( std::vector< CXUnsavedFile > &unsaved_files,\n                size_t parse_options );\n\n  void UpdateLatestParsedInfo();\n\n  CXSourceRange SourceRange();\n\n  std::string filename_;\n\n  std::mutex highlights_mutex_;\n  std::vector<Highlight> latest_highlights_;\n\n  mutable std::mutex clang_access_mutex_;\n  CXTranslationUnit clang_translation_unit_;\n};\n\n#endif /* end of include guard: TRANSLATIONUNIT_H_XQ7I6SVA */\n\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.h"
		}
	}
]
I0402 16:15:08.102141  6046 json_parser.cpp:18] 
[
	18,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011, 2012 Google Inc.\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#ifndef TRANSLATIONUNIT_H_XQ7I6SVA\n#define TRANSLATIONUNIT_H_XQ7I6SVA\n\n#include \"UnsavedFile.h\"\n#include \"Location.h\"\n#include \"Highlight.h\"\n\n#include <clang-c/Index.h>\n\n#include <memory>\n#include <mutex>\n#include <string>\n#include <vector>\n\nstruct CompletionData;\n\nclass TranslationUnit {\npublic:\n\n  // This constructor creates an invalid, sentinel TU. All of it's methods\n  // return empty vectors, and IsCurrentlyUpdating always returns true so that\n  // no callers try to rely on the invalid TU.\n  TranslationUnit();\n  TranslationUnit( const TranslationUnit& ) = delete;\n  TranslationUnit& operator=( const TranslationUnit& ) = delete;\n\n  TranslationUnit(\n    const std::string &filename,\n    const std::vector< UnsavedFile > &unsaved_files,\n    const std::vector< std::string > &flags,\n    CXIndex clang_index );\n\n  ~TranslationUnit();\n\n  void Destroy();\n\n  bool IsCurrentlyUpdating() const;\n\n  std::vector<Highlight> Reparse(\n    const std::vector< UnsavedFile > &unsaved_files);\n\nprivate:\n  void Reparse( std::vector< CXUnsavedFile > &unsaved_files );\n\n  void Reparse( std::vector< CXUnsavedFile > &unsaved_files,\n                size_t parse_options );\n\n  void UpdateLatest();\n\n  CXSourceRange SourceRange();\n\n  std::string filename_;\n\n  std::mutex highlights_mutex_;\n  std::vector<Highlight> latest_highlights_;\n\n  mutable std::mutex clang_access_mutex_;\n  CXTranslationUnit clang_translation_unit_;\n};\n\n#endif /* end of include guard: TRANSLATIONUNIT_H_XQ7I6SVA */\n\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.h"
		}
	}
]
I0402 16:15:08.264838  6046 json_parser.cpp:18] 
[
	19,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011, 2012 Google Inc.\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#ifndef TRANSLATIONUNIT_H_XQ7I6SVA\n#define TRANSLATIONUNIT_H_XQ7I6SVA\n\n#include \"UnsavedFile.h\"\n#include \"Location.h\"\n#include \"Highlight.h\"\n\n#include <clang-c/Index.h>\n\n#include <memory>\n#include <mutex>\n#include <string>\n#include <vector>\n\nstruct CompletionData;\n\nclass TranslationUnit {\npublic:\n\n  // This constructor creates an invalid, sentinel TU. All of it's methods\n  // return empty vectors, and IsCurrentlyUpdating always returns true so that\n  // no callers try to rely on the invalid TU.\n  TranslationUnit();\n  TranslationUnit( const TranslationUnit& ) = delete;\n  TranslationUnit& operator=( const TranslationUnit& ) = delete;\n\n  TranslationUnit(\n    const std::string &filename,\n    const std::vector< UnsavedFile > &unsaved_files,\n    const std::vector< std::string > &flags,\n    CXIndex clang_index );\n\n  ~TranslationUnit();\n\n  void Destroy();\n\n  bool IsCurrentlyUpdating() const;\n\n  std::vector<Highlight> Reparse(\n    const std::vector< UnsavedFile > &unsaved_files);\n\nprivate:\n  void Reparse( std::vector< CXUnsavedFile > &unsaved_files );\n\n  void Reparse( std::vector< CXUnsavedFile > &unsaved_files,\n                size_t parse_options );\n\n  void UpdateLatest();\n\n  CXSourceRange SourceRange();\n\n  std::string filename_;\n\n  std::mutex highlights_mutex_;\n  std::vector<Highlight> latest_highlights_;\n\n  mutable std::mutex clang_access_mutex_;\n  CXTranslationUnit clang_translation_unit_;\n};\n\n#endif /* end of include guard: TRANSLATIONUNIT_H_XQ7I6SVA */\n\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.h"
		}
	}
]
I0402 16:15:12.767530  6046 json_parser.cpp:18] 
[
	20,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011, 2012 Google Inc.\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#ifndef TRANSLATIONUNIT_H_XQ7I6SVA\n#define TRANSLATIONUNIT_H_XQ7I6SVA\n\n#include \"UnsavedFile.h\"\n#include \"Location.h\"\n#include \"Highlight.h\"\n\n#include <clang-c/Index.h>\n\n#include <memory>\n#include <mutex>\n#include <string>\n#include <vector>\n\nstruct CompletionData;\n\nclass TranslationUnit {\npublic:\n\n  // This constructor creates an invalid, sentinel TU. All of it's methods\n  // return empty vectors, and IsCurrentlyUpdating always returns true so that\n  // no callers try to rely on the invalid TU.\n  TranslationUnit();\n  TranslationUnit( const TranslationUnit& ) = delete;\n  TranslationUnit& operator=( const TranslationUnit& ) = delete;\n\n  TranslationUnit(\n    const std::string &filename,\n    const std::vector< UnsavedFile > &unsaved_files,\n    const std::vector< std::string > &flags,\n    CXIndex clang_index );\n\n  ~TranslationUnit();\n\n  void Destroy();\n\n  bool IsCurrentlyUpdating() const;\n\n  std::vector<Highlight> Reparse(\n    const std::vector< UnsavedFile > &unsaved_files);\n\nprivate:\n  void Reparse( std::vector< CXUnsavedFile > &unsaved_files );\n\n  void Reparse( std::vector< CXUnsavedFile > &unsaved_files,\n                size_t parse_options );\n\n  void UpdateLatestHighlights();\n\n  CXSourceRange SourceRange();\n\n  std::string filename_;\n\n  std::mutex highlights_mutex_;\n  std::vector<Highlight> latest_highlights_;\n\n  mutable std::mutex clang_access_mutex_;\n  CXTranslationUnit clang_translation_unit_;\n};\n\n#endif /* end of include guard: TRANSLATIONUNIT_H_XQ7I6SVA */\n\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.h"
		}
	}
]
I0402 16:15:15.902952  6046 json_parser.cpp:18] 
[
	21,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011, 2012 Google Inc.\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#ifndef TRANSLATIONUNIT_H_XQ7I6SVA\n#define TRANSLATIONUNIT_H_XQ7I6SVA\n\n#include \"UnsavedFile.h\"\n#include \"Location.h\"\n#include \"Highlight.h\"\n\n#include <clang-c/Index.h>\n\n#include <memory>\n#include <mutex>\n#include <string>\n#include <vector>\n\nstruct CompletionData;\n\nclass TranslationUnit {\npublic:\n\n  // This constructor creates an invalid, sentinel TU. All of it's methods\n  // return empty vectors, and IsCurrentlyUpdating always returns true so that\n  // no callers try to rely on the invalid TU.\n  TranslationUnit();\n  TranslationUnit( const TranslationUnit& ) = delete;\n  TranslationUnit& operator=( const TranslationUnit& ) = delete;\n\n  TranslationUnit(\n    const std::string &filename,\n    const std::vector< UnsavedFile > &unsaved_files,\n    const std::vector< std::string > &flags,\n    CXIndex clang_index );\n\n  ~TranslationUnit();\n\n  void Destroy();\n\n  bool IsCurrentlyUpdating() const;\n\n  std::vector<Highlight> Reparse(\n    const std::vector< UnsavedFile > &unsaved_files);\n\nprivate:\n  void Reparse( std::vector< CXUnsavedFile > &unsaved_files );\n\n  void Reparse( std::vector< CXUnsavedFile > &unsaved_files,\n                size_t parse_options );\n\n  void UpdateLatestHighlights();\n\n  CXSourceRange SourceRange();\n\n  std::string filename_;\n\n  std::mutex highlights_mutex_;\n  std::vector<Highlight> latest_highlights_;\n\n  mutable std::mutex clang_access_mutex_;\n  CXTranslationUnit clang_translation_unit_;\n};\n\n#endif /* end of include guard: TRANSLATIONUNIT_H_XQ7I6SVA */\n\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.h"
		}
	}
]
I0402 16:15:15.915648  6046 json_parser.cpp:18] 
[
	22,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011, 2012 Google Inc.\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#ifndef TRANSLATIONUNIT_H_XQ7I6SVA\n#define TRANSLATIONUNIT_H_XQ7I6SVA\n\n#include \"UnsavedFile.h\"\n#include \"Location.h\"\n#include \"Highlight.h\"\n\n#include <clang-c/Index.h>\n\n#include <memory>\n#include <mutex>\n#include <string>\n#include <vector>\n\nstruct CompletionData;\n\nclass TranslationUnit {\npublic:\n\n  // This constructor creates an invalid, sentinel TU. All of it's methods\n  // return empty vectors, and IsCurrentlyUpdating always returns true so that\n  // no callers try to rely on the invalid TU.\n  TranslationUnit();\n  TranslationUnit( const TranslationUnit& ) = delete;\n  TranslationUnit& operator=( const TranslationUnit& ) = delete;\n\n  TranslationUnit(\n    const std::string &filename,\n    const std::vector< UnsavedFile > &unsaved_files,\n    const std::vector< std::string > &flags,\n    CXIndex clang_index );\n\n  ~TranslationUnit();\n\n  void Destroy();\n\n  bool IsCurrentlyUpdating() const;\n\n  std::vector<Highlight> Reparse(\n    const std::vector< UnsavedFile > &unsaved_files);\n\nprivate:\n  void Reparse( std::vector< CXUnsavedFile > &unsaved_files );\n\n  void Reparse( std::vector< CXUnsavedFile > &unsaved_files,\n                size_t parse_options );\n\n  void UpdateLatestHighlights();\n\n  CXSourceRange SourceRange();\n\n  std::string filename_;\n\n  std::mutex highlights_mutex_;\n  std::vector<Highlight> latest_highlights_;\n\n  mutable std::mutex clang_access_mutex_;\n  CXTranslationUnit clang_translation_unit_;\n};\n\n#endif /* end of include guard: TRANSLATIONUNIT_H_XQ7I6SVA */\n\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.h"
		}
	}
]
I0402 16:15:15.928082  6046 json_parser.cpp:18] 
[
	23,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011, 2012 Google Inc.\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#ifndef TRANSLATIONUNIT_H_XQ7I6SVA\n#define TRANSLATIONUNIT_H_XQ7I6SVA\n\n#include \"UnsavedFile.h\"\n#include \"Location.h\"\n#include \"Highlight.h\"\n\n#include <clang-c/Index.h>\n\n#include <memory>\n#include <mutex>\n#include <string>\n#include <vector>\n\nstruct CompletionData;\n\nclass TranslationUnit {\npublic:\n\n  // This constructor creates an invalid, sentinel TU. All of it's methods\n  // return empty vectors, and IsCurrentlyUpdating always returns true so that\n  // no callers try to rely on the invalid TU.\n  TranslationUnit();\n  TranslationUnit( const TranslationUnit& ) = delete;\n  TranslationUnit& operator=( const TranslationUnit& ) = delete;\n\n  TranslationUnit(\n    const std::string &filename,\n    const std::vector< UnsavedFile > &unsaved_files,\n    const std::vector< std::string > &flags,\n    CXIndex clang_index );\n\n  ~TranslationUnit();\n\n  void Destroy();\n\n  bool IsCurrentlyUpdating() const;\n\n  std::vector<Highlight> Reparse(\n    const std::vector< UnsavedFile > &unsaved_files);\n\nprivate:\n  void Reparse( std::vector< CXUnsavedFile > &unsaved_files );\n\n  void Reparse( std::vector< CXUnsavedFile > &unsaved_files,\n                size_t parse_options );\n\n  void UpdateLatestHighlights();\n\n  CXSourceRange SourceRange();\n\n  std::string filename_;\n\n  std::mutex highlights_mutex_;\n  std::vector<Highlight> latest_highlights_;\n\n  mutable std::mutex clang_access_mutex_;\n  CXTranslationUnit clang_translation_unit_;\n};\n\n#endif /* end of include guard: TRANSLATIONUNIT_H_XQ7I6SVA */\n\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.h"
		}
	}
]
I0402 16:15:15.944772  6046 json_parser.cpp:18] 
[
	24,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestParsedInfo();\n}\n\nvoid TranslationUnit::UpdateLatestParsedInfo() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:15:16.750433  6046 json_parser.cpp:18] 
[
	25,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestParsedInfo();\n}\n\nvoid TranslationUnit::UpdateLatestParsedInfo() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:15:18.850069  6046 json_parser.cpp:18] 
[
	26,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatest();\n}\n\nvoid TranslationUnit::UpdateLatestParsedInfo() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:15:18.919975  6046 json_parser.cpp:18] 
[
	27,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatest();\n}\n\nvoid TranslationUnit::UpdateLatestParsedInfo() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:15:21.050674  6046 json_parser.cpp:18] 
[
	28,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatestParsedInfo() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:15:21.078258  6046 json_parser.cpp:18] 
[
	29,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatestParsedInfo() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:15:23.529821  6046 json_parser.cpp:18] 
[
	30,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatest() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:15:23.612581  6046 json_parser.cpp:18] 
[
	31,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatest() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:15:24.482096  6046 json_parser.cpp:18] 
[
	32,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:15:24.564147  6046 json_parser.cpp:18] 
[
	33,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:16:31.218811  6046 json_parser.cpp:18] 
[
	34,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    \n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:16:32.105672  6046 json_parser.cpp:18] 
[
	35,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:16:32.126336  6046 json_parser.cpp:18] 
[
	36,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:16:32.535856  6046 json_parser.cpp:18] 
[
	37,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:16:38.114887  6046 json_parser.cpp:18] 
[
	38,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:16:40.897564  6046 json_parser.cpp:18] 
[
	39,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\n#include \"\"\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:16:41.672102  6046 json_parser.cpp:18] 
[
	40,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\n#include \"\"\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:16:46.906992  6046 json_parser.cpp:18] 
[
	41,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\n#include \"glog/logging.h\"\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:16:47.769980  6046 json_parser.cpp:18] 
[
	42,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\n#include \"glog/logging.h\"\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:16:52.274435  6046 json_parser.cpp:18] 
[
	43,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\n#include \"glog/logging.h\"\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    \n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:16:54.409714  6046 json_parser.cpp:18] 
[
	44,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\n#include \"glog/logging.h\"\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    LOG()\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:16:54.553777  6046 json_parser.cpp:18] 
[
	45,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\n#include \"glog/logging.h\"\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    LOG()\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:16:57.010056  6046 json_parser.cpp:18] 
[
	46,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\n#include \"glog/logging.h\"\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    LOG(WARN)\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:16:57.322175  6046 json_parser.cpp:18] 
[
	47,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\n#include \"glog/logging.h\"\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    LOG(WARN)\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:16:58.966959  6046 json_parser.cpp:18] 
[
	48,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\n#include \"glog/logging.h\"\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    LOG(WARN)<<\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:16:59.394198  6046 json_parser.cpp:18] 
[
	49,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\n#include \"glog/logging.h\"\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    LOG(WARN)<<\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:17:00.489660  6046 json_parser.cpp:18] 
[
	50,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\n#include \"glog/logging.h\"\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    LOG(WARNNING)<<\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:17:05.336246  6046 json_parser.cpp:18] 
[
	51,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\n#include \"glog/logging.h\"\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    LOG(WARN)<<\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:17:06.730165  6046 json_parser.cpp:18] 
[
	52,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\n#include \"glog/logging.h\"\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    LOG(WARN)<<\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:17:16.242609  6046 json_parser.cpp:18] 
[
	53,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\n#include \"glog/logging.h\"\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    LOG(WARN)<<\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:17:18.265731  6046 json_parser.cpp:18] 
[
	54,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\n#include \"glog/logging.h\"\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    LOG(WARN)<<\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:17:19.649550  6046 json_parser.cpp:18] 
[
	55,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\n#include \"glog/logging.h\"\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    LOG(WARN)<<\"\"\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:17:19.783722  6046 json_parser.cpp:18] 
[
	56,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\n#include \"glog/logging.h\"\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    LOG(WARN)<<\"\"\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:17:29.812252  6046 json_parser.cpp:18] 
[
	57,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\n#include \"glog/logging.h\"\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    LOG(WARN)<<\"Parse failed\"\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:17:30.122295  6046 json_parser.cpp:18] 
[
	58,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\n#include \"glog/logging.h\"\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    LOG(WARN)<<\"Parse failed\"\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:17:31.897444  6046 json_parser.cpp:18] 
[
	59,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\n#include \"glog/logging.h\"\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    LOG(WARN)<<\"Parse failed\"<<\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:17:32.473793  6046 json_parser.cpp:18] 
[
	60,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\n#include \"glog/logging.h\"\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    LOG(WARN)<<\"Parse failed\"<<\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:17:33.074309  6046 json_parser.cpp:18] 
[
	61,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\n#include \"glog/logging.h\"\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    LOG(WARN)<<\"Parse failed: \"<<\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:17:33.841671  6046 json_parser.cpp:18] 
[
	62,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\n#include \"glog/logging.h\"\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    LOG(WARN)<<\"Parse failed: \"<<\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:17:41.234426  6046 json_parser.cpp:18] 
[
	63,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\n#include \"glog/logging.h\"\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    LOG(WARN)<<\"Parse failed: \"\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:17:41.702874  6046 json_parser.cpp:18] 
[
	64,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\n#include \"glog/logging.h\"\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    LOG(WARN)<<\"Parse failed:\"\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:17:42.366789  6046 json_parser.cpp:18] 
[
	65,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\n#include \"glog/logging.h\"\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    LOG(WARN)<<\"Parse failed\"\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:17:46.346370  6046 json_parser.cpp:18] 
[
	66,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\n#include \"glog/logging.h\"\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    LOG()<<\"Parse failed\"\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:17:46.495106  6046 json_parser.cpp:18] 
[
	67,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\n#include \"glog/logging.h\"\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    LOG()<<\"Parse failed\"\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:17:47.361791  6046 json_parser.cpp:18] 
[
	68,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\n#include \"glog/logging.h\"\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Parse failed\"\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:17:51.002485  6046 json_parser.cpp:18] 
[
	69,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\n#include \"glog/logging.h\"\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Parse failed\"\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:17:51.322374  6046 json_parser.cpp:18] 
[
	70,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\n#include \"glog/logging.h\"\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Parse failed\";\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:17:51.345885  6046 json_parser.cpp:18] 
[
	71,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\n#include \"glog/logging.h\"\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Parse failed\";\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:18:18.011204  6046 json_parser.cpp:18] 
[
	72,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\n#include \"glog/logging.h\"\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Parse failed\";\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:18:18.030992  6046 json_parser.cpp:18] 
[
	73,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\n#include \"glog/logging.h\"\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Parse failed\";\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:18:57.954238  6046 json_parser.cpp:18] 
[
	74,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\n#include \"glog/logging.h\"\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Parse failed\";\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:18:59.921646  6046 json_parser.cpp:18] 
[
	75,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\n#include \"glog/logging.h\"\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"ReParse failed\";\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:18:59.941895  6046 json_parser.cpp:18] 
[
	76,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\n#include \"glog/logging.h\"\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"ReParse failed\";\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:19:00.551100  6046 json_parser.cpp:18] 
[
	77,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\n#include \"glog/logging.h\"\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Reparse failed\";\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:19:04.814256  6046 json_parser.cpp:18] 
[
	78,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\n#include \"glog/logging.h\"\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Reparse failed\";\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Reparse failed\";\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:19:07.085871  6046 json_parser.cpp:18] 
[
	79,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\n#include \"glog/logging.h\"\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"eparse failed\";\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Reparse failed\";\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:19:07.247038  6046 json_parser.cpp:18] 
[
	80,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\n#include \"glog/logging.h\"\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"parse failed\";\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Reparse failed\";\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:19:08.159469  6046 json_parser.cpp:18] 
[
	81,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\n#include \"glog/logging.h\"\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Parse failed\";\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Reparse failed\";\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:22:12.940121  6046 json_parser.cpp:18] 
[
	82,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\n#include \"glog/logging.h\"\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Parse failed\";\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Reparse failed\";\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang_getNullLocation())) {\n    throw std::runtime_error{\"cannot retrieve location\"};\n  }\n\n  CXSourceRange const range(clang_getRange(top, bottom));\n  if (clang_Range_isNull(range)) {\n    throw std::runtime_error{\"cannot retrieve range\"};\n  }\n\n  return range;\n}\n",
			"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp"
		}
	}
]
I0402 16:22:13.039893  6046 json_parser.cpp:18] 
[
	83,
	{
		"filename" : "/home/mr/.vim/bundle/color-cpp/server/ClangAnalyzer/TranslationUnit.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_includes",
			"-I/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/llvm/include",
			"-I/usr/local/include",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright (C) 2011-2018 ycmd contributors\n//\n// This file is part of ycmd.\n//\n// ycmd is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// ycmd is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with ycmd.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"TranslationUnit.h\"\n#include \"ClangHelpers.h\"\n#include \"ClangUtils.h\"\n#include \"TokenKindMap.h\"\n\n#include <algorithm>\n#include <cstdlib>\n#include <fstream>\n#include <memory>\n#include <string>\n#include <time.h>\n\n#include \"glog/logging.h\"\n\nusing std::mutex;\nusing std::remove_pointer;\nusing std::shared_ptr;\nusing std::try_to_lock_t;\nusing std::unique_lock;\n\nnamespace {\n\nunsigned EditingOptions() {\n  // See cpp/llvm/include/clang-c/Index.h file for detail on these options.\n  return CXTranslationUnit_DetailedPreprocessingRecord |\n         CXTranslationUnit_Incomplete |\n         CXTranslationUnit_IncludeBriefCommentsInCodeCompletion |\n         CXTranslationUnit_CreatePreambleOnFirstParse |\n         CXTranslationUnit_KeepGoing |\n         clang_defaultEditingTranslationUnitOptions();\n}\n\nunsigned ReparseOptions(CXTranslationUnit translationUnit) {\n  return clang_defaultReparseOptions(translationUnit);\n}\n\nvoid EnsureCompilerNamePresent(std::vector<const char *> &flags) {\n  bool no_compiler_name_set = !flags.empty() && flags.front()[0] == '-';\n\n  if (flags.empty() || no_compiler_name_set) {\n    flags.insert(flags.begin(), \"clang\");\n  }\n}\n\n} // unnamed namespace\n\nusing CodeCompleteResultsWrap =\n    shared_ptr<remove_pointer<CXCodeCompleteResults>::type>;\n\nTranslationUnit::TranslationUnit() : clang_translation_unit_(nullptr) {}\n\nTranslationUnit::TranslationUnit(const std::string &filename,\n                                 const std::vector<UnsavedFile> &unsaved_files,\n                                 const std::vector<std::string> &flags,\n                                 CXIndex clang_index)\n    : filename_(filename), clang_translation_unit_(nullptr) {\n  std::vector<const char *> pointer_flags;\n  pointer_flags.reserve(flags.size());\n\n  for (const std::string &flag : flags) {\n    pointer_flags.push_back(flag.c_str());\n  }\n\n  EnsureCompilerNamePresent(pointer_flags);\n\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n  const CXUnsavedFile *unsaved =\n      cxunsaved_files.empty() ? nullptr : &cxunsaved_files[0];\n\n  // Actually parse the translation unit.\n  CXErrorCode failure = clang_parseTranslationUnit2FullArgv(\n      clang_index, filename.c_str(), &pointer_flags[0], pointer_flags.size(),\n      const_cast<CXUnsavedFile *>(unsaved), cxunsaved_files.size(),\n      EditingOptions(), &clang_translation_unit_);\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Parse failed\";\n    throw ClangParseError(failure);\n  }\n}\n\nTranslationUnit::~TranslationUnit() { Destroy(); }\n\nvoid TranslationUnit::Destroy() {\n  unique_lock<mutex> lock(clang_access_mutex_);\n\n  if (clang_translation_unit_) {\n    clang_disposeTranslationUnit(clang_translation_unit_);\n    clang_translation_unit_ = nullptr;\n  }\n}\n\nbool TranslationUnit::IsCurrentlyUpdating() const {\n  // We return true when the TU is invalid; an invalid TU also acts a sentinel,\n  // preventing other threads from trying to use it.\n  if (!clang_translation_unit_) {\n    return true;\n  }\n\n  unique_lock<mutex> lock(clang_access_mutex_, try_to_lock_t());\n  return !lock.owns_lock();\n}\n\nstd::vector<Highlight>\nTranslationUnit::Reparse(const std::vector<UnsavedFile> &unsaved_files) {\n  std::vector<CXUnsavedFile> cxunsaved_files = ToCXUnsavedFiles(unsaved_files);\n\n  Reparse(cxunsaved_files);\n\n  unique_lock<mutex> lock(highlights_mutex_);\n  return latest_highlights_;\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files) {\n  unsigned options =\n      (clang_translation_unit_ ? ReparseOptions(clang_translation_unit_)\n                               : static_cast<unsigned>(CXReparse_None));\n\n  Reparse(unsaved_files, options);\n}\n\n// Argument taken as non-const ref because we need to be able to pass a\n// non-const pointer to clang. This function (and clang too) will not modify the\n// param though.\nvoid TranslationUnit::Reparse(std::vector<CXUnsavedFile> &unsaved_files,\n                              size_t parse_options) {\n  CXErrorCode failure;\n  {\n    unique_lock<mutex> lock(clang_access_mutex_);\n\n    if (!clang_translation_unit_) {\n      return;\n    }\n\n    CXUnsavedFile *unsaved =\n        unsaved_files.empty() ? nullptr : &unsaved_files[0];\n\n    // This function should technically return a CXErrorCode enum but return an\n    // int instead.\n    failure = static_cast<CXErrorCode>(clang_reparseTranslationUnit(\n        clang_translation_unit_, unsaved_files.size(), unsaved, parse_options));\n  }\n\n  if (failure != CXError_Success) {\n    LOG(INFO)<<\"Reparse failed\";\n    Destroy();\n    throw ClangParseError(failure);\n  }\n\n  UpdateLatestHighlights();\n}\n\nvoid TranslationUnit::UpdateLatestHighlights() {\n  unique_lock<mutex> lock1(clang_access_mutex_);\n  unique_lock<mutex> lock2(highlights_mutex_);\n\n  latest_highlights_.clear();\n  unsigned int num_tokens;\n  CXToken *tokens;\n  CXSourceRange range = SourceRange();\n  clang_tokenize(clang_translation_unit_, range, &tokens, &num_tokens);\n\n  std::vector<CXCursor> cursors(num_tokens);\n  clang_annotateTokens(clang_translation_unit_, tokens, num_tokens,\n                       cursors.data());\n  for (size_t i = 0; i < num_tokens; ++i) {\n    CXToken token = tokens[i];\n    CXTokenKind kind{clang_getTokenKind(token)};\n    auto loc{clang_getTokenLocation(clang_translation_unit_, token)};\n\n    CXFile file;\n    unsigned line, column, offset;\n    clang_getFileLocation(loc, &file, &line, &column, &offset);\n\n    auto cursor_kind(cursors[i].kind);\n    auto cursor_type(clang_getCursorType(cursors[i]).kind);\n\n    CXString spell{clang_getTokenSpelling(clang_translation_unit_, token)};\n    std::string text{clang_getCString(spell)};\n    clang_disposeString(spell);\n\n    auto mapped(map_token_kind(kind, cursor_kind, cursor_type));\n    if (mapped.size()) {\n      Highlight highlight = BuildHighlight(text, mapped, line, column);\n      latest_highlights_.push_back(highlight);\n    }\n  }\n  clang_disposeTokens(clang_translation_unit_, tokens, num_tokens);\n}\n\nCXSourceRange TranslationUnit::SourceRange() {\n  // ge the whole range of the file\n  size_t size;\n  CXFile const file{clang_getFile(clang_translation_unit_, filename_.c_str())};\n  clang_getFileContents(clang_translation_unit_, file, &size);\n\n  CXSourceLocation const top(\n      clang_getLocationForOffset(clang_translation_unit_, file, 0));\n  CXSourceLocation const bottom(\n      clang_getLocationForOffset(clang_translation_unit_, file, size));\n\n  if (clang_equalLocations(top, clang_getNullLocation()) ||\n      clang_equalLocations(bottom, clang