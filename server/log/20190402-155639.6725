Log file created at: 2019/04/02 15:56:39
Running on machine: mr-pc
Log line format: [IWEF]mmdd hh:mm:ss.uuuuuu threadid file:line] msg
I0402 15:56:39.963052  6725 json_parser.cpp:18] 
[
	1,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/eigen_types.h\"\n\n#include \"common/proto/config/config_map.pb.h\"\n\n#include \"lidar_map.h\"\n#include \"local_database.h\"\n#include \"map_layer.h\"\n#include \"map_scope.h\"\n#include \"ndt3interface.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass LidarMapOffline : public LidarMap {\n public:\n  /// @brief configure the LidarMapOffline class, mainly static members\n  /// which shared by all LidarMapOffline instance, such as database\n  ///\n  /// @param mode[in] specify the database operation mode, read, write, create...\n  ///\n  /// @note this should be called first before any operation about\n  /// LidarMapOffline\n  static bool configure(LocalDatabase::MODE mode);\n\n  /// @brief get the cache range(in number of tiles)\n  static int getCacheRange() { return LidarMap::cache_range_; }\n\n  /// @brief get the watermark of tile cache\n  static int getCacheMargin() { return LidarMap::cache_margin_; }\n\n  /// @brief implimention of LidarMap::initializeLayer, see LidarMap for more infomation\n  bool initializeLayer(int layer_id) override;\n\n  /// @brief initialize a layer by specify type_name, grid_size and tile\n  /// @return the layer_id of the initilized layer, if failed, a negtive number will be returned\n  int initializeLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief implimention of LidarMap::addPointCloud, see LidarMap for more infomation\n  bool addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) override;\n\n  /// @brief load the map to cache\n  /// @param[in] pos the center of the region to be loaded\n  /// @return true on succeed, else false\n  bool load(const Eigen::Vector3f& pos);\n\n  /// @brief Get the map of a layer in specific region\n  ///\n  /// @param layer_id[in] specify which layer to get\n  /// @param[in] scope specifies the submap region.\n  /// @param[in] blocking if is true, this call will block if cache miss happens,\n  /// until tiles are loaded or timeout\n  /// @param[out] ndt3 stores the map we got\n  ///\n  /// @return true on succeed, else false. we may fails when there is a cache miss\n  /// in blocking mode\n  bool getMap(int layer_id, const MapScope& scope, bool blocking,\n              std::shared_ptr<Ndt3Interface>* ndt3);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @param layer_item[in] a layer item contains nessecery infomation\n  /// to add one layer\n  ///\n  /// @return true on succeed, else false\n  bool addLayer(const proto::config::MapLayerItem& layer_item);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @return the layer id of the layer we add\n  int addLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief save the map into database\n  ///\n  /// @return true on succeed, else false\n  bool save();\n\n  /// @brief get one maplayer\n  ///\n  /// @param layer_id[in] specify which layer to get\n  ///\n  /// @return a const ref of maplayer\n  const MapLayer& getLayer(int layer_id);\n\n  /// @brief get one maplayer\n  ///\n  /// @param type_name[in] such as ndt3_corner...\n  ///\n  /// @return a const ref of maplayer\n  const MapLayer& getLayer(const std::string& type_name, float grid_size, float tile_size);\n\n private:\n  static std::shared_ptr<LocalDatabase> database_;\n  static LocalDatabase::MODE database_operation_mode_;\n  static proto::map::MapInfo map_info_;\n\n  std::map<int, std::shared_ptr<MapLayer>> layers_;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h"
		}
	}
]
I0402 15:56:39.980324  6725 json_parser.cpp:18] 
[
	2,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/eigen_types.h\"\n\n#include \"common/proto/config/config_map.pb.h\"\n\n#include \"lidar_map.h\"\n#include \"local_database.h\"\n#include \"map_layer.h\"\n#include \"map_scope.h\"\n#include \"ndt3interface.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass LidarMapOffline : public LidarMap {\n public:\n  /// @brief configure the LidarMapOffline class, mainly static members\n  /// which shared by all LidarMapOffline instance, such as database\n  ///\n  /// @param mode[in] specify the database operation mode, read, write, create...\n  ///\n  /// @note this should be called first before any operation about\n  /// LidarMapOffline\n  static bool configure(LocalDatabase::MODE mode);\n\n  /// @brief get the cache range(in number of tiles)\n  static int getCacheRange() { return LidarMap::cache_range_; }\n\n  /// @brief get the watermark of tile cache\n  static int getCacheMargin() { return LidarMap::cache_margin_; }\n\n  /// @brief implimention of LidarMap::initializeLayer, see LidarMap for more infomation\n  bool initializeLayer(int layer_id) override;\n\n  /// @brief initialize a layer by specify type_name, grid_size and tile\n  /// @return the layer_id of the initilized layer, if failed, a negtive number will be returned\n  int initializeLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief implimention of LidarMap::addPointCloud, see LidarMap for more infomation\n  bool addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) override;\n\n  /// @brief load the map to cache\n  /// @param[in] pos the center of the region to be loaded\n  /// @return true on succeed, else false\n  bool load(const Eigen::Vector3f& pos);\n\n  /// @brief Get the map of a layer in specific region\n  ///\n  /// @param layer_id[in] specify which layer to get\n  /// @param[in] scope specifies the submap region.\n  /// @param[in] blocking if is true, this call will block if cache miss happens,\n  /// until tiles are loaded or timeout\n  /// @param[out] ndt3 stores the map we got\n  ///\n  /// @return true on succeed, else false. we may fails when there is a cache miss\n  /// in blocking mode\n  bool getMap(int layer_id, const MapScope& scope, bool blocking,\n              std::shared_ptr<Ndt3Interface>* ndt3);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @param layer_item[in] a layer item contains nessecery infomation\n  /// to add one layer\n  ///\n  /// @return true on succeed, else false\n  bool addLayer(const proto::config::MapLayerItem& layer_item);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @return the layer id of the layer we add\n  int addLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief save the map into database\n  ///\n  /// @return true on succeed, else false\n  bool save();\n\n  /// @brief get one maplayer\n  ///\n  /// @param layer_id[in] specify which layer to get\n  ///\n  /// @return a const ref of maplayer\n  const MapLayer& getLayer(int layer_id);\n\n  /// @brief get one maplayer\n  ///\n  /// @param type_name[in] such as ndt3_corner...\n  ///\n  /// @return a const ref of maplayer\n  const MapLayer& getLayer(const std::string& type_name, float grid_size, float tile_size);\n\n private:\n  static std::shared_ptr<LocalDatabase> database_;\n  static LocalDatabase::MODE database_operation_mode_;\n  static proto::map::MapInfo map_info_;\n\n  std::map<int, std::shared_ptr<MapLayer>> layers_;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h"
		}
	}
]
I0402 15:56:45.790891  6725 json_parser.cpp:18] 
[
	3,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/eigen_types.h\"\n\n#include \"common/proto/config/config_map.pb.h\"\n\n#include \"lidar_map.h\"\n#include \"local_database.h\"\n#include \"map_layer.h\"\n#include \"map_scope.h\"\n#include \"ndt3interface.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass LidarMapOffline : public LidarMap {\n public:\n  /// @brief configure the LidarMapOffline class, mainly static members\n  /// which shared by all LidarMapOffline instance, such as database\n  ///\n  /// @param mode[in] specify the database operation mode, read, write, create...\n  ///\n  /// @note this should be called first before any operation about\n  /// LidarMapOffline\n  static bool configure(LocalDatabase::MODE mode);\n\n  /// @brief get the cache range(in number of tiles)\n  static int getCacheRange() { return LidarMap::cache_range_; }\n\n  /// @brief get the watermark of tile cache\n  static int getCacheMargin() { return LidarMap::cache_margin_; }\n\n  /// @brief implimention of LidarMap::initializeLayer, see LidarMap for more infomation\n  bool initializeLayer(int layer_id) override;\n\n  /// @brief initialize a layer by specify type_name, grid_size and tile\n  /// @return the layer_id of the initilized layer, if failed, a negtive number will be returned\n  int initializeLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief implimention of LidarMap::addPointCloud, see LidarMap for more infomation\n  bool addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) override;\n\n  /// @brief load the map to cache\n  /// @param[in] pos the center of the region to be loaded\n  /// @return true on succeed, else false\n  bool load(const Eigen::Vector3f& pos);\n\n  /// @brief Get the map of a layer in specific region\n  ///\n  /// @param layer_id[in] specify which layer to get\n  /// @param[in] scope specifies the submap region.\n  /// @param[in] blocking if is true, this call will block if cache miss happens,\n  /// until tiles are loaded or timeout\n  /// @param[out] ndt3 stores the map we got\n  ///\n  /// @return true on succeed, else false. we may fails when there is a cache miss\n  /// in blocking mode\n  bool getMap(int layer_id, const MapScope& scope, bool blocking,\n              std::shared_ptr<Ndt3Interface>* ndt3);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @param layer_item[in] a layer item contains nessecery infomation\n  /// to add one layer\n  ///\n  /// @return true on succeed, else false\n  bool addLayer(const proto::config::MapLayerItem& layer_item);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @return the layer id of the layer we add\n  int addLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief save the map into database\n  ///\n  /// @return true on succeed, else false\n  bool save();\n\n  /// @brief get one maplayer\n  ///\n  /// @param layer_id[in] specify which layer to get\n  ///\n  /// @return a const ref of maplayer\n  MapLayer& getLayer(int layer_id);\n\n  /// @brief get one maplayer\n  ///\n  /// @param type_name[in] such as ndt3_corner...\n  ///\n  /// @return a const ref of maplayer\n  const MapLayer& getLayer(const std::string& type_name, float grid_size, float tile_size);\n\n private:\n  static std::shared_ptr<LocalDatabase> database_;\n  static LocalDatabase::MODE database_operation_mode_;\n  static proto::map::MapInfo map_info_;\n\n  std::map<int, std::shared_ptr<MapLayer>> layers_;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h"
		}
	}
]
I0402 15:56:46.945108  6725 json_parser.cpp:18] 
[
	4,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/eigen_types.h\"\n\n#include \"common/proto/config/config_map.pb.h\"\n\n#include \"lidar_map.h\"\n#include \"local_database.h\"\n#include \"map_layer.h\"\n#include \"map_scope.h\"\n#include \"ndt3interface.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass LidarMapOffline : public LidarMap {\n public:\n  /// @brief configure the LidarMapOffline class, mainly static members\n  /// which shared by all LidarMapOffline instance, such as database\n  ///\n  /// @param mode[in] specify the database operation mode, read, write, create...\n  ///\n  /// @note this should be called first before any operation about\n  /// LidarMapOffline\n  static bool configure(LocalDatabase::MODE mode);\n\n  /// @brief get the cache range(in number of tiles)\n  static int getCacheRange() { return LidarMap::cache_range_; }\n\n  /// @brief get the watermark of tile cache\n  static int getCacheMargin() { return LidarMap::cache_margin_; }\n\n  /// @brief implimention of LidarMap::initializeLayer, see LidarMap for more infomation\n  bool initializeLayer(int layer_id) override;\n\n  /// @brief initialize a layer by specify type_name, grid_size and tile\n  /// @return the layer_id of the initilized layer, if failed, a negtive number will be returned\n  int initializeLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief implimention of LidarMap::addPointCloud, see LidarMap for more infomation\n  bool addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) override;\n\n  /// @brief load the map to cache\n  /// @param[in] pos the center of the region to be loaded\n  /// @return true on succeed, else false\n  bool load(const Eigen::Vector3f& pos);\n\n  /// @brief Get the map of a layer in specific region\n  ///\n  /// @param layer_id[in] specify which layer to get\n  /// @param[in] scope specifies the submap region.\n  /// @param[in] blocking if is true, this call will block if cache miss happens,\n  /// until tiles are loaded or timeout\n  /// @param[out] ndt3 stores the map we got\n  ///\n  /// @return true on succeed, else false. we may fails when there is a cache miss\n  /// in blocking mode\n  bool getMap(int layer_id, const MapScope& scope, bool blocking,\n              std::shared_ptr<Ndt3Interface>* ndt3);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @param layer_item[in] a layer item contains nessecery infomation\n  /// to add one layer\n  ///\n  /// @return true on succeed, else false\n  bool addLayer(const proto::config::MapLayerItem& layer_item);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @return the layer id of the layer we add\n  int addLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief save the map into database\n  ///\n  /// @return true on succeed, else false\n  bool save();\n\n  /// @brief get one maplayer\n  ///\n  /// @param layer_id[in] specify which layer to get\n  ///\n  /// @return a const ref of maplayer\n  MapLayer& getLayer(int layer_id);\n\n  /// @brief get one maplayer\n  ///\n  /// @param type_name[in] such as ndt3_corner...\n  ///\n  /// @return a const ref of maplayer\n  const MapLayer& getLayer(const std::string& type_name, float grid_size, float tile_size);\n\n private:\n  static std::shared_ptr<LocalDatabase> database_;\n  static LocalDatabase::MODE database_operation_mode_;\n  static proto::map::MapInfo map_info_;\n\n  std::map<int, std::shared_ptr<MapLayer>> layers_;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h"
		}
	}
]
I0402 15:56:52.456148  6725 json_parser.cpp:18] 
[
	5,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/eigen_types.h\"\n\n#include \"common/proto/config/config_map.pb.h\"\n\n#include \"lidar_map.h\"\n#include \"local_database.h\"\n#include \"map_layer.h\"\n#include \"map_scope.h\"\n#include \"ndt3interface.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass LidarMapOffline : public LidarMap {\n public:\n  /// @brief configure the LidarMapOffline class, mainly static members\n  /// which shared by all LidarMapOffline instance, such as database\n  ///\n  /// @param mode[in] specify the database operation mode, read, write, create...\n  ///\n  /// @note this should be called first before any operation about\n  /// LidarMapOffline\n  static bool configure(LocalDatabase::MODE mode);\n\n  /// @brief get the cache range(in number of tiles)\n  static int getCacheRange() { return LidarMap::cache_range_; }\n\n  /// @brief get the watermark of tile cache\n  static int getCacheMargin() { return LidarMap::cache_margin_; }\n\n  /// @brief implimention of LidarMap::initializeLayer, see LidarMap for more infomation\n  bool initializeLayer(int layer_id) override;\n\n  /// @brief initialize a layer by specify type_name, grid_size and tile\n  /// @return the layer_id of the initilized layer, if failed, a negtive number will be returned\n  int initializeLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief implimention of LidarMap::addPointCloud, see LidarMap for more infomation\n  bool addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) override;\n\n  /// @brief load the map to cache\n  /// @param[in] pos the center of the region to be loaded\n  /// @return true on succeed, else false\n  bool load(const Eigen::Vector3f& pos);\n\n  /// @brief Get the map of a layer in specific region\n  ///\n  /// @param layer_id[in] specify which layer to get\n  /// @param[in] scope specifies the submap region.\n  /// @param[in] blocking if is true, this call will block if cache miss happens,\n  /// until tiles are loaded or timeout\n  /// @param[out] ndt3 stores the map we got\n  ///\n  /// @return true on succeed, else false. we may fails when there is a cache miss\n  /// in blocking mode\n  bool getMap(int layer_id, const MapScope& scope, bool blocking,\n              std::shared_ptr<Ndt3Interface>* ndt3);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @param layer_item[in] a layer item contains nessecery infomation\n  /// to add one layer\n  ///\n  /// @return true on succeed, else false\n  bool addLayer(const proto::config::MapLayerItem& layer_item);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @return the layer id of the layer we add\n  int addLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief save the map into database\n  ///\n  /// @return true on succeed, else false\n  bool save();\n\n  /// @brief get one maplayer\n  ///\n  /// @param layer_id[in] specify which layer to get\n  ///\n  /// @return a const ref of maplayer\n  std::shared_ptr<MapLayer& getLayer(int layer_id);\n\n  /// @brief get one maplayer\n  ///\n  /// @param type_name[in] such as ndt3_corner...\n  ///\n  /// @return a const ref of maplayer\n  const MapLayer& getLayer(const std::string& type_name, float grid_size, float tile_size);\n\n private:\n  static std::shared_ptr<LocalDatabase> database_;\n  static LocalDatabase::MODE database_operation_mode_;\n  static proto::map::MapInfo map_info_;\n\n  std::map<int, std::shared_ptr<MapLayer>> layers_;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h"
		}
	}
]
I0402 15:56:54.217473  6725 json_parser.cpp:18] 
[
	6,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/eigen_types.h\"\n\n#include \"common/proto/config/config_map.pb.h\"\n\n#include \"lidar_map.h\"\n#include \"local_database.h\"\n#include \"map_layer.h\"\n#include \"map_scope.h\"\n#include \"ndt3interface.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass LidarMapOffline : public LidarMap {\n public:\n  /// @brief configure the LidarMapOffline class, mainly static members\n  /// which shared by all LidarMapOffline instance, such as database\n  ///\n  /// @param mode[in] specify the database operation mode, read, write, create...\n  ///\n  /// @note this should be called first before any operation about\n  /// LidarMapOffline\n  static bool configure(LocalDatabase::MODE mode);\n\n  /// @brief get the cache range(in number of tiles)\n  static int getCacheRange() { return LidarMap::cache_range_; }\n\n  /// @brief get the watermark of tile cache\n  static int getCacheMargin() { return LidarMap::cache_margin_; }\n\n  /// @brief implimention of LidarMap::initializeLayer, see LidarMap for more infomation\n  bool initializeLayer(int layer_id) override;\n\n  /// @brief initialize a layer by specify type_name, grid_size and tile\n  /// @return the layer_id of the initilized layer, if failed, a negtive number will be returned\n  int initializeLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief implimention of LidarMap::addPointCloud, see LidarMap for more infomation\n  bool addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) override;\n\n  /// @brief load the map to cache\n  /// @param[in] pos the center of the region to be loaded\n  /// @return true on succeed, else false\n  bool load(const Eigen::Vector3f& pos);\n\n  /// @brief Get the map of a layer in specific region\n  ///\n  /// @param layer_id[in] specify which layer to get\n  /// @param[in] scope specifies the submap region.\n  /// @param[in] blocking if is true, this call will block if cache miss happens,\n  /// until tiles are loaded or timeout\n  /// @param[out] ndt3 stores the map we got\n  ///\n  /// @return true on succeed, else false. we may fails when there is a cache miss\n  /// in blocking mode\n  bool getMap(int layer_id, const MapScope& scope, bool blocking,\n              std::shared_ptr<Ndt3Interface>* ndt3);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @param layer_item[in] a layer item contains nessecery infomation\n  /// to add one layer\n  ///\n  /// @return true on succeed, else false\n  bool addLayer(const proto::config::MapLayerItem& layer_item);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @return the layer id of the layer we add\n  int addLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief save the map into database\n  ///\n  /// @return true on succeed, else false\n  bool save();\n\n  /// @brief get one maplayer\n  ///\n  /// @param layer_id[in] specify which layer to get\n  ///\n  /// @return a const ref of maplayer\n  std::shared_ptr<MapLayer& getLayer(int layer_id);\n\n  /// @brief get one maplayer\n  ///\n  /// @param type_name[in] such as ndt3_corner...\n  ///\n  /// @return a const ref of maplayer\n  const MapLayer& getLayer(const std::string& type_name, float grid_size, float tile_size);\n\n private:\n  static std::shared_ptr<LocalDatabase> database_;\n  static LocalDatabase::MODE database_operation_mode_;\n  static proto::map::MapInfo map_info_;\n\n  std::map<int, std::shared_ptr<MapLayer>> layers_;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h"
		}
	}
]
I0402 15:56:55.511833  6725 json_parser.cpp:18] 
[
	7,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/eigen_types.h\"\n\n#include \"common/proto/config/config_map.pb.h\"\n\n#include \"lidar_map.h\"\n#include \"local_database.h\"\n#include \"map_layer.h\"\n#include \"map_scope.h\"\n#include \"ndt3interface.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass LidarMapOffline : public LidarMap {\n public:\n  /// @brief configure the LidarMapOffline class, mainly static members\n  /// which shared by all LidarMapOffline instance, such as database\n  ///\n  /// @param mode[in] specify the database operation mode, read, write, create...\n  ///\n  /// @note this should be called first before any operation about\n  /// LidarMapOffline\n  static bool configure(LocalDatabase::MODE mode);\n\n  /// @brief get the cache range(in number of tiles)\n  static int getCacheRange() { return LidarMap::cache_range_; }\n\n  /// @brief get the watermark of tile cache\n  static int getCacheMargin() { return LidarMap::cache_margin_; }\n\n  /// @brief implimention of LidarMap::initializeLayer, see LidarMap for more infomation\n  bool initializeLayer(int layer_id) override;\n\n  /// @brief initialize a layer by specify type_name, grid_size and tile\n  /// @return the layer_id of the initilized layer, if failed, a negtive number will be returned\n  int initializeLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief implimention of LidarMap::addPointCloud, see LidarMap for more infomation\n  bool addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) override;\n\n  /// @brief load the map to cache\n  /// @param[in] pos the center of the region to be loaded\n  /// @return true on succeed, else false\n  bool load(const Eigen::Vector3f& pos);\n\n  /// @brief Get the map of a layer in specific region\n  ///\n  /// @param layer_id[in] specify which layer to get\n  /// @param[in] scope specifies the submap region.\n  /// @param[in] blocking if is true, this call will block if cache miss happens,\n  /// until tiles are loaded or timeout\n  /// @param[out] ndt3 stores the map we got\n  ///\n  /// @return true on succeed, else false. we may fails when there is a cache miss\n  /// in blocking mode\n  bool getMap(int layer_id, const MapScope& scope, bool blocking,\n              std::shared_ptr<Ndt3Interface>* ndt3);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @param layer_item[in] a layer item contains nessecery infomation\n  /// to add one layer\n  ///\n  /// @return true on succeed, else false\n  bool addLayer(const proto::config::MapLayerItem& layer_item);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @return the layer id of the layer we add\n  int addLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief save the map into database\n  ///\n  /// @return true on succeed, else false\n  bool save();\n\n  /// @brief get one maplayer\n  ///\n  /// @param layer_id[in] specify which layer to get\n  ///\n  /// @return a const ref of maplayer\n  std::shared_ptr<MapLayer>& getLayer(int layer_id);\n\n  /// @brief get one maplayer\n  ///\n  /// @param type_name[in] such as ndt3_corner...\n  ///\n  /// @return a const ref of maplayer\n  const MapLayer& getLayer(const std::string& type_name, float grid_size, float tile_size);\n\n private:\n  static std::shared_ptr<LocalDatabase> database_;\n  static LocalDatabase::MODE database_operation_mode_;\n  static proto::map::MapInfo map_info_;\n\n  std::map<int, std::shared_ptr<MapLayer>> layers_;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h"
		}
	}
]
I0402 15:56:57.217160  6725 json_parser.cpp:18] 
[
	8,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/eigen_types.h\"\n\n#include \"common/proto/config/config_map.pb.h\"\n\n#include \"lidar_map.h\"\n#include \"local_database.h\"\n#include \"map_layer.h\"\n#include \"map_scope.h\"\n#include \"ndt3interface.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass LidarMapOffline : public LidarMap {\n public:\n  /// @brief configure the LidarMapOffline class, mainly static members\n  /// which shared by all LidarMapOffline instance, such as database\n  ///\n  /// @param mode[in] specify the database operation mode, read, write, create...\n  ///\n  /// @note this should be called first before any operation about\n  /// LidarMapOffline\n  static bool configure(LocalDatabase::MODE mode);\n\n  /// @brief get the cache range(in number of tiles)\n  static int getCacheRange() { return LidarMap::cache_range_; }\n\n  /// @brief get the watermark of tile cache\n  static int getCacheMargin() { return LidarMap::cache_margin_; }\n\n  /// @brief implimention of LidarMap::initializeLayer, see LidarMap for more infomation\n  bool initializeLayer(int layer_id) override;\n\n  /// @brief initialize a layer by specify type_name, grid_size and tile\n  /// @return the layer_id of the initilized layer, if failed, a negtive number will be returned\n  int initializeLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief implimention of LidarMap::addPointCloud, see LidarMap for more infomation\n  bool addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) override;\n\n  /// @brief load the map to cache\n  /// @param[in] pos the center of the region to be loaded\n  /// @return true on succeed, else false\n  bool load(const Eigen::Vector3f& pos);\n\n  /// @brief Get the map of a layer in specific region\n  ///\n  /// @param layer_id[in] specify which layer to get\n  /// @param[in] scope specifies the submap region.\n  /// @param[in] blocking if is true, this call will block if cache miss happens,\n  /// until tiles are loaded or timeout\n  /// @param[out] ndt3 stores the map we got\n  ///\n  /// @return true on succeed, else false. we may fails when there is a cache miss\n  /// in blocking mode\n  bool getMap(int layer_id, const MapScope& scope, bool blocking,\n              std::shared_ptr<Ndt3Interface>* ndt3);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @param layer_item[in] a layer item contains nessecery infomation\n  /// to add one layer\n  ///\n  /// @return true on succeed, else false\n  bool addLayer(const proto::config::MapLayerItem& layer_item);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @return the layer id of the layer we add\n  int addLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief save the map into database\n  ///\n  /// @return true on succeed, else false\n  bool save();\n\n  /// @brief get one maplayer\n  ///\n  /// @param layer_id[in] specify which layer to get\n  ///\n  /// @return a const ref of maplayer\n  std::shared_ptr<MapLayer>& getLayer(int layer_id);\n\n  /// @brief get one maplayer\n  ///\n  /// @param type_name[in] such as ndt3_corner...\n  ///\n  /// @return a const ref of maplayer\n  const MapLayer& getLayer(const std::string& type_name, float grid_size, float tile_size);\n\n private:\n  static std::shared_ptr<LocalDatabase> database_;\n  static LocalDatabase::MODE database_operation_mode_;\n  static proto::map::MapInfo map_info_;\n\n  std::map<int, std::shared_ptr<MapLayer>> layers_;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h"
		}
	}
]
I0402 15:56:58.224144  6725 json_parser.cpp:18] 
[
	9,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/eigen_types.h\"\n\n#include \"common/proto/config/config_map.pb.h\"\n\n#include \"lidar_map.h\"\n#include \"local_database.h\"\n#include \"map_layer.h\"\n#include \"map_scope.h\"\n#include \"ndt3interface.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass LidarMapOffline : public LidarMap {\n public:\n  /// @brief configure the LidarMapOffline class, mainly static members\n  /// which shared by all LidarMapOffline instance, such as database\n  ///\n  /// @param mode[in] specify the database operation mode, read, write, create...\n  ///\n  /// @note this should be called first before any operation about\n  /// LidarMapOffline\n  static bool configure(LocalDatabase::MODE mode);\n\n  /// @brief get the cache range(in number of tiles)\n  static int getCacheRange() { return LidarMap::cache_range_; }\n\n  /// @brief get the watermark of tile cache\n  static int getCacheMargin() { return LidarMap::cache_margin_; }\n\n  /// @brief implimention of LidarMap::initializeLayer, see LidarMap for more infomation\n  bool initializeLayer(int layer_id) override;\n\n  /// @brief initialize a layer by specify type_name, grid_size and tile\n  /// @return the layer_id of the initilized layer, if failed, a negtive number will be returned\n  int initializeLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief implimention of LidarMap::addPointCloud, see LidarMap for more infomation\n  bool addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) override;\n\n  /// @brief load the map to cache\n  /// @param[in] pos the center of the region to be loaded\n  /// @return true on succeed, else false\n  bool load(const Eigen::Vector3f& pos);\n\n  /// @brief Get the map of a layer in specific region\n  ///\n  /// @param layer_id[in] specify which layer to get\n  /// @param[in] scope specifies the submap region.\n  /// @param[in] blocking if is true, this call will block if cache miss happens,\n  /// until tiles are loaded or timeout\n  /// @param[out] ndt3 stores the map we got\n  ///\n  /// @return true on succeed, else false. we may fails when there is a cache miss\n  /// in blocking mode\n  bool getMap(int layer_id, const MapScope& scope, bool blocking,\n              std::shared_ptr<Ndt3Interface>* ndt3);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @param layer_item[in] a layer item contains nessecery infomation\n  /// to add one layer\n  ///\n  /// @return true on succeed, else false\n  bool addLayer(const proto::config::MapLayerItem& layer_item);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @return the layer id of the layer we add\n  int addLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief save the map into database\n  ///\n  /// @return true on succeed, else false\n  bool save();\n\n  /// @brief get one maplayer\n  ///\n  /// @param layer_id[in] specify which layer to get\n  ///\n  /// @return a const ref of maplayer\n  std::shared_ptr<const MapLayer>& getLayer(int layer_id);\n\n  /// @brief get one maplayer\n  ///\n  /// @param type_name[in] such as ndt3_corner...\n  ///\n  /// @return a const ref of maplayer\n  const MapLayer& getLayer(const std::string& type_name, float grid_size, float tile_size);\n\n private:\n  static std::shared_ptr<LocalDatabase> database_;\n  static LocalDatabase::MODE database_operation_mode_;\n  static proto::map::MapInfo map_info_;\n\n  std::map<int, std::shared_ptr<MapLayer>> layers_;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h"
		}
	}
]
I0402 15:57:00.085261  6725 json_parser.cpp:18] 
[
	10,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/eigen_types.h\"\n\n#include \"common/proto/config/config_map.pb.h\"\n\n#include \"lidar_map.h\"\n#include \"local_database.h\"\n#include \"map_layer.h\"\n#include \"map_scope.h\"\n#include \"ndt3interface.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass LidarMapOffline : public LidarMap {\n public:\n  /// @brief configure the LidarMapOffline class, mainly static members\n  /// which shared by all LidarMapOffline instance, such as database\n  ///\n  /// @param mode[in] specify the database operation mode, read, write, create...\n  ///\n  /// @note this should be called first before any operation about\n  /// LidarMapOffline\n  static bool configure(LocalDatabase::MODE mode);\n\n  /// @brief get the cache range(in number of tiles)\n  static int getCacheRange() { return LidarMap::cache_range_; }\n\n  /// @brief get the watermark of tile cache\n  static int getCacheMargin() { return LidarMap::cache_margin_; }\n\n  /// @brief implimention of LidarMap::initializeLayer, see LidarMap for more infomation\n  bool initializeLayer(int layer_id) override;\n\n  /// @brief initialize a layer by specify type_name, grid_size and tile\n  /// @return the layer_id of the initilized layer, if failed, a negtive number will be returned\n  int initializeLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief implimention of LidarMap::addPointCloud, see LidarMap for more infomation\n  bool addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) override;\n\n  /// @brief load the map to cache\n  /// @param[in] pos the center of the region to be loaded\n  /// @return true on succeed, else false\n  bool load(const Eigen::Vector3f& pos);\n\n  /// @brief Get the map of a layer in specific region\n  ///\n  /// @param layer_id[in] specify which layer to get\n  /// @param[in] scope specifies the submap region.\n  /// @param[in] blocking if is true, this call will block if cache miss happens,\n  /// until tiles are loaded or timeout\n  /// @param[out] ndt3 stores the map we got\n  ///\n  /// @return true on succeed, else false. we may fails when there is a cache miss\n  /// in blocking mode\n  bool getMap(int layer_id, const MapScope& scope, bool blocking,\n              std::shared_ptr<Ndt3Interface>* ndt3);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @param layer_item[in] a layer item contains nessecery infomation\n  /// to add one layer\n  ///\n  /// @return true on succeed, else false\n  bool addLayer(const proto::config::MapLayerItem& layer_item);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @return the layer id of the layer we add\n  int addLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief save the map into database\n  ///\n  /// @return true on succeed, else false\n  bool save();\n\n  /// @brief get one maplayer\n  ///\n  /// @param layer_id[in] specify which layer to get\n  ///\n  /// @return a const ref of maplayer\n  std::shared_ptr<const MapLayer> getLayer(int layer_id);\n\n  /// @brief get one maplayer\n  ///\n  /// @param type_name[in] such as ndt3_corner...\n  ///\n  /// @return a const ref of maplayer\n  const MapLayer& getLayer(const std::string& type_name, float grid_size, float tile_size);\n\n private:\n  static std::shared_ptr<LocalDatabase> database_;\n  static LocalDatabase::MODE database_operation_mode_;\n  static proto::map::MapInfo map_info_;\n\n  std::map<int, std::shared_ptr<MapLayer>> layers_;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h"
		}
	}
]
I0402 15:57:06.845461  6725 json_parser.cpp:18] 
[
	11,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/eigen_types.h\"\n\n#include \"common/proto/config/config_map.pb.h\"\n\n#include \"lidar_map.h\"\n#include \"local_database.h\"\n#include \"map_layer.h\"\n#include \"map_scope.h\"\n#include \"ndt3interface.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass LidarMapOffline : public LidarMap {\n public:\n  /// @brief configure the LidarMapOffline class, mainly static members\n  /// which shared by all LidarMapOffline instance, such as database\n  ///\n  /// @param mode[in] specify the database operation mode, read, write, create...\n  ///\n  /// @note this should be called first before any operation about\n  /// LidarMapOffline\n  static bool configure(LocalDatabase::MODE mode);\n\n  /// @brief get the cache range(in number of tiles)\n  static int getCacheRange() { return LidarMap::cache_range_; }\n\n  /// @brief get the watermark of tile cache\n  static int getCacheMargin() { return LidarMap::cache_margin_; }\n\n  /// @brief implimention of LidarMap::initializeLayer, see LidarMap for more infomation\n  bool initializeLayer(int layer_id) override;\n\n  /// @brief initialize a layer by specify type_name, grid_size and tile\n  /// @return the layer_id of the initilized layer, if failed, a negtive number will be returned\n  int initializeLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief implimention of LidarMap::addPointCloud, see LidarMap for more infomation\n  bool addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) override;\n\n  /// @brief load the map to cache\n  /// @param[in] pos the center of the region to be loaded\n  /// @return true on succeed, else false\n  bool load(const Eigen::Vector3f& pos);\n\n  /// @brief Get the map of a layer in specific region\n  ///\n  /// @param layer_id[in] specify which layer to get\n  /// @param[in] scope specifies the submap region.\n  /// @param[in] blocking if is true, this call will block if cache miss happens,\n  /// until tiles are loaded or timeout\n  /// @param[out] ndt3 stores the map we got\n  ///\n  /// @return true on succeed, else false. we may fails when there is a cache miss\n  /// in blocking mode\n  bool getMap(int layer_id, const MapScope& scope, bool blocking,\n              std::shared_ptr<Ndt3Interface>* ndt3);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @param layer_item[in] a layer item contains nessecery infomation\n  /// to add one layer\n  ///\n  /// @return true on succeed, else false\n  bool addLayer(const proto::config::MapLayerItem& layer_item);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @return the layer id of the layer we add\n  int addLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief save the map into database\n  ///\n  /// @return true on succeed, else false\n  bool save();\n\n  /// @brief get one maplayer\n  ///\n  /// @param layer_id[in] specify which layer to get\n  ///\n  /// @return a const ref of maplayer\n  std::shared_ptr<const MapLayer> getLayer(int layer_id);\n\n  /// @brief get one maplayer\n  ///\n  /// @param type_name[in] such as ndt3_corner...\n  ///\n  /// @return a const ref of maplayer\n  MapLayer& getLayer(const std::string& type_name, float grid_size, float tile_size);\n\n private:\n  static std::shared_ptr<LocalDatabase> database_;\n  static LocalDatabase::MODE database_operation_mode_;\n  static proto::map::MapInfo map_info_;\n\n  std::map<int, std::shared_ptr<MapLayer>> layers_;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h"
		}
	}
]
I0402 15:57:06.937083  6725 json_parser.cpp:18] 
[
	12,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/eigen_types.h\"\n\n#include \"common/proto/config/config_map.pb.h\"\n\n#include \"lidar_map.h\"\n#include \"local_database.h\"\n#include \"map_layer.h\"\n#include \"map_scope.h\"\n#include \"ndt3interface.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass LidarMapOffline : public LidarMap {\n public:\n  /// @brief configure the LidarMapOffline class, mainly static members\n  /// which shared by all LidarMapOffline instance, such as database\n  ///\n  /// @param mode[in] specify the database operation mode, read, write, create...\n  ///\n  /// @note this should be called first before any operation about\n  /// LidarMapOffline\n  static bool configure(LocalDatabase::MODE mode);\n\n  /// @brief get the cache range(in number of tiles)\n  static int getCacheRange() { return LidarMap::cache_range_; }\n\n  /// @brief get the watermark of tile cache\n  static int getCacheMargin() { return LidarMap::cache_margin_; }\n\n  /// @brief implimention of LidarMap::initializeLayer, see LidarMap for more infomation\n  bool initializeLayer(int layer_id) override;\n\n  /// @brief initialize a layer by specify type_name, grid_size and tile\n  /// @return the layer_id of the initilized layer, if failed, a negtive number will be returned\n  int initializeLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief implimention of LidarMap::addPointCloud, see LidarMap for more infomation\n  bool addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) override;\n\n  /// @brief load the map to cache\n  /// @param[in] pos the center of the region to be loaded\n  /// @return true on succeed, else false\n  bool load(const Eigen::Vector3f& pos);\n\n  /// @brief Get the map of a layer in specific region\n  ///\n  /// @param layer_id[in] specify which layer to get\n  /// @param[in] scope specifies the submap region.\n  /// @param[in] blocking if is true, this call will block if cache miss happens,\n  /// until tiles are loaded or timeout\n  /// @param[out] ndt3 stores the map we got\n  ///\n  /// @return true on succeed, else false. we may fails when there is a cache miss\n  /// in blocking mode\n  bool getMap(int layer_id, const MapScope& scope, bool blocking,\n              std::shared_ptr<Ndt3Interface>* ndt3);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @param layer_item[in] a layer item contains nessecery infomation\n  /// to add one layer\n  ///\n  /// @return true on succeed, else false\n  bool addLayer(const proto::config::MapLayerItem& layer_item);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @return the layer id of the layer we add\n  int addLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief save the map into database\n  ///\n  /// @return true on succeed, else false\n  bool save();\n\n  /// @brief get one maplayer\n  ///\n  /// @param layer_id[in] specify which layer to get\n  ///\n  /// @return a const ref of maplayer\n  std::shared_ptr<const MapLayer> getLayer(int layer_id);\n\n  /// @brief get one maplayer\n  ///\n  /// @param type_name[in] such as ndt3_corner...\n  ///\n  /// @return a const ref of maplayer\n  MapLayer& getLayer(const std::string& type_name, float grid_size, float tile_size);\n\n private:\n  static std::shared_ptr<LocalDatabase> database_;\n  static LocalDatabase::MODE database_operation_mode_;\n  static proto::map::MapInfo map_info_;\n\n  std::map<int, std::shared_ptr<MapLayer>> layers_;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h"
		}
	}
]
I0402 15:57:12.623744  6725 json_parser.cpp:18] 
[
	13,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/eigen_types.h\"\n\n#include \"common/proto/config/config_map.pb.h\"\n\n#include \"lidar_map.h\"\n#include \"local_database.h\"\n#include \"map_layer.h\"\n#include \"map_scope.h\"\n#include \"ndt3interface.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass LidarMapOffline : public LidarMap {\n public:\n  /// @brief configure the LidarMapOffline class, mainly static members\n  /// which shared by all LidarMapOffline instance, such as database\n  ///\n  /// @param mode[in] specify the database operation mode, read, write, create...\n  ///\n  /// @note this should be called first before any operation about\n  /// LidarMapOffline\n  static bool configure(LocalDatabase::MODE mode);\n\n  /// @brief get the cache range(in number of tiles)\n  static int getCacheRange() { return LidarMap::cache_range_; }\n\n  /// @brief get the watermark of tile cache\n  static int getCacheMargin() { return LidarMap::cache_margin_; }\n\n  /// @brief implimention of LidarMap::initializeLayer, see LidarMap for more infomation\n  bool initializeLayer(int layer_id) override;\n\n  /// @brief initialize a layer by specify type_name, grid_size and tile\n  /// @return the layer_id of the initilized layer, if failed, a negtive number will be returned\n  int initializeLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief implimention of LidarMap::addPointCloud, see LidarMap for more infomation\n  bool addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) override;\n\n  /// @brief load the map to cache\n  /// @param[in] pos the center of the region to be loaded\n  /// @return true on succeed, else false\n  bool load(const Eigen::Vector3f& pos);\n\n  /// @brief Get the map of a layer in specific region\n  ///\n  /// @param layer_id[in] specify which layer to get\n  /// @param[in] scope specifies the submap region.\n  /// @param[in] blocking if is true, this call will block if cache miss happens,\n  /// until tiles are loaded or timeout\n  /// @param[out] ndt3 stores the map we got\n  ///\n  /// @return true on succeed, else false. we may fails when there is a cache miss\n  /// in blocking mode\n  bool getMap(int layer_id, const MapScope& scope, bool blocking,\n              std::shared_ptr<Ndt3Interface>* ndt3);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @param layer_item[in] a layer item contains nessecery infomation\n  /// to add one layer\n  ///\n  /// @return true on succeed, else false\n  bool addLayer(const proto::config::MapLayerItem& layer_item);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @return the layer id of the layer we add\n  int addLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief save the map into database\n  ///\n  /// @return true on succeed, else false\n  bool save();\n\n  /// @brief get one maplayer\n  ///\n  /// @param layer_id[in] specify which layer to get\n  ///\n  /// @return a const ref of maplayer\n  std::shared_ptr<const MapLayer> getLayer(int layer_id);\n\n  /// @brief get one maplayer\n  ///\n  /// @param type_name[in] such as ndt3_corner...\n  ///\n  /// @return a const ref of maplayer\n  std::shared_ptr<const MapLayer& getLayer(const std::string& type_name, float grid_size, float tile_size);\n\n private:\n  static std::shared_ptr<LocalDatabase> database_;\n  static LocalDatabase::MODE database_operation_mode_;\n  static proto::map::MapInfo map_info_;\n\n  std::map<int, std::shared_ptr<MapLayer>> layers_;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h"
		}
	}
]
I0402 15:57:14.165132  6725 json_parser.cpp:18] 
[
	14,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/eigen_types.h\"\n\n#include \"common/proto/config/config_map.pb.h\"\n\n#include \"lidar_map.h\"\n#include \"local_database.h\"\n#include \"map_layer.h\"\n#include \"map_scope.h\"\n#include \"ndt3interface.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass LidarMapOffline : public LidarMap {\n public:\n  /// @brief configure the LidarMapOffline class, mainly static members\n  /// which shared by all LidarMapOffline instance, such as database\n  ///\n  /// @param mode[in] specify the database operation mode, read, write, create...\n  ///\n  /// @note this should be called first before any operation about\n  /// LidarMapOffline\n  static bool configure(LocalDatabase::MODE mode);\n\n  /// @brief get the cache range(in number of tiles)\n  static int getCacheRange() { return LidarMap::cache_range_; }\n\n  /// @brief get the watermark of tile cache\n  static int getCacheMargin() { return LidarMap::cache_margin_; }\n\n  /// @brief implimention of LidarMap::initializeLayer, see LidarMap for more infomation\n  bool initializeLayer(int layer_id) override;\n\n  /// @brief initialize a layer by specify type_name, grid_size and tile\n  /// @return the layer_id of the initilized layer, if failed, a negtive number will be returned\n  int initializeLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief implimention of LidarMap::addPointCloud, see LidarMap for more infomation\n  bool addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) override;\n\n  /// @brief load the map to cache\n  /// @param[in] pos the center of the region to be loaded\n  /// @return true on succeed, else false\n  bool load(const Eigen::Vector3f& pos);\n\n  /// @brief Get the map of a layer in specific region\n  ///\n  /// @param layer_id[in] specify which layer to get\n  /// @param[in] scope specifies the submap region.\n  /// @param[in] blocking if is true, this call will block if cache miss happens,\n  /// until tiles are loaded or timeout\n  /// @param[out] ndt3 stores the map we got\n  ///\n  /// @return true on succeed, else false. we may fails when there is a cache miss\n  /// in blocking mode\n  bool getMap(int layer_id, const MapScope& scope, bool blocking,\n              std::shared_ptr<Ndt3Interface>* ndt3);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @param layer_item[in] a layer item contains nessecery infomation\n  /// to add one layer\n  ///\n  /// @return true on succeed, else false\n  bool addLayer(const proto::config::MapLayerItem& layer_item);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @return the layer id of the layer we add\n  int addLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief save the map into database\n  ///\n  /// @return true on succeed, else false\n  bool save();\n\n  /// @brief get one maplayer\n  ///\n  /// @param layer_id[in] specify which layer to get\n  ///\n  /// @return a const ref of maplayer\n  std::shared_ptr<const MapLayer> getLayer(int layer_id);\n\n  /// @brief get one maplayer\n  ///\n  /// @param type_name[in] such as ndt3_corner...\n  ///\n  /// @return a const ref of maplayer\n  std::shared_ptr<const MapLayer getLayer(const std::string& type_name, float grid_size, float tile_size);\n\n private:\n  static std::shared_ptr<LocalDatabase> database_;\n  static LocalDatabase::MODE database_operation_mode_;\n  static proto::map::MapInfo map_info_;\n\n  std::map<int, std::shared_ptr<MapLayer>> layers_;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h"
		}
	}
]
I0402 15:57:14.266899  6725 json_parser.cpp:18] 
[
	15,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/eigen_types.h\"\n\n#include \"common/proto/config/config_map.pb.h\"\n\n#include \"lidar_map.h\"\n#include \"local_database.h\"\n#include \"map_layer.h\"\n#include \"map_scope.h\"\n#include \"ndt3interface.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass LidarMapOffline : public LidarMap {\n public:\n  /// @brief configure the LidarMapOffline class, mainly static members\n  /// which shared by all LidarMapOffline instance, such as database\n  ///\n  /// @param mode[in] specify the database operation mode, read, write, create...\n  ///\n  /// @note this should be called first before any operation about\n  /// LidarMapOffline\n  static bool configure(LocalDatabase::MODE mode);\n\n  /// @brief get the cache range(in number of tiles)\n  static int getCacheRange() { return LidarMap::cache_range_; }\n\n  /// @brief get the watermark of tile cache\n  static int getCacheMargin() { return LidarMap::cache_margin_; }\n\n  /// @brief implimention of LidarMap::initializeLayer, see LidarMap for more infomation\n  bool initializeLayer(int layer_id) override;\n\n  /// @brief initialize a layer by specify type_name, grid_size and tile\n  /// @return the layer_id of the initilized layer, if failed, a negtive number will be returned\n  int initializeLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief implimention of LidarMap::addPointCloud, see LidarMap for more infomation\n  bool addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) override;\n\n  /// @brief load the map to cache\n  /// @param[in] pos the center of the region to be loaded\n  /// @return true on succeed, else false\n  bool load(const Eigen::Vector3f& pos);\n\n  /// @brief Get the map of a layer in specific region\n  ///\n  /// @param layer_id[in] specify which layer to get\n  /// @param[in] scope specifies the submap region.\n  /// @param[in] blocking if is true, this call will block if cache miss happens,\n  /// until tiles are loaded or timeout\n  /// @param[out] ndt3 stores the map we got\n  ///\n  /// @return true on succeed, else false. we may fails when there is a cache miss\n  /// in blocking mode\n  bool getMap(int layer_id, const MapScope& scope, bool blocking,\n              std::shared_ptr<Ndt3Interface>* ndt3);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @param layer_item[in] a layer item contains nessecery infomation\n  /// to add one layer\n  ///\n  /// @return true on succeed, else false\n  bool addLayer(const proto::config::MapLayerItem& layer_item);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @return the layer id of the layer we add\n  int addLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief save the map into database\n  ///\n  /// @return true on succeed, else false\n  bool save();\n\n  /// @brief get one maplayer\n  ///\n  /// @param layer_id[in] specify which layer to get\n  ///\n  /// @return a const ref of maplayer\n  std::shared_ptr<const MapLayer> getLayer(int layer_id);\n\n  /// @brief get one maplayer\n  ///\n  /// @param type_name[in] such as ndt3_corner...\n  ///\n  /// @return a const ref of maplayer\n  std::shared_ptr<const MapLayer getLayer(const std::string& type_name, float grid_size, float tile_size);\n\n private:\n  static std::shared_ptr<LocalDatabase> database_;\n  static LocalDatabase::MODE database_operation_mode_;\n  static proto::map::MapInfo map_info_;\n\n  std::map<int, std::shared_ptr<MapLayer>> layers_;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h"
		}
	}
]
I0402 15:57:15.072324  6725 json_parser.cpp:18] 
[
	16,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/eigen_types.h\"\n\n#include \"common/proto/config/config_map.pb.h\"\n\n#include \"lidar_map.h\"\n#include \"local_database.h\"\n#include \"map_layer.h\"\n#include \"map_scope.h\"\n#include \"ndt3interface.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass LidarMapOffline : public LidarMap {\n public:\n  /// @brief configure the LidarMapOffline class, mainly static members\n  /// which shared by all LidarMapOffline instance, such as database\n  ///\n  /// @param mode[in] specify the database operation mode, read, write, create...\n  ///\n  /// @note this should be called first before any operation about\n  /// LidarMapOffline\n  static bool configure(LocalDatabase::MODE mode);\n\n  /// @brief get the cache range(in number of tiles)\n  static int getCacheRange() { return LidarMap::cache_range_; }\n\n  /// @brief get the watermark of tile cache\n  static int getCacheMargin() { return LidarMap::cache_margin_; }\n\n  /// @brief implimention of LidarMap::initializeLayer, see LidarMap for more infomation\n  bool initializeLayer(int layer_id) override;\n\n  /// @brief initialize a layer by specify type_name, grid_size and tile\n  /// @return the layer_id of the initilized layer, if failed, a negtive number will be returned\n  int initializeLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief implimention of LidarMap::addPointCloud, see LidarMap for more infomation\n  bool addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) override;\n\n  /// @brief load the map to cache\n  /// @param[in] pos the center of the region to be loaded\n  /// @return true on succeed, else false\n  bool load(const Eigen::Vector3f& pos);\n\n  /// @brief Get the map of a layer in specific region\n  ///\n  /// @param layer_id[in] specify which layer to get\n  /// @param[in] scope specifies the submap region.\n  /// @param[in] blocking if is true, this call will block if cache miss happens,\n  /// until tiles are loaded or timeout\n  /// @param[out] ndt3 stores the map we got\n  ///\n  /// @return true on succeed, else false. we may fails when there is a cache miss\n  /// in blocking mode\n  bool getMap(int layer_id, const MapScope& scope, bool blocking,\n              std::shared_ptr<Ndt3Interface>* ndt3);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @param layer_item[in] a layer item contains nessecery infomation\n  /// to add one layer\n  ///\n  /// @return true on succeed, else false\n  bool addLayer(const proto::config::MapLayerItem& layer_item);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @return the layer id of the layer we add\n  int addLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief save the map into database\n  ///\n  /// @return true on succeed, else false\n  bool save();\n\n  /// @brief get one maplayer\n  ///\n  /// @param layer_id[in] specify which layer to get\n  ///\n  /// @return a const ref of maplayer\n  std::shared_ptr<const MapLayer> getLayer(int layer_id);\n\n  /// @brief get one maplayer\n  ///\n  /// @param type_name[in] such as ndt3_corner...\n  ///\n  /// @return a const ref of maplayer\n  std::shared_ptr<const MapLayer> getLayer(const std::string& type_name, float grid_size, float tile_size);\n\n private:\n  static std::shared_ptr<LocalDatabase> database_;\n  static LocalDatabase::MODE database_operation_mode_;\n  static proto::map::MapInfo map_info_;\n\n  std::map<int, std::shared_ptr<MapLayer>> layers_;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h"
		}
	}
]
I0402 15:57:21.492866  6725 json_parser.cpp:18] 
[
	17,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/eigen_types.h\"\n\n#include \"common/proto/config/config_map.pb.h\"\n\n#include \"lidar_map.h\"\n#include \"local_database.h\"\n#include \"map_layer.h\"\n#include \"map_scope.h\"\n#include \"ndt3interface.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass LidarMapOffline : public LidarMap {\n public:\n  /// @brief configure the LidarMapOffline class, mainly static members\n  /// which shared by all LidarMapOffline instance, such as database\n  ///\n  /// @param mode[in] specify the database operation mode, read, write, create...\n  ///\n  /// @note this should be called first before any operation about\n  /// LidarMapOffline\n  static bool configure(LocalDatabase::MODE mode);\n\n  /// @brief get the cache range(in number of tiles)\n  static int getCacheRange() { return LidarMap::cache_range_; }\n\n  /// @brief get the watermark of tile cache\n  static int getCacheMargin() { return LidarMap::cache_margin_; }\n\n  /// @brief implimention of LidarMap::initializeLayer, see LidarMap for more infomation\n  bool initializeLayer(int layer_id) override;\n\n  /// @brief initialize a layer by specify type_name, grid_size and tile\n  /// @return the layer_id of the initilized layer, if failed, a negtive number will be returned\n  int initializeLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief implimention of LidarMap::addPointCloud, see LidarMap for more infomation\n  bool addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) override;\n\n  /// @brief load the map to cache\n  /// @param[in] pos the center of the region to be loaded\n  /// @return true on succeed, else false\n  bool load(const Eigen::Vector3f& pos);\n\n  /// @brief Get the map of a layer in specific region\n  ///\n  /// @param layer_id[in] specify which layer to get\n  /// @param[in] scope specifies the submap region.\n  /// @param[in] blocking if is true, this call will block if cache miss happens,\n  /// until tiles are loaded or timeout\n  /// @param[out] ndt3 stores the map we got\n  ///\n  /// @return true on succeed, else false. we may fails when there is a cache miss\n  /// in blocking mode\n  bool getMap(int layer_id, const MapScope& scope, bool blocking,\n              std::shared_ptr<Ndt3Interface>* ndt3);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @param layer_item[in] a layer item contains nessecery infomation\n  /// to add one layer\n  ///\n  /// @return true on succeed, else false\n  bool addLayer(const proto::config::MapLayerItem& layer_item);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @return the layer id of the layer we add\n  int addLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief save the map into database\n  ///\n  /// @return true on succeed, else false\n  bool save();\n\n  /// @brief get one maplayer\n  ///\n  /// @param layer_id[in] specify which layer to get\n  ///\n  /// @return a const ref of maplayer\n  std::shared_ptr<const MapLayer> getLayer(int layer_id);\n\n  /// @brief get one maplayer\n  ///\n  /// @param type_name[in] such as ndt3_corner...\n  ///\n  /// @return a const ref of maplaye\n  std::shared_ptr<const MapLayer> getLayer(const std::string& type_name, float grid_size, float tile_size);\n\n private:\n  static std::shared_ptr<LocalDatabase> database_;\n  static LocalDatabase::MODE database_operation_mode_;\n  static proto::map::MapInfo map_info_;\n\n  std::map<int, std::shared_ptr<MapLayer>> layers_;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h"
		}
	}
]
I0402 15:57:22.153049  6725 json_parser.cpp:18] 
[
	18,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/eigen_types.h\"\n\n#include \"common/proto/config/config_map.pb.h\"\n\n#include \"lidar_map.h\"\n#include \"local_database.h\"\n#include \"map_layer.h\"\n#include \"map_scope.h\"\n#include \"ndt3interface.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass LidarMapOffline : public LidarMap {\n public:\n  /// @brief configure the LidarMapOffline class, mainly static members\n  /// which shared by all LidarMapOffline instance, such as database\n  ///\n  /// @param mode[in] specify the database operation mode, read, write, create...\n  ///\n  /// @note this should be called first before any operation about\n  /// LidarMapOffline\n  static bool configure(LocalDatabase::MODE mode);\n\n  /// @brief get the cache range(in number of tiles)\n  static int getCacheRange() { return LidarMap::cache_range_; }\n\n  /// @brief get the watermark of tile cache\n  static int getCacheMargin() { return LidarMap::cache_margin_; }\n\n  /// @brief implimention of LidarMap::initializeLayer, see LidarMap for more infomation\n  bool initializeLayer(int layer_id) override;\n\n  /// @brief initialize a layer by specify type_name, grid_size and tile\n  /// @return the layer_id of the initilized layer, if failed, a negtive number will be returned\n  int initializeLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief implimention of LidarMap::addPointCloud, see LidarMap for more infomation\n  bool addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) override;\n\n  /// @brief load the map to cache\n  /// @param[in] pos the center of the region to be loaded\n  /// @return true on succeed, else false\n  bool load(const Eigen::Vector3f& pos);\n\n  /// @brief Get the map of a layer in specific region\n  ///\n  /// @param layer_id[in] specify which layer to get\n  /// @param[in] scope specifies the submap region.\n  /// @param[in] blocking if is true, this call will block if cache miss happens,\n  /// until tiles are loaded or timeout\n  /// @param[out] ndt3 stores the map we got\n  ///\n  /// @return true on succeed, else false. we may fails when there is a cache miss\n  /// in blocking mode\n  bool getMap(int layer_id, const MapScope& scope, bool blocking,\n              std::shared_ptr<Ndt3Interface>* ndt3);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @param layer_item[in] a layer item contains nessecery infomation\n  /// to add one layer\n  ///\n  /// @return true on succeed, else false\n  bool addLayer(const proto::config::MapLayerItem& layer_item);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @return the layer id of the layer we add\n  int addLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief save the map into database\n  ///\n  /// @return true on succeed, else false\n  bool save();\n\n  /// @brief get one maplayer\n  ///\n  /// @param layer_id[in] specify which layer to get\n  ///\n  /// @return a const ref of maplayer\n  std::shared_ptr<const MapLayer> getLayer(int layer_id);\n\n  /// @brief get one maplayer\n  ///\n  /// @param type_name[in] such as ndt3_corner...\n  ///\n  /// @return a const ref of maplay\n  std::shared_ptr<const MapLayer> getLayer(const std::string& type_name, float grid_size, float tile_size);\n\n private:\n  static std::shared_ptr<LocalDatabase> database_;\n  static LocalDatabase::MODE database_operation_mode_;\n  static proto::map::MapInfo map_info_;\n\n  std::map<int, std::shared_ptr<MapLayer>> layers_;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h"
		}
	}
]
I0402 15:57:22.193195  6725 json_parser.cpp:18] 
[
	19,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/eigen_types.h\"\n\n#include \"common/proto/config/config_map.pb.h\"\n\n#include \"lidar_map.h\"\n#include \"local_database.h\"\n#include \"map_layer.h\"\n#include \"map_scope.h\"\n#include \"ndt3interface.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass LidarMapOffline : public LidarMap {\n public:\n  /// @brief configure the LidarMapOffline class, mainly static members\n  /// which shared by all LidarMapOffline instance, such as database\n  ///\n  /// @param mode[in] specify the database operation mode, read, write, create...\n  ///\n  /// @note this should be called first before any operation about\n  /// LidarMapOffline\n  static bool configure(LocalDatabase::MODE mode);\n\n  /// @brief get the cache range(in number of tiles)\n  static int getCacheRange() { return LidarMap::cache_range_; }\n\n  /// @brief get the watermark of tile cache\n  static int getCacheMargin() { return LidarMap::cache_margin_; }\n\n  /// @brief implimention of LidarMap::initializeLayer, see LidarMap for more infomation\n  bool initializeLayer(int layer_id) override;\n\n  /// @brief initialize a layer by specify type_name, grid_size and tile\n  /// @return the layer_id of the initilized layer, if failed, a negtive number will be returned\n  int initializeLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief implimention of LidarMap::addPointCloud, see LidarMap for more infomation\n  bool addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) override;\n\n  /// @brief load the map to cache\n  /// @param[in] pos the center of the region to be loaded\n  /// @return true on succeed, else false\n  bool load(const Eigen::Vector3f& pos);\n\n  /// @brief Get the map of a layer in specific region\n  ///\n  /// @param layer_id[in] specify which layer to get\n  /// @param[in] scope specifies the submap region.\n  /// @param[in] blocking if is true, this call will block if cache miss happens,\n  /// until tiles are loaded or timeout\n  /// @param[out] ndt3 stores the map we got\n  ///\n  /// @return true on succeed, else false. we may fails when there is a cache miss\n  /// in blocking mode\n  bool getMap(int layer_id, const MapScope& scope, bool blocking,\n              std::shared_ptr<Ndt3Interface>* ndt3);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @param layer_item[in] a layer item contains nessecery infomation\n  /// to add one layer\n  ///\n  /// @return true on succeed, else false\n  bool addLayer(const proto::config::MapLayerItem& layer_item);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @return the layer id of the layer we add\n  int addLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief save the map into database\n  ///\n  /// @return true on succeed, else false\n  bool save();\n\n  /// @brief get one maplayer\n  ///\n  /// @param layer_id[in] specify which layer to get\n  ///\n  /// @return a const ref of maplayer\n  std::shared_ptr<const MapLayer> getLayer(int layer_id);\n\n  /// @brief get one maplayer\n  ///\n  /// @param type_name[in] such as ndt3_corner...\n  ///\n  /// @return a const ref of mapla\n  std::shared_ptr<const MapLayer> getLayer(const std::string& type_name, float grid_size, float tile_size);\n\n private:\n  static std::shared_ptr<LocalDatabase> database_;\n  static LocalDatabase::MODE database_operation_mode_;\n  static proto::map::MapInfo map_info_;\n\n  std::map<int, std::shared_ptr<MapLayer>> layers_;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h"
		}
	}
]
I0402 15:57:22.229656  6725 json_parser.cpp:18] 
[
	20,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/eigen_types.h\"\n\n#include \"common/proto/config/config_map.pb.h\"\n\n#include \"lidar_map.h\"\n#include \"local_database.h\"\n#include \"map_layer.h\"\n#include \"map_scope.h\"\n#include \"ndt3interface.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass LidarMapOffline : public LidarMap {\n public:\n  /// @brief configure the LidarMapOffline class, mainly static members\n  /// which shared by all LidarMapOffline instance, such as database\n  ///\n  /// @param mode[in] specify the database operation mode, read, write, create...\n  ///\n  /// @note this should be called first before any operation about\n  /// LidarMapOffline\n  static bool configure(LocalDatabase::MODE mode);\n\n  /// @brief get the cache range(in number of tiles)\n  static int getCacheRange() { return LidarMap::cache_range_; }\n\n  /// @brief get the watermark of tile cache\n  static int getCacheMargin() { return LidarMap::cache_margin_; }\n\n  /// @brief implimention of LidarMap::initializeLayer, see LidarMap for more infomation\n  bool initializeLayer(int layer_id) override;\n\n  /// @brief initialize a layer by specify type_name, grid_size and tile\n  /// @return the layer_id of the initilized layer, if failed, a negtive number will be returned\n  int initializeLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief implimention of LidarMap::addPointCloud, see LidarMap for more infomation\n  bool addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) override;\n\n  /// @brief load the map to cache\n  /// @param[in] pos the center of the region to be loaded\n  /// @return true on succeed, else false\n  bool load(const Eigen::Vector3f& pos);\n\n  /// @brief Get the map of a layer in specific region\n  ///\n  /// @param layer_id[in] specify which layer to get\n  /// @param[in] scope specifies the submap region.\n  /// @param[in] blocking if is true, this call will block if cache miss happens,\n  /// until tiles are loaded or timeout\n  /// @param[out] ndt3 stores the map we got\n  ///\n  /// @return true on succeed, else false. we may fails when there is a cache miss\n  /// in blocking mode\n  bool getMap(int layer_id, const MapScope& scope, bool blocking,\n              std::shared_ptr<Ndt3Interface>* ndt3);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @param layer_item[in] a layer item contains nessecery infomation\n  /// to add one layer\n  ///\n  /// @return true on succeed, else false\n  bool addLayer(const proto::config::MapLayerItem& layer_item);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @return the layer id of the layer we add\n  int addLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief save the map into database\n  ///\n  /// @return true on succeed, else false\n  bool save();\n\n  /// @brief get one maplayer\n  ///\n  /// @param layer_id[in] specify which layer to get\n  ///\n  /// @return a const ref of maplayer\n  std::shared_ptr<const MapLayer> getLayer(int layer_id);\n\n  /// @brief get one maplayer\n  ///\n  /// @param type_name[in] such as ndt3_corner...\n  ///\n  /// @return a const ref of mapl\n  std::shared_ptr<const MapLayer> getLayer(const std::string& type_name, float grid_size, float tile_size);\n\n private:\n  static std::shared_ptr<LocalDatabase> database_;\n  static LocalDatabase::MODE database_operation_mode_;\n  static proto::map::MapInfo map_info_;\n\n  std::map<int, std::shared_ptr<MapLayer>> layers_;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h"
		}
	}
]
I0402 15:57:22.269835  6725 json_parser.cpp:18] 
[
	21,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/eigen_types.h\"\n\n#include \"common/proto/config/config_map.pb.h\"\n\n#include \"lidar_map.h\"\n#include \"local_database.h\"\n#include \"map_layer.h\"\n#include \"map_scope.h\"\n#include \"ndt3interface.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass LidarMapOffline : public LidarMap {\n public:\n  /// @brief configure the LidarMapOffline class, mainly static members\n  /// which shared by all LidarMapOffline instance, such as database\n  ///\n  /// @param mode[in] specify the database operation mode, read, write, create...\n  ///\n  /// @note this should be called first before any operation about\n  /// LidarMapOffline\n  static bool configure(LocalDatabase::MODE mode);\n\n  /// @brief get the cache range(in number of tiles)\n  static int getCacheRange() { return LidarMap::cache_range_; }\n\n  /// @brief get the watermark of tile cache\n  static int getCacheMargin() { return LidarMap::cache_margin_; }\n\n  /// @brief implimention of LidarMap::initializeLayer, see LidarMap for more infomation\n  bool initializeLayer(int layer_id) override;\n\n  /// @brief initialize a layer by specify type_name, grid_size and tile\n  /// @return the layer_id of the initilized layer, if failed, a negtive number will be returned\n  int initializeLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief implimention of LidarMap::addPointCloud, see LidarMap for more infomation\n  bool addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) override;\n\n  /// @brief load the map to cache\n  /// @param[in] pos the center of the region to be loaded\n  /// @return true on succeed, else false\n  bool load(const Eigen::Vector3f& pos);\n\n  /// @brief Get the map of a layer in specific region\n  ///\n  /// @param layer_id[in] specify which layer to get\n  /// @param[in] scope specifies the submap region.\n  /// @param[in] blocking if is true, this call will block if cache miss happens,\n  /// until tiles are loaded or timeout\n  /// @param[out] ndt3 stores the map we got\n  ///\n  /// @return true on succeed, else false. we may fails when there is a cache miss\n  /// in blocking mode\n  bool getMap(int layer_id, const MapScope& scope, bool blocking,\n              std::shared_ptr<Ndt3Interface>* ndt3);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @param layer_item[in] a layer item contains nessecery infomation\n  /// to add one layer\n  ///\n  /// @return true on succeed, else false\n  bool addLayer(const proto::config::MapLayerItem& layer_item);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @return the layer id of the layer we add\n  int addLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief save the map into database\n  ///\n  /// @return true on succeed, else false\n  bool save();\n\n  /// @brief get one maplayer\n  ///\n  /// @param layer_id[in] specify which layer to get\n  ///\n  /// @return a const ref of maplayer\n  std::shared_ptr<const MapLayer> getLayer(int layer_id);\n\n  /// @brief get one maplayer\n  ///\n  /// @param type_name[in] such as ndt3_corner...\n  ///\n  /// @return a const ref of map\n  std::shared_ptr<const MapLayer> getLayer(const std::string& type_name, float grid_size, float tile_size);\n\n private:\n  static std::shared_ptr<LocalDatabase> database_;\n  static LocalDatabase::MODE database_operation_mode_;\n  static proto::map::MapInfo map_info_;\n\n  std::map<int, std::shared_ptr<MapLayer>> layers_;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h"
		}
	}
]
I0402 15:57:22.314846  6725 json_parser.cpp:18] 
[
	22,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/eigen_types.h\"\n\n#include \"common/proto/config/config_map.pb.h\"\n\n#include \"lidar_map.h\"\n#include \"local_database.h\"\n#include \"map_layer.h\"\n#include \"map_scope.h\"\n#include \"ndt3interface.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass LidarMapOffline : public LidarMap {\n public:\n  /// @brief configure the LidarMapOffline class, mainly static members\n  /// which shared by all LidarMapOffline instance, such as database\n  ///\n  /// @param mode[in] specify the database operation mode, read, write, create...\n  ///\n  /// @note this should be called first before any operation about\n  /// LidarMapOffline\n  static bool configure(LocalDatabase::MODE mode);\n\n  /// @brief get the cache range(in number of tiles)\n  static int getCacheRange() { return LidarMap::cache_range_; }\n\n  /// @brief get the watermark of tile cache\n  static int getCacheMargin() { return LidarMap::cache_margin_; }\n\n  /// @brief implimention of LidarMap::initializeLayer, see LidarMap for more infomation\n  bool initializeLayer(int layer_id) override;\n\n  /// @brief initialize a layer by specify type_name, grid_size and tile\n  /// @return the layer_id of the initilized layer, if failed, a negtive number will be returned\n  int initializeLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief implimention of LidarMap::addPointCloud, see LidarMap for more infomation\n  bool addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) override;\n\n  /// @brief load the map to cache\n  /// @param[in] pos the center of the region to be loaded\n  /// @return true on succeed, else false\n  bool load(const Eigen::Vector3f& pos);\n\n  /// @brief Get the map of a layer in specific region\n  ///\n  /// @param layer_id[in] specify which layer to get\n  /// @param[in] scope specifies the submap region.\n  /// @param[in] blocking if is true, this call will block if cache miss happens,\n  /// until tiles are loaded or timeout\n  /// @param[out] ndt3 stores the map we got\n  ///\n  /// @return true on succeed, else false. we may fails when there is a cache miss\n  /// in blocking mode\n  bool getMap(int layer_id, const MapScope& scope, bool blocking,\n              std::shared_ptr<Ndt3Interface>* ndt3);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @param layer_item[in] a layer item contains nessecery infomation\n  /// to add one layer\n  ///\n  /// @return true on succeed, else false\n  bool addLayer(const proto::config::MapLayerItem& layer_item);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @return the layer id of the layer we add\n  int addLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief save the map into database\n  ///\n  /// @return true on succeed, else false\n  bool save();\n\n  /// @brief get one maplayer\n  ///\n  /// @param layer_id[in] specify which layer to get\n  ///\n  /// @return a const ref of maplayer\n  std::shared_ptr<const MapLayer> getLayer(int layer_id);\n\n  /// @brief get one maplayer\n  ///\n  /// @param type_name[in] such as ndt3_corner...\n  ///\n  /// @return a const ref of ma\n  std::shared_ptr<const MapLayer> getLayer(const std::string& type_name, float grid_size, float tile_size);\n\n private:\n  static std::shared_ptr<LocalDatabase> database_;\n  static LocalDatabase::MODE database_operation_mode_;\n  static proto::map::MapInfo map_info_;\n\n  std::map<int, std::shared_ptr<MapLayer>> layers_;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h"
		}
	}
]
I0402 15:57:22.350360  6725 json_parser.cpp:18] 
[
	23,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/eigen_types.h\"\n\n#include \"common/proto/config/config_map.pb.h\"\n\n#include \"lidar_map.h\"\n#include \"local_database.h\"\n#include \"map_layer.h\"\n#include \"map_scope.h\"\n#include \"ndt3interface.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass LidarMapOffline : public LidarMap {\n public:\n  /// @brief configure the LidarMapOffline class, mainly static members\n  /// which shared by all LidarMapOffline instance, such as database\n  ///\n  /// @param mode[in] specify the database operation mode, read, write, create...\n  ///\n  /// @note this should be called first before any operation about\n  /// LidarMapOffline\n  static bool configure(LocalDatabase::MODE mode);\n\n  /// @brief get the cache range(in number of tiles)\n  static int getCacheRange() { return LidarMap::cache_range_; }\n\n  /// @brief get the watermark of tile cache\n  static int getCacheMargin() { return LidarMap::cache_margin_; }\n\n  /// @brief implimention of LidarMap::initializeLayer, see LidarMap for more infomation\n  bool initializeLayer(int layer_id) override;\n\n  /// @brief initialize a layer by specify type_name, grid_size and tile\n  /// @return the layer_id of the initilized layer, if failed, a negtive number will be returned\n  int initializeLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief implimention of LidarMap::addPointCloud, see LidarMap for more infomation\n  bool addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) override;\n\n  /// @brief load the map to cache\n  /// @param[in] pos the center of the region to be loaded\n  /// @return true on succeed, else false\n  bool load(const Eigen::Vector3f& pos);\n\n  /// @brief Get the map of a layer in specific region\n  ///\n  /// @param layer_id[in] specify which layer to get\n  /// @param[in] scope specifies the submap region.\n  /// @param[in] blocking if is true, this call will block if cache miss happens,\n  /// until tiles are loaded or timeout\n  /// @param[out] ndt3 stores the map we got\n  ///\n  /// @return true on succeed, else false. we may fails when there is a cache miss\n  /// in blocking mode\n  bool getMap(int layer_id, const MapScope& scope, bool blocking,\n              std::shared_ptr<Ndt3Interface>* ndt3);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @param layer_item[in] a layer item contains nessecery infomation\n  /// to add one layer\n  ///\n  /// @return true on succeed, else false\n  bool addLayer(const proto::config::MapLayerItem& layer_item);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @return the layer id of the layer we add\n  int addLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief save the map into database\n  ///\n  /// @return true on succeed, else false\n  bool save();\n\n  /// @brief get one maplayer\n  ///\n  /// @param layer_id[in] specify which layer to get\n  ///\n  /// @return a const ref of maplayer\n  std::shared_ptr<const MapLayer> getLayer(int layer_id);\n\n  /// @brief get one maplayer\n  ///\n  /// @param type_name[in] such as ndt3_corner...\n  ///\n  /// @return a const ref of m\n  std::shared_ptr<const MapLayer> getLayer(const std::string& type_name, float grid_size, float tile_size);\n\n private:\n  static std::shared_ptr<LocalDatabase> database_;\n  static LocalDatabase::MODE database_operation_mode_;\n  static proto::map::MapInfo map_info_;\n\n  std::map<int, std::shared_ptr<MapLayer>> layers_;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h"
		}
	}
]
I0402 15:57:22.389884  6725 json_parser.cpp:18] 
[
	24,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/eigen_types.h\"\n\n#include \"common/proto/config/config_map.pb.h\"\n\n#include \"lidar_map.h\"\n#include \"local_database.h\"\n#include \"map_layer.h\"\n#include \"map_scope.h\"\n#include \"ndt3interface.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass LidarMapOffline : public LidarMap {\n public:\n  /// @brief configure the LidarMapOffline class, mainly static members\n  /// which shared by all LidarMapOffline instance, such as database\n  ///\n  /// @param mode[in] specify the database operation mode, read, write, create...\n  ///\n  /// @note this should be called first before any operation about\n  /// LidarMapOffline\n  static bool configure(LocalDatabase::MODE mode);\n\n  /// @brief get the cache range(in number of tiles)\n  static int getCacheRange() { return LidarMap::cache_range_; }\n\n  /// @brief get the watermark of tile cache\n  static int getCacheMargin() { return LidarMap::cache_margin_; }\n\n  /// @brief implimention of LidarMap::initializeLayer, see LidarMap for more infomation\n  bool initializeLayer(int layer_id) override;\n\n  /// @brief initialize a layer by specify type_name, grid_size and tile\n  /// @return the layer_id of the initilized layer, if failed, a negtive number will be returned\n  int initializeLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief implimention of LidarMap::addPointCloud, see LidarMap for more infomation\n  bool addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) override;\n\n  /// @brief load the map to cache\n  /// @param[in] pos the center of the region to be loaded\n  /// @return true on succeed, else false\n  bool load(const Eigen::Vector3f& pos);\n\n  /// @brief Get the map of a layer in specific region\n  ///\n  /// @param layer_id[in] specify which layer to get\n  /// @param[in] scope specifies the submap region.\n  /// @param[in] blocking if is true, this call will block if cache miss happens,\n  /// until tiles are loaded or timeout\n  /// @param[out] ndt3 stores the map we got\n  ///\n  /// @return true on succeed, else false. we may fails when there is a cache miss\n  /// in blocking mode\n  bool getMap(int layer_id, const MapScope& scope, bool blocking,\n              std::shared_ptr<Ndt3Interface>* ndt3);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @param layer_item[in] a layer item contains nessecery infomation\n  /// to add one layer\n  ///\n  /// @return true on succeed, else false\n  bool addLayer(const proto::config::MapLayerItem& layer_item);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @return the layer id of the layer we add\n  int addLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief save the map into database\n  ///\n  /// @return true on succeed, else false\n  bool save();\n\n  /// @brief get one maplayer\n  ///\n  /// @param layer_id[in] specify which layer to get\n  ///\n  /// @return a const ref of maplayer\n  std::shared_ptr<const MapLayer> getLayer(int layer_id);\n\n  /// @brief get one maplayer\n  ///\n  /// @param type_name[in] such as ndt3_corner...\n  ///\n  /// @return a const ref of \n  std::shared_ptr<const MapLayer> getLayer(const std::string& type_name, float grid_size, float tile_size);\n\n private:\n  static std::shared_ptr<LocalDatabase> database_;\n  static LocalDatabase::MODE database_operation_mode_;\n  static proto::map::MapInfo map_info_;\n\n  std::map<int, std::shared_ptr<MapLayer>> layers_;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h"
		}
	}
]
I0402 15:57:22.430588  6725 json_parser.cpp:18] 
[
	25,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/eigen_types.h\"\n\n#include \"common/proto/config/config_map.pb.h\"\n\n#include \"lidar_map.h\"\n#include \"local_database.h\"\n#include \"map_layer.h\"\n#include \"map_scope.h\"\n#include \"ndt3interface.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass LidarMapOffline : public LidarMap {\n public:\n  /// @brief configure the LidarMapOffline class, mainly static members\n  /// which shared by all LidarMapOffline instance, such as database\n  ///\n  /// @param mode[in] specify the database operation mode, read, write, create...\n  ///\n  /// @note this should be called first before any operation about\n  /// LidarMapOffline\n  static bool configure(LocalDatabase::MODE mode);\n\n  /// @brief get the cache range(in number of tiles)\n  static int getCacheRange() { return LidarMap::cache_range_; }\n\n  /// @brief get the watermark of tile cache\n  static int getCacheMargin() { return LidarMap::cache_margin_; }\n\n  /// @brief implimention of LidarMap::initializeLayer, see LidarMap for more infomation\n  bool initializeLayer(int layer_id) override;\n\n  /// @brief initialize a layer by specify type_name, grid_size and tile\n  /// @return the layer_id of the initilized layer, if failed, a negtive number will be returned\n  int initializeLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief implimention of LidarMap::addPointCloud, see LidarMap for more infomation\n  bool addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) override;\n\n  /// @brief load the map to cache\n  /// @param[in] pos the center of the region to be loaded\n  /// @return true on succeed, else false\n  bool load(const Eigen::Vector3f& pos);\n\n  /// @brief Get the map of a layer in specific region\n  ///\n  /// @param layer_id[in] specify which layer to get\n  /// @param[in] scope specifies the submap region.\n  /// @param[in] blocking if is true, this call will block if cache miss happens,\n  /// until tiles are loaded or timeout\n  /// @param[out] ndt3 stores the map we got\n  ///\n  /// @return true on succeed, else false. we may fails when there is a cache miss\n  /// in blocking mode\n  bool getMap(int layer_id, const MapScope& scope, bool blocking,\n              std::shared_ptr<Ndt3Interface>* ndt3);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @param layer_item[in] a layer item contains nessecery infomation\n  /// to add one layer\n  ///\n  /// @return true on succeed, else false\n  bool addLayer(const proto::config::MapLayerItem& layer_item);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @return the layer id of the layer we add\n  int addLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief save the map into database\n  ///\n  /// @return true on succeed, else false\n  bool save();\n\n  /// @brief get one maplayer\n  ///\n  /// @param layer_id[in] specify which layer to get\n  ///\n  /// @return a const ref of maplayer\n  std::shared_ptr<const MapLayer> getLayer(int layer_id);\n\n  /// @brief get one maplayer\n  ///\n  /// @param type_name[in] such as ndt3_corner...\n  ///\n  /// @return a const ref of\n  std::shared_ptr<const MapLayer> getLayer(const std::string& type_name, float grid_size, float tile_size);\n\n private:\n  static std::shared_ptr<LocalDatabase> database_;\n  static LocalDatabase::MODE database_operation_mode_;\n  static proto::map::MapInfo map_info_;\n\n  std::map<int, std::shared_ptr<MapLayer>> layers_;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h"
		}
	}
]
I0402 15:57:22.470971  6725 json_parser.cpp:18] 
[
	26,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/eigen_types.h\"\n\n#include \"common/proto/config/config_map.pb.h\"\n\n#include \"lidar_map.h\"\n#include \"local_database.h\"\n#include \"map_layer.h\"\n#include \"map_scope.h\"\n#include \"ndt3interface.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass LidarMapOffline : public LidarMap {\n public:\n  /// @brief configure the LidarMapOffline class, mainly static members\n  /// which shared by all LidarMapOffline instance, such as database\n  ///\n  /// @param mode[in] specify the database operation mode, read, write, create...\n  ///\n  /// @note this should be called first before any operation about\n  /// LidarMapOffline\n  static bool configure(LocalDatabase::MODE mode);\n\n  /// @brief get the cache range(in number of tiles)\n  static int getCacheRange() { return LidarMap::cache_range_; }\n\n  /// @brief get the watermark of tile cache\n  static int getCacheMargin() { return LidarMap::cache_margin_; }\n\n  /// @brief implimention of LidarMap::initializeLayer, see LidarMap for more infomation\n  bool initializeLayer(int layer_id) override;\n\n  /// @brief initialize a layer by specify type_name, grid_size and tile\n  /// @return the layer_id of the initilized layer, if failed, a negtive number will be returned\n  int initializeLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief implimention of LidarMap::addPointCloud, see LidarMap for more infomation\n  bool addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) override;\n\n  /// @brief load the map to cache\n  /// @param[in] pos the center of the region to be loaded\n  /// @return true on succeed, else false\n  bool load(const Eigen::Vector3f& pos);\n\n  /// @brief Get the map of a layer in specific region\n  ///\n  /// @param layer_id[in] specify which layer to get\n  /// @param[in] scope specifies the submap region.\n  /// @param[in] blocking if is true, this call will block if cache miss happens,\n  /// until tiles are loaded or timeout\n  /// @param[out] ndt3 stores the map we got\n  ///\n  /// @return true on succeed, else false. we may fails when there is a cache miss\n  /// in blocking mode\n  bool getMap(int layer_id, const MapScope& scope, bool blocking,\n              std::shared_ptr<Ndt3Interface>* ndt3);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @param layer_item[in] a layer item contains nessecery infomation\n  /// to add one layer\n  ///\n  /// @return true on succeed, else false\n  bool addLayer(const proto::config::MapLayerItem& layer_item);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @return the layer id of the layer we add\n  int addLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief save the map into database\n  ///\n  /// @return true on succeed, else false\n  bool save();\n\n  /// @brief get one maplayer\n  ///\n  /// @param layer_id[in] specify which layer to get\n  ///\n  /// @return a const ref of maplayer\n  std::shared_ptr<const MapLayer> getLayer(int layer_id);\n\n  /// @brief get one maplayer\n  ///\n  /// @param type_name[in] such as ndt3_corner...\n  ///\n  /// @return a const ref o\n  std::shared_ptr<const MapLayer> getLayer(const std::string& type_name, float grid_size, float tile_size);\n\n private:\n  static std::shared_ptr<LocalDatabase> database_;\n  static LocalDatabase::MODE database_operation_mode_;\n  static proto::map::MapInfo map_info_;\n\n  std::map<int, std::shared_ptr<MapLayer>> layers_;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h"
		}
	}
]
I0402 15:57:22.510488  6725 json_parser.cpp:18] 
[
	27,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/eigen_types.h\"\n\n#include \"common/proto/config/config_map.pb.h\"\n\n#include \"lidar_map.h\"\n#include \"local_database.h\"\n#include \"map_layer.h\"\n#include \"map_scope.h\"\n#include \"ndt3interface.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass LidarMapOffline : public LidarMap {\n public:\n  /// @brief configure the LidarMapOffline class, mainly static members\n  /// which shared by all LidarMapOffline instance, such as database\n  ///\n  /// @param mode[in] specify the database operation mode, read, write, create...\n  ///\n  /// @note this should be called first before any operation about\n  /// LidarMapOffline\n  static bool configure(LocalDatabase::MODE mode);\n\n  /// @brief get the cache range(in number of tiles)\n  static int getCacheRange() { return LidarMap::cache_range_; }\n\n  /// @brief get the watermark of tile cache\n  static int getCacheMargin() { return LidarMap::cache_margin_; }\n\n  /// @brief implimention of LidarMap::initializeLayer, see LidarMap for more infomation\n  bool initializeLayer(int layer_id) override;\n\n  /// @brief initialize a layer by specify type_name, grid_size and tile\n  /// @return the layer_id of the initilized layer, if failed, a negtive number will be returned\n  int initializeLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief implimention of LidarMap::addPointCloud, see LidarMap for more infomation\n  bool addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) override;\n\n  /// @brief load the map to cache\n  /// @param[in] pos the center of the region to be loaded\n  /// @return true on succeed, else false\n  bool load(const Eigen::Vector3f& pos);\n\n  /// @brief Get the map of a layer in specific region\n  ///\n  /// @param layer_id[in] specify which layer to get\n  /// @param[in] scope specifies the submap region.\n  /// @param[in] blocking if is true, this call will block if cache miss happens,\n  /// until tiles are loaded or timeout\n  /// @param[out] ndt3 stores the map we got\n  ///\n  /// @return true on succeed, else false. we may fails when there is a cache miss\n  /// in blocking mode\n  bool getMap(int layer_id, const MapScope& scope, bool blocking,\n              std::shared_ptr<Ndt3Interface>* ndt3);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @param layer_item[in] a layer item contains nessecery infomation\n  /// to add one layer\n  ///\n  /// @return true on succeed, else false\n  bool addLayer(const proto::config::MapLayerItem& layer_item);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @return the layer id of the layer we add\n  int addLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief save the map into database\n  ///\n  /// @return true on succeed, else false\n  bool save();\n\n  /// @brief get one maplayer\n  ///\n  /// @param layer_id[in] specify which layer to get\n  ///\n  /// @return a const ref of maplayer\n  std::shared_ptr<const MapLayer> getLayer(int layer_id);\n\n  /// @brief get one maplayer\n  ///\n  /// @param type_name[in] such as ndt3_corner...\n  ///\n  /// @return a const ref \n  std::shared_ptr<const MapLayer> getLayer(const std::string& type_name, float grid_size, float tile_size);\n\n private:\n  static std::shared_ptr<LocalDatabase> database_;\n  static LocalDatabase::MODE database_operation_mode_;\n  static proto::map::MapInfo map_info_;\n\n  std::map<int, std::shared_ptr<MapLayer>> layers_;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h"
		}
	}
]
I0402 15:57:22.550861  6725 json_parser.cpp:18] 
[
	28,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/eigen_types.h\"\n\n#include \"common/proto/config/config_map.pb.h\"\n\n#include \"lidar_map.h\"\n#include \"local_database.h\"\n#include \"map_layer.h\"\n#include \"map_scope.h\"\n#include \"ndt3interface.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass LidarMapOffline : public LidarMap {\n public:\n  /// @brief configure the LidarMapOffline class, mainly static members\n  /// which shared by all LidarMapOffline instance, such as database\n  ///\n  /// @param mode[in] specify the database operation mode, read, write, create...\n  ///\n  /// @note this should be called first before any operation about\n  /// LidarMapOffline\n  static bool configure(LocalDatabase::MODE mode);\n\n  /// @brief get the cache range(in number of tiles)\n  static int getCacheRange() { return LidarMap::cache_range_; }\n\n  /// @brief get the watermark of tile cache\n  static int getCacheMargin() { return LidarMap::cache_margin_; }\n\n  /// @brief implimention of LidarMap::initializeLayer, see LidarMap for more infomation\n  bool initializeLayer(int layer_id) override;\n\n  /// @brief initialize a layer by specify type_name, grid_size and tile\n  /// @return the layer_id of the initilized layer, if failed, a negtive number will be returned\n  int initializeLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief implimention of LidarMap::addPointCloud, see LidarMap for more infomation\n  bool addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) override;\n\n  /// @brief load the map to cache\n  /// @param[in] pos the center of the region to be loaded\n  /// @return true on succeed, else false\n  bool load(const Eigen::Vector3f& pos);\n\n  /// @brief Get the map of a layer in specific region\n  ///\n  /// @param layer_id[in] specify which layer to get\n  /// @param[in] scope specifies the submap region.\n  /// @param[in] blocking if is true, this call will block if cache miss happens,\n  /// until tiles are loaded or timeout\n  /// @param[out] ndt3 stores the map we got\n  ///\n  /// @return true on succeed, else false. we may fails when there is a cache miss\n  /// in blocking mode\n  bool getMap(int layer_id, const MapScope& scope, bool blocking,\n              std::shared_ptr<Ndt3Interface>* ndt3);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @param layer_item[in] a layer item contains nessecery infomation\n  /// to add one layer\n  ///\n  /// @return true on succeed, else false\n  bool addLayer(const proto::config::MapLayerItem& layer_item);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @return the layer id of the layer we add\n  int addLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief save the map into database\n  ///\n  /// @return true on succeed, else false\n  bool save();\n\n  /// @brief get one maplayer\n  ///\n  /// @param layer_id[in] specify which layer to get\n  ///\n  /// @return a const ref of maplayer\n  std::shared_ptr<const MapLayer> getLayer(int layer_id);\n\n  /// @brief get one maplayer\n  ///\n  /// @param type_name[in] such as ndt3_corner...\n  ///\n  /// @return a const ref\n  std::shared_ptr<const MapLayer> getLayer(const std::string& type_name, float grid_size, float tile_size);\n\n private:\n  static std::shared_ptr<LocalDatabase> database_;\n  static LocalDatabase::MODE database_operation_mode_;\n  static proto::map::MapInfo map_info_;\n\n  std::map<int, std::shared_ptr<MapLayer>> layers_;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h"
		}
	}
]
I0402 15:57:22.591168  6725 json_parser.cpp:18] 
[
	29,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/eigen_types.h\"\n\n#include \"common/proto/config/config_map.pb.h\"\n\n#include \"lidar_map.h\"\n#include \"local_database.h\"\n#include \"map_layer.h\"\n#include \"map_scope.h\"\n#include \"ndt3interface.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass LidarMapOffline : public LidarMap {\n public:\n  /// @brief configure the LidarMapOffline class, mainly static members\n  /// which shared by all LidarMapOffline instance, such as database\n  ///\n  /// @param mode[in] specify the database operation mode, read, write, create...\n  ///\n  /// @note this should be called first before any operation about\n  /// LidarMapOffline\n  static bool configure(LocalDatabase::MODE mode);\n\n  /// @brief get the cache range(in number of tiles)\n  static int getCacheRange() { return LidarMap::cache_range_; }\n\n  /// @brief get the watermark of tile cache\n  static int getCacheMargin() { return LidarMap::cache_margin_; }\n\n  /// @brief implimention of LidarMap::initializeLayer, see LidarMap for more infomation\n  bool initializeLayer(int layer_id) override;\n\n  /// @brief initialize a layer by specify type_name, grid_size and tile\n  /// @return the layer_id of the initilized layer, if failed, a negtive number will be returned\n  int initializeLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief implimention of LidarMap::addPointCloud, see LidarMap for more infomation\n  bool addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) override;\n\n  /// @brief load the map to cache\n  /// @param[in] pos the center of the region to be loaded\n  /// @return true on succeed, else false\n  bool load(const Eigen::Vector3f& pos);\n\n  /// @brief Get the map of a layer in specific region\n  ///\n  /// @param layer_id[in] specify which layer to get\n  /// @param[in] scope specifies the submap region.\n  /// @param[in] blocking if is true, this call will block if cache miss happens,\n  /// until tiles are loaded or timeout\n  /// @param[out] ndt3 stores the map we got\n  ///\n  /// @return true on succeed, else false. we may fails when there is a cache miss\n  /// in blocking mode\n  bool getMap(int layer_id, const MapScope& scope, bool blocking,\n              std::shared_ptr<Ndt3Interface>* ndt3);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @param layer_item[in] a layer item contains nessecery infomation\n  /// to add one layer\n  ///\n  /// @return true on succeed, else false\n  bool addLayer(const proto::config::MapLayerItem& layer_item);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @return the layer id of the layer we add\n  int addLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief save the map into database\n  ///\n  /// @return true on succeed, else false\n  bool save();\n\n  /// @brief get one maplayer\n  ///\n  /// @param layer_id[in] specify which layer to get\n  ///\n  /// @return a const ref of maplayer\n  std::shared_ptr<const MapLayer> getLayer(int layer_id);\n\n  /// @brief get one maplayer\n  ///\n  /// @param type_name[in] such as ndt3_corner...\n  ///\n  /// @return a const re\n  std::shared_ptr<const MapLayer> getLayer(const std::string& type_name, float grid_size, float tile_size);\n\n private:\n  static std::shared_ptr<LocalDatabase> database_;\n  static LocalDatabase::MODE database_operation_mode_;\n  static proto::map::MapInfo map_info_;\n\n  std::map<int, std::shared_ptr<MapLayer>> layers_;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h"
		}
	}
]
I0402 15:57:22.630995  6725 json_parser.cpp:18] 
[
	30,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/eigen_types.h\"\n\n#include \"common/proto/config/config_map.pb.h\"\n\n#include \"lidar_map.h\"\n#include \"local_database.h\"\n#include \"map_layer.h\"\n#include \"map_scope.h\"\n#include \"ndt3interface.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass LidarMapOffline : public LidarMap {\n public:\n  /// @brief configure the LidarMapOffline class, mainly static members\n  /// which shared by all LidarMapOffline instance, such as database\n  ///\n  /// @param mode[in] specify the database operation mode, read, write, create...\n  ///\n  /// @note this should be called first before any operation about\n  /// LidarMapOffline\n  static bool configure(LocalDatabase::MODE mode);\n\n  /// @brief get the cache range(in number of tiles)\n  static int getCacheRange() { return LidarMap::cache_range_; }\n\n  /// @brief get the watermark of tile cache\n  static int getCacheMargin() { return LidarMap::cache_margin_; }\n\n  /// @brief implimention of LidarMap::initializeLayer, see LidarMap for more infomation\n  bool initializeLayer(int layer_id) override;\n\n  /// @brief initialize a layer by specify type_name, grid_size and tile\n  /// @return the layer_id of the initilized layer, if failed, a negtive number will be returned\n  int initializeLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief implimention of LidarMap::addPointCloud, see LidarMap for more infomation\n  bool addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) override;\n\n  /// @brief load the map to cache\n  /// @param[in] pos the center of the region to be loaded\n  /// @return true on succeed, else false\n  bool load(const Eigen::Vector3f& pos);\n\n  /// @brief Get the map of a layer in specific region\n  ///\n  /// @param layer_id[in] specify which layer to get\n  /// @param[in] scope specifies the submap region.\n  /// @param[in] blocking if is true, this call will block if cache miss happens,\n  /// until tiles are loaded or timeout\n  /// @param[out] ndt3 stores the map we got\n  ///\n  /// @return true on succeed, else false. we may fails when there is a cache miss\n  /// in blocking mode\n  bool getMap(int layer_id, const MapScope& scope, bool blocking,\n              std::shared_ptr<Ndt3Interface>* ndt3);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @param layer_item[in] a layer item contains nessecery infomation\n  /// to add one layer\n  ///\n  /// @return true on succeed, else false\n  bool addLayer(const proto::config::MapLayerItem& layer_item);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @return the layer id of the layer we add\n  int addLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief save the map into database\n  ///\n  /// @return true on succeed, else false\n  bool save();\n\n  /// @brief get one maplayer\n  ///\n  /// @param layer_id[in] specify which layer to get\n  ///\n  /// @return a const ref of maplayer\n  std::shared_ptr<const MapLayer> getLayer(int layer_id);\n\n  /// @brief get one maplayer\n  ///\n  /// @param type_name[in] such as ndt3_corner...\n  ///\n  /// @return a const r\n  std::shared_ptr<const MapLayer> getLayer(const std::string& type_name, float grid_size, float tile_size);\n\n private:\n  static std::shared_ptr<LocalDatabase> database_;\n  static LocalDatabase::MODE database_operation_mode_;\n  static proto::map::MapInfo map_info_;\n\n  std::map<int, std::shared_ptr<MapLayer>> layers_;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h"
		}
	}
]
I0402 15:57:22.670346  6725 json_parser.cpp:18] 
[
	31,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/eigen_types.h\"\n\n#include \"common/proto/config/config_map.pb.h\"\n\n#include \"lidar_map.h\"\n#include \"local_database.h\"\n#include \"map_layer.h\"\n#include \"map_scope.h\"\n#include \"ndt3interface.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass LidarMapOffline : public LidarMap {\n public:\n  /// @brief configure the LidarMapOffline class, mainly static members\n  /// which shared by all LidarMapOffline instance, such as database\n  ///\n  /// @param mode[in] specify the database operation mode, read, write, create...\n  ///\n  /// @note this should be called first before any operation about\n  /// LidarMapOffline\n  static bool configure(LocalDatabase::MODE mode);\n\n  /// @brief get the cache range(in number of tiles)\n  static int getCacheRange() { return LidarMap::cache_range_; }\n\n  /// @brief get the watermark of tile cache\n  static int getCacheMargin() { return LidarMap::cache_margin_; }\n\n  /// @brief implimention of LidarMap::initializeLayer, see LidarMap for more infomation\n  bool initializeLayer(int layer_id) override;\n\n  /// @brief initialize a layer by specify type_name, grid_size and tile\n  /// @return the layer_id of the initilized layer, if failed, a negtive number will be returned\n  int initializeLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief implimention of LidarMap::addPointCloud, see LidarMap for more infomation\n  bool addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) override;\n\n  /// @brief load the map to cache\n  /// @param[in] pos the center of the region to be loaded\n  /// @return true on succeed, else false\n  bool load(const Eigen::Vector3f& pos);\n\n  /// @brief Get the map of a layer in specific region\n  ///\n  /// @param layer_id[in] specify which layer to get\n  /// @param[in] scope specifies the submap region.\n  /// @param[in] blocking if is true, this call will block if cache miss happens,\n  /// until tiles are loaded or timeout\n  /// @param[out] ndt3 stores the map we got\n  ///\n  /// @return true on succeed, else false. we may fails when there is a cache miss\n  /// in blocking mode\n  bool getMap(int layer_id, const MapScope& scope, bool blocking,\n              std::shared_ptr<Ndt3Interface>* ndt3);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @param layer_item[in] a layer item contains nessecery infomation\n  /// to add one layer\n  ///\n  /// @return true on succeed, else false\n  bool addLayer(const proto::config::MapLayerItem& layer_item);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @return the layer id of the layer we add\n  int addLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief save the map into database\n  ///\n  /// @return true on succeed, else false\n  bool save();\n\n  /// @brief get one maplayer\n  ///\n  /// @param layer_id[in] specify which layer to get\n  ///\n  /// @return a const ref of maplayer\n  std::shared_ptr<const MapLayer> getLayer(int layer_id);\n\n  /// @brief get one maplayer\n  ///\n  /// @param type_name[in] such as ndt3_corner...\n  ///\n  /// @return a const \n  std::shared_ptr<const MapLayer> getLayer(const std::string& type_name, float grid_size, float tile_size);\n\n private:\n  static std::shared_ptr<LocalDatabase> database_;\n  static LocalDatabase::MODE database_operation_mode_;\n  static proto::map::MapInfo map_info_;\n\n  std::map<int, std::shared_ptr<MapLayer>> layers_;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h"
		}
	}
]
I0402 15:57:22.711194  6725 json_parser.cpp:18] 
[
	32,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/eigen_types.h\"\n\n#include \"common/proto/config/config_map.pb.h\"\n\n#include \"lidar_map.h\"\n#include \"local_database.h\"\n#include \"map_layer.h\"\n#include \"map_scope.h\"\n#include \"ndt3interface.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass LidarMapOffline : public LidarMap {\n public:\n  /// @brief configure the LidarMapOffline class, mainly static members\n  /// which shared by all LidarMapOffline instance, such as database\n  ///\n  /// @param mode[in] specify the database operation mode, read, write, create...\n  ///\n  /// @note this should be called first before any operation about\n  /// LidarMapOffline\n  static bool configure(LocalDatabase::MODE mode);\n\n  /// @brief get the cache range(in number of tiles)\n  static int getCacheRange() { return LidarMap::cache_range_; }\n\n  /// @brief get the watermark of tile cache\n  static int getCacheMargin() { return LidarMap::cache_margin_; }\n\n  /// @brief implimention of LidarMap::initializeLayer, see LidarMap for more infomation\n  bool initializeLayer(int layer_id) override;\n\n  /// @brief initialize a layer by specify type_name, grid_size and tile\n  /// @return the layer_id of the initilized layer, if failed, a negtive number will be returned\n  int initializeLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief implimention of LidarMap::addPointCloud, see LidarMap for more infomation\n  bool addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) override;\n\n  /// @brief load the map to cache\n  /// @param[in] pos the center of the region to be loaded\n  /// @return true on succeed, else false\n  bool load(const Eigen::Vector3f& pos);\n\n  /// @brief Get the map of a layer in specific region\n  ///\n  /// @param layer_id[in] specify which layer to get\n  /// @param[in] scope specifies the submap region.\n  /// @param[in] blocking if is true, this call will block if cache miss happens,\n  /// until tiles are loaded or timeout\n  /// @param[out] ndt3 stores the map we got\n  ///\n  /// @return true on succeed, else false. we may fails when there is a cache miss\n  /// in blocking mode\n  bool getMap(int layer_id, const MapScope& scope, bool blocking,\n              std::shared_ptr<Ndt3Interface>* ndt3);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @param layer_item[in] a layer item contains nessecery infomation\n  /// to add one layer\n  ///\n  /// @return true on succeed, else false\n  bool addLayer(const proto::config::MapLayerItem& layer_item);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @return the layer id of the layer we add\n  int addLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief save the map into database\n  ///\n  /// @return true on succeed, else false\n  bool save();\n\n  /// @brief get one maplayer\n  ///\n  /// @param layer_id[in] specify which layer to get\n  ///\n  /// @return a const ref of maplayer\n  std::shared_ptr<const MapLayer> getLayer(int layer_id);\n\n  /// @brief get one maplayer\n  ///\n  /// @param type_name[in] such as ndt3_corner...\n  ///\n  /// @return a const\n  std::shared_ptr<const MapLayer> getLayer(const std::string& type_name, float grid_size, float tile_size);\n\n private:\n  static std::shared_ptr<LocalDatabase> database_;\n  static LocalDatabase::MODE database_operation_mode_;\n  static proto::map::MapInfo map_info_;\n\n  std::map<int, std::shared_ptr<MapLayer>> layers_;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h"
		}
	}
]
I0402 15:57:22.751897  6725 json_parser.cpp:18] 
[
	33,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/eigen_types.h\"\n\n#include \"common/proto/config/config_map.pb.h\"\n\n#include \"lidar_map.h\"\n#include \"local_database.h\"\n#include \"map_layer.h\"\n#include \"map_scope.h\"\n#include \"ndt3interface.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass LidarMapOffline : public LidarMap {\n public:\n  /// @brief configure the LidarMapOffline class, mainly static members\n  /// which shared by all LidarMapOffline instance, such as database\n  ///\n  /// @param mode[in] specify the database operation mode, read, write, create...\n  ///\n  /// @note this should be called first before any operation about\n  /// LidarMapOffline\n  static bool configure(LocalDatabase::MODE mode);\n\n  /// @brief get the cache range(in number of tiles)\n  static int getCacheRange() { return LidarMap::cache_range_; }\n\n  /// @brief get the watermark of tile cache\n  static int getCacheMargin() { return LidarMap::cache_margin_; }\n\n  /// @brief implimention of LidarMap::initializeLayer, see LidarMap for more infomation\n  bool initializeLayer(int layer_id) override;\n\n  /// @brief initialize a layer by specify type_name, grid_size and tile\n  /// @return the layer_id of the initilized layer, if failed, a negtive number will be returned\n  int initializeLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief implimention of LidarMap::addPointCloud, see LidarMap for more infomation\n  bool addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) override;\n\n  /// @brief load the map to cache\n  /// @param[in] pos the center of the region to be loaded\n  /// @return true on succeed, else false\n  bool load(const Eigen::Vector3f& pos);\n\n  /// @brief Get the map of a layer in specific region\n  ///\n  /// @param layer_id[in] specify which layer to get\n  /// @param[in] scope specifies the submap region.\n  /// @param[in] blocking if is true, this call will block if cache miss happens,\n  /// until tiles are loaded or timeout\n  /// @param[out] ndt3 stores the map we got\n  ///\n  /// @return true on succeed, else false. we may fails when there is a cache miss\n  /// in blocking mode\n  bool getMap(int layer_id, const MapScope& scope, bool blocking,\n              std::shared_ptr<Ndt3Interface>* ndt3);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @param layer_item[in] a layer item contains nessecery infomation\n  /// to add one layer\n  ///\n  /// @return true on succeed, else false\n  bool addLayer(const proto::config::MapLayerItem& layer_item);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @return the layer id of the layer we add\n  int addLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief save the map into database\n  ///\n  /// @return true on succeed, else false\n  bool save();\n\n  /// @brief get one maplayer\n  ///\n  /// @param layer_id[in] specify which layer to get\n  ///\n  /// @return a const ref of maplayer\n  std::shared_ptr<const MapLayer> getLayer(int layer_id);\n\n  /// @brief get one maplayer\n  ///\n  /// @param type_name[in] such as ndt3_corner...\n  ///\n  /// @return a cons\n  std::shared_ptr<const MapLayer> getLayer(const std::string& type_name, float grid_size, float tile_size);\n\n private:\n  static std::shared_ptr<LocalDatabase> database_;\n  static LocalDatabase::MODE database_operation_mode_;\n  static proto::map::MapInfo map_info_;\n\n  std::map<int, std::shared_ptr<MapLayer>> layers_;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h"
		}
	}
]
I0402 15:57:22.792975  6725 json_parser.cpp:18] 
[
	34,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/eigen_types.h\"\n\n#include \"common/proto/config/config_map.pb.h\"\n\n#include \"lidar_map.h\"\n#include \"local_database.h\"\n#include \"map_layer.h\"\n#include \"map_scope.h\"\n#include \"ndt3interface.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass LidarMapOffline : public LidarMap {\n public:\n  /// @brief configure the LidarMapOffline class, mainly static members\n  /// which shared by all LidarMapOffline instance, such as database\n  ///\n  /// @param mode[in] specify the database operation mode, read, write, create...\n  ///\n  /// @note this should be called first before any operation about\n  /// LidarMapOffline\n  static bool configure(LocalDatabase::MODE mode);\n\n  /// @brief get the cache range(in number of tiles)\n  static int getCacheRange() { return LidarMap::cache_range_; }\n\n  /// @brief get the watermark of tile cache\n  static int getCacheMargin() { return LidarMap::cache_margin_; }\n\n  /// @brief implimention of LidarMap::initializeLayer, see LidarMap for more infomation\n  bool initializeLayer(int layer_id) override;\n\n  /// @brief initialize a layer by specify type_name, grid_size and tile\n  /// @return the layer_id of the initilized layer, if failed, a negtive number will be returned\n  int initializeLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief implimention of LidarMap::addPointCloud, see LidarMap for more infomation\n  bool addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) override;\n\n  /// @brief load the map to cache\n  /// @param[in] pos the center of the region to be loaded\n  /// @return true on succeed, else false\n  bool load(const Eigen::Vector3f& pos);\n\n  /// @brief Get the map of a layer in specific region\n  ///\n  /// @param layer_id[in] specify which layer to get\n  /// @param[in] scope specifies the submap region.\n  /// @param[in] blocking if is true, this call will block if cache miss happens,\n  /// until tiles are loaded or timeout\n  /// @param[out] ndt3 stores the map we got\n  ///\n  /// @return true on succeed, else false. we may fails when there is a cache miss\n  /// in blocking mode\n  bool getMap(int layer_id, const MapScope& scope, bool blocking,\n              std::shared_ptr<Ndt3Interface>* ndt3);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @param layer_item[in] a layer item contains nessecery infomation\n  /// to add one layer\n  ///\n  /// @return true on succeed, else false\n  bool addLayer(const proto::config::MapLayerItem& layer_item);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @return the layer id of the layer we add\n  int addLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief save the map into database\n  ///\n  /// @return true on succeed, else false\n  bool save();\n\n  /// @brief get one maplayer\n  ///\n  /// @param layer_id[in] specify which layer to get\n  ///\n  /// @return a const ref of maplayer\n  std::shared_ptr<const MapLayer> getLayer(int layer_id);\n\n  /// @brief get one maplayer\n  ///\n  /// @param type_name[in] such as ndt3_corner...\n  ///\n  /// @return a con\n  std::shared_ptr<const MapLayer> getLayer(const std::string& type_name, float grid_size, float tile_size);\n\n private:\n  static std::shared_ptr<LocalDatabase> database_;\n  static LocalDatabase::MODE database_operation_mode_;\n  static proto::map::MapInfo map_info_;\n\n  std::map<int, std::shared_ptr<MapLayer>> layers_;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h"
		}
	}
]
I0402 15:57:22.832969  6725 json_parser.cpp:18] 
[
	35,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/eigen_types.h\"\n\n#include \"common/proto/config/config_map.pb.h\"\n\n#include \"lidar_map.h\"\n#include \"local_database.h\"\n#include \"map_layer.h\"\n#include \"map_scope.h\"\n#include \"ndt3interface.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass LidarMapOffline : public LidarMap {\n public:\n  /// @brief configure the LidarMapOffline class, mainly static members\n  /// which shared by all LidarMapOffline instance, such as database\n  ///\n  /// @param mode[in] specify the database operation mode, read, write, create...\n  ///\n  /// @note this should be called first before any operation about\n  /// LidarMapOffline\n  static bool configure(LocalDatabase::MODE mode);\n\n  /// @brief get the cache range(in number of tiles)\n  static int getCacheRange() { return LidarMap::cache_range_; }\n\n  /// @brief get the watermark of tile cache\n  static int getCacheMargin() { return LidarMap::cache_margin_; }\n\n  /// @brief implimention of LidarMap::initializeLayer, see LidarMap for more infomation\n  bool initializeLayer(int layer_id) override;\n\n  /// @brief initialize a layer by specify type_name, grid_size and tile\n  /// @return the layer_id of the initilized layer, if failed, a negtive number will be returned\n  int initializeLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief implimention of LidarMap::addPointCloud, see LidarMap for more infomation\n  bool addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) override;\n\n  /// @brief load the map to cache\n  /// @param[in] pos the center of the region to be loaded\n  /// @return true on succeed, else false\n  bool load(const Eigen::Vector3f& pos);\n\n  /// @brief Get the map of a layer in specific region\n  ///\n  /// @param layer_id[in] specify which layer to get\n  /// @param[in] scope specifies the submap region.\n  /// @param[in] blocking if is true, this call will block if cache miss happens,\n  /// until tiles are loaded or timeout\n  /// @param[out] ndt3 stores the map we got\n  ///\n  /// @return true on succeed, else false. we may fails when there is a cache miss\n  /// in blocking mode\n  bool getMap(int layer_id, const MapScope& scope, bool blocking,\n              std::shared_ptr<Ndt3Interface>* ndt3);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @param layer_item[in] a layer item contains nessecery infomation\n  /// to add one layer\n  ///\n  /// @return true on succeed, else false\n  bool addLayer(const proto::config::MapLayerItem& layer_item);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @return the layer id of the layer we add\n  int addLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief save the map into database\n  ///\n  /// @return true on succeed, else false\n  bool save();\n\n  /// @brief get one maplayer\n  ///\n  /// @param layer_id[in] specify which layer to get\n  ///\n  /// @return a const ref of maplayer\n  std::shared_ptr<const MapLayer> getLayer(int layer_id);\n\n  /// @brief get one maplayer\n  ///\n  /// @param type_name[in] such as ndt3_corner...\n  ///\n  /// @return a co\n  std::shared_ptr<const MapLayer> getLayer(const std::string& type_name, float grid_size, float tile_size);\n\n private:\n  static std::shared_ptr<LocalDatabase> database_;\n  static LocalDatabase::MODE database_operation_mode_;\n  static proto::map::MapInfo map_info_;\n\n  std::map<int, std::shared_ptr<MapLayer>> layers_;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h"
		}
	}
]
I0402 15:57:22.878275  6725 json_parser.cpp:18] 
[
	36,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/eigen_types.h\"\n\n#include \"common/proto/config/config_map.pb.h\"\n\n#include \"lidar_map.h\"\n#include \"local_database.h\"\n#include \"map_layer.h\"\n#include \"map_scope.h\"\n#include \"ndt3interface.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass LidarMapOffline : public LidarMap {\n public:\n  /// @brief configure the LidarMapOffline class, mainly static members\n  /// which shared by all LidarMapOffline instance, such as database\n  ///\n  /// @param mode[in] specify the database operation mode, read, write, create...\n  ///\n  /// @note this should be called first before any operation about\n  /// LidarMapOffline\n  static bool configure(LocalDatabase::MODE mode);\n\n  /// @brief get the cache range(in number of tiles)\n  static int getCacheRange() { return LidarMap::cache_range_; }\n\n  /// @brief get the watermark of tile cache\n  static int getCacheMargin() { return LidarMap::cache_margin_; }\n\n  /// @brief implimention of LidarMap::initializeLayer, see LidarMap for more infomation\n  bool initializeLayer(int layer_id) override;\n\n  /// @brief initialize a layer by specify type_name, grid_size and tile\n  /// @return the layer_id of the initilized layer, if failed, a negtive number will be returned\n  int initializeLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief implimention of LidarMap::addPointCloud, see LidarMap for more infomation\n  bool addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) override;\n\n  /// @brief load the map to cache\n  /// @param[in] pos the center of the region to be loaded\n  /// @return true on succeed, else false\n  bool load(const Eigen::Vector3f& pos);\n\n  /// @brief Get the map of a layer in specific region\n  ///\n  /// @param layer_id[in] specify which layer to get\n  /// @param[in] scope specifies the submap region.\n  /// @param[in] blocking if is true, this call will block if cache miss happens,\n  /// until tiles are loaded or timeout\n  /// @param[out] ndt3 stores the map we got\n  ///\n  /// @return true on succeed, else false. we may fails when there is a cache miss\n  /// in blocking mode\n  bool getMap(int layer_id, const MapScope& scope, bool blocking,\n              std::shared_ptr<Ndt3Interface>* ndt3);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @param layer_item[in] a layer item contains nessecery infomation\n  /// to add one layer\n  ///\n  /// @return true on succeed, else false\n  bool addLayer(const proto::config::MapLayerItem& layer_item);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @return the layer id of the layer we add\n  int addLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief save the map into database\n  ///\n  /// @return true on succeed, else false\n  bool save();\n\n  /// @brief get one maplayer\n  ///\n  /// @param layer_id[in] specify which layer to get\n  ///\n  /// @return a const ref of maplayer\n  std::shared_ptr<const MapLayer> getLayer(int layer_id);\n\n  /// @brief get one maplayer\n  ///\n  /// @param type_name[in] such as ndt3_corner...\n  ///\n  /// @return a c\n  std::shared_ptr<const MapLayer> getLayer(const std::string& type_name, float grid_size, float tile_size);\n\n private:\n  static std::shared_ptr<LocalDatabase> database_;\n  static LocalDatabase::MODE database_operation_mode_;\n  static proto::map::MapInfo map_info_;\n\n  std::map<int, std::shared_ptr<MapLayer>> layers_;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h"
		}
	}
]
I0402 15:57:22.924141  6725 json_parser.cpp:18] 
[
	37,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/eigen_types.h\"\n\n#include \"common/proto/config/config_map.pb.h\"\n\n#include \"lidar_map.h\"\n#include \"local_database.h\"\n#include \"map_layer.h\"\n#include \"map_scope.h\"\n#include \"ndt3interface.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass LidarMapOffline : public LidarMap {\n public:\n  /// @brief configure the LidarMapOffline class, mainly static members\n  /// which shared by all LidarMapOffline instance, such as database\n  ///\n  /// @param mode[in] specify the database operation mode, read, write, create...\n  ///\n  /// @note this should be called first before any operation about\n  /// LidarMapOffline\n  static bool configure(LocalDatabase::MODE mode);\n\n  /// @brief get the cache range(in number of tiles)\n  static int getCacheRange() { return LidarMap::cache_range_; }\n\n  /// @brief get the watermark of tile cache\n  static int getCacheMargin() { return LidarMap::cache_margin_; }\n\n  /// @brief implimention of LidarMap::initializeLayer, see LidarMap for more infomation\n  bool initializeLayer(int layer_id) override;\n\n  /// @brief initialize a layer by specify type_name, grid_size and tile\n  /// @return the layer_id of the initilized layer, if failed, a negtive number will be returned\n  int initializeLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief implimention of LidarMap::addPointCloud, see LidarMap for more infomation\n  bool addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) override;\n\n  /// @brief load the map to cache\n  /// @param[in] pos the center of the region to be loaded\n  /// @return true on succeed, else false\n  bool load(const Eigen::Vector3f& pos);\n\n  /// @brief Get the map of a layer in specific region\n  ///\n  /// @param layer_id[in] specify which layer to get\n  /// @param[in] scope specifies the submap region.\n  /// @param[in] blocking if is true, this call will block if cache miss happens,\n  /// until tiles are loaded or timeout\n  /// @param[out] ndt3 stores the map we got\n  ///\n  /// @return true on succeed, else false. we may fails when there is a cache miss\n  /// in blocking mode\n  bool getMap(int layer_id, const MapScope& scope, bool blocking,\n              std::shared_ptr<Ndt3Interface>* ndt3);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @param layer_item[in] a layer item contains nessecery infomation\n  /// to add one layer\n  ///\n  /// @return true on succeed, else false\n  bool addLayer(const proto::config::MapLayerItem& layer_item);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @return the layer id of the layer we add\n  int addLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief save the map into database\n  ///\n  /// @return true on succeed, else false\n  bool save();\n\n  /// @brief get one maplayer\n  ///\n  /// @param layer_id[in] specify which layer to get\n  ///\n  /// @return a const ref of maplayer\n  std::shared_ptr<const MapLayer> getLayer(int layer_id);\n\n  /// @brief get one maplayer\n  ///\n  /// @param type_name[in] such as ndt3_corner...\n  ///\n  /// @return a \n  std::shared_ptr<const MapLayer> getLayer(const std::string& type_name, float grid_size, float tile_size);\n\n private:\n  static std::shared_ptr<LocalDatabase> database_;\n  static LocalDatabase::MODE database_operation_mode_;\n  static proto::map::MapInfo map_info_;\n\n  std::map<int, std::shared_ptr<MapLayer>> layers_;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h"
		}
	}
]
I0402 15:57:23.145301  6725 json_parser.cpp:18] 
[
	38,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/eigen_types.h\"\n\n#include \"common/proto/config/config_map.pb.h\"\n\n#include \"lidar_map.h\"\n#include \"local_database.h\"\n#include \"map_layer.h\"\n#include \"map_scope.h\"\n#include \"ndt3interface.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass LidarMapOffline : public LidarMap {\n public:\n  /// @brief configure the LidarMapOffline class, mainly static members\n  /// which shared by all LidarMapOffline instance, such as database\n  ///\n  /// @param mode[in] specify the database operation mode, read, write, create...\n  ///\n  /// @note this should be called first before any operation about\n  /// LidarMapOffline\n  static bool configure(LocalDatabase::MODE mode);\n\n  /// @brief get the cache range(in number of tiles)\n  static int getCacheRange() { return LidarMap::cache_range_; }\n\n  /// @brief get the watermark of tile cache\n  static int getCacheMargin() { return LidarMap::cache_margin_; }\n\n  /// @brief implimention of LidarMap::initializeLayer, see LidarMap for more infomation\n  bool initializeLayer(int layer_id) override;\n\n  /// @brief initialize a layer by specify type_name, grid_size and tile\n  /// @return the layer_id of the initilized layer, if failed, a negtive number will be returned\n  int initializeLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief implimention of LidarMap::addPointCloud, see LidarMap for more infomation\n  bool addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) override;\n\n  /// @brief load the map to cache\n  /// @param[in] pos the center of the region to be loaded\n  /// @return true on succeed, else false\n  bool load(const Eigen::Vector3f& pos);\n\n  /// @brief Get the map of a layer in specific region\n  ///\n  /// @param layer_id[in] specify which layer to get\n  /// @param[in] scope specifies the submap region.\n  /// @param[in] blocking if is true, this call will block if cache miss happens,\n  /// until tiles are loaded or timeout\n  /// @param[out] ndt3 stores the map we got\n  ///\n  /// @return true on succeed, else false. we may fails when there is a cache miss\n  /// in blocking mode\n  bool getMap(int layer_id, const MapScope& scope, bool blocking,\n              std::shared_ptr<Ndt3Interface>* ndt3);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @param layer_item[in] a layer item contains nessecery infomation\n  /// to add one layer\n  ///\n  /// @return true on succeed, else false\n  bool addLayer(const proto::config::MapLayerItem& layer_item);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @return the layer id of the layer we add\n  int addLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief save the map into database\n  ///\n  /// @return true on succeed, else false\n  bool save();\n\n  /// @brief get one maplayer\n  ///\n  /// @param layer_id[in] specify which layer to get\n  ///\n  /// @return a const ref of maplayer\n  std::shared_ptr<const MapLayer> getLayer(int layer_id);\n\n  /// @brief get one maplayer\n  ///\n  /// @param type_name[in] such as ndt3_corner...\n  ///\n  /// @return a\n  std::shared_ptr<const MapLayer> getLayer(const std::string& type_name, float grid_size, float tile_size);\n\n private:\n  static std::shared_ptr<LocalDatabase> database_;\n  static LocalDatabase::MODE database_operation_mode_;\n  static proto::map::MapInfo map_info_;\n\n  std::map<int, std::shared_ptr<MapLayer>> layers_;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h"
		}
	}
]
I0402 15:57:23.332738  6725 json_parser.cpp:18] 
[
	39,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/eigen_types.h\"\n\n#include \"common/proto/config/config_map.pb.h\"\n\n#include \"lidar_map.h\"\n#include \"local_database.h\"\n#include \"map_layer.h\"\n#include \"map_scope.h\"\n#include \"ndt3interface.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass LidarMapOffline : public LidarMap {\n public:\n  /// @brief configure the LidarMapOffline class, mainly static members\n  /// which shared by all LidarMapOffline instance, such as database\n  ///\n  /// @param mode[in] specify the database operation mode, read, write, create...\n  ///\n  /// @note this should be called first before any operation about\n  /// LidarMapOffline\n  static bool configure(LocalDatabase::MODE mode);\n\n  /// @brief get the cache range(in number of tiles)\n  static int getCacheRange() { return LidarMap::cache_range_; }\n\n  /// @brief get the watermark of tile cache\n  static int getCacheMargin() { return LidarMap::cache_margin_; }\n\n  /// @brief implimention of LidarMap::initializeLayer, see LidarMap for more infomation\n  bool initializeLayer(int layer_id) override;\n\n  /// @brief initialize a layer by specify type_name, grid_size and tile\n  /// @return the layer_id of the initilized layer, if failed, a negtive number will be returned\n  int initializeLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief implimention of LidarMap::addPointCloud, see LidarMap for more infomation\n  bool addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) override;\n\n  /// @brief load the map to cache\n  /// @param[in] pos the center of the region to be loaded\n  /// @return true on succeed, else false\n  bool load(const Eigen::Vector3f& pos);\n\n  /// @brief Get the map of a layer in specific region\n  ///\n  /// @param layer_id[in] specify which layer to get\n  /// @param[in] scope specifies the submap region.\n  /// @param[in] blocking if is true, this call will block if cache miss happens,\n  /// until tiles are loaded or timeout\n  /// @param[out] ndt3 stores the map we got\n  ///\n  /// @return true on succeed, else false. we may fails when there is a cache miss\n  /// in blocking mode\n  bool getMap(int layer_id, const MapScope& scope, bool blocking,\n              std::shared_ptr<Ndt3Interface>* ndt3);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @param layer_item[in] a layer item contains nessecery infomation\n  /// to add one layer\n  ///\n  /// @return true on succeed, else false\n  bool addLayer(const proto::config::MapLayerItem& layer_item);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @return the layer id of the layer we add\n  int addLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief save the map into database\n  ///\n  /// @return true on succeed, else false\n  bool save();\n\n  /// @brief get one maplayer\n  ///\n  /// @param layer_id[in] specify which layer to get\n  ///\n  /// @return a const ref of maplayer\n  std::shared_ptr<const MapLayer> getLayer(int layer_id);\n\n  /// @brief get one maplayer\n  ///\n  /// @param type_name[in] such as ndt3_corner...\n  ///\n  /// @return \n  std::shared_ptr<const MapLayer> getLayer(const std::string& type_name, float grid_size, float tile_size);\n\n private:\n  static std::shared_ptr<LocalDatabase> database_;\n  static LocalDatabase::MODE database_operation_mode_;\n  static proto::map::MapInfo map_info_;\n\n  std::map<int, std::shared_ptr<MapLayer>> layers_;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h"
		}
	}
]
I0402 15:57:23.649026  6725 json_parser.cpp:18] 
[
	40,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/eigen_types.h\"\n\n#include \"common/proto/config/config_map.pb.h\"\n\n#include \"lidar_map.h\"\n#include \"local_database.h\"\n#include \"map_layer.h\"\n#include \"map_scope.h\"\n#include \"ndt3interface.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass LidarMapOffline : public LidarMap {\n public:\n  /// @brief configure the LidarMapOffline class, mainly static members\n  /// which shared by all LidarMapOffline instance, such as database\n  ///\n  /// @param mode[in] specify the database operation mode, read, write, create...\n  ///\n  /// @note this should be called first before any operation about\n  /// LidarMapOffline\n  static bool configure(LocalDatabase::MODE mode);\n\n  /// @brief get the cache range(in number of tiles)\n  static int getCacheRange() { return LidarMap::cache_range_; }\n\n  /// @brief get the watermark of tile cache\n  static int getCacheMargin() { return LidarMap::cache_margin_; }\n\n  /// @brief implimention of LidarMap::initializeLayer, see LidarMap for more infomation\n  bool initializeLayer(int layer_id) override;\n\n  /// @brief initialize a layer by specify type_name, grid_size and tile\n  /// @return the layer_id of the initilized layer, if failed, a negtive number will be returned\n  int initializeLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief implimention of LidarMap::addPointCloud, see LidarMap for more infomation\n  bool addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) override;\n\n  /// @brief load the map to cache\n  /// @param[in] pos the center of the region to be loaded\n  /// @return true on succeed, else false\n  bool load(const Eigen::Vector3f& pos);\n\n  /// @brief Get the map of a layer in specific region\n  ///\n  /// @param layer_id[in] specify which layer to get\n  /// @param[in] scope specifies the submap region.\n  /// @param[in] blocking if is true, this call will block if cache miss happens,\n  /// until tiles are loaded or timeout\n  /// @param[out] ndt3 stores the map we got\n  ///\n  /// @return true on succeed, else false. we may fails when there is a cache miss\n  /// in blocking mode\n  bool getMap(int layer_id, const MapScope& scope, bool blocking,\n              std::shared_ptr<Ndt3Interface>* ndt3);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @param layer_item[in] a layer item contains nessecery infomation\n  /// to add one layer\n  ///\n  /// @return true on succeed, else false\n  bool addLayer(const proto::config::MapLayerItem& layer_item);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @return the layer id of the layer we add\n  int addLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief save the map into database\n  ///\n  /// @return true on succeed, else false\n  bool save();\n\n  /// @brief get one maplayer\n  ///\n  /// @param layer_id[in] specify which layer to get\n  ///\n  /// @return a const ref of maplayer\n  std::shared_ptr<const MapLayer> getLayer(int layer_id);\n\n  /// @brief get one maplayer\n  ///\n  /// @param type_name[in] such as ndt3_corner...\n  ///\n  /// @return \n  std::shared_ptr<const MapLayer> getLayer(const std::string& type_name, float grid_size, float tile_size);\n\n private:\n  static std::shared_ptr<LocalDatabase> database_;\n  static LocalDatabase::MODE database_operation_mode_;\n  static proto::map::MapInfo map_info_;\n\n  std::map<int, std::shared_ptr<MapLayer>> layers_;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h"
		}
	}
]
I0402 15:57:28.896068  6725 json_parser.cpp:18] 
[
	41,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/eigen_types.h\"\n\n#include \"common/proto/config/config_map.pb.h\"\n\n#include \"lidar_map.h\"\n#include \"local_database.h\"\n#include \"map_layer.h\"\n#include \"map_scope.h\"\n#include \"ndt3interface.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass LidarMapOffline : public LidarMap {\n public:\n  /// @brief configure the LidarMapOffline class, mainly static members\n  /// which shared by all LidarMapOffline instance, such as database\n  ///\n  /// @param mode[in] specify the database operation mode, read, write, create...\n  ///\n  /// @note this should be called first before any operation about\n  /// LidarMapOffline\n  static bool configure(LocalDatabase::MODE mode);\n\n  /// @brief get the cache range(in number of tiles)\n  static int getCacheRange() { return LidarMap::cache_range_; }\n\n  /// @brief get the watermark of tile cache\n  static int getCacheMargin() { return LidarMap::cache_margin_; }\n\n  /// @brief implimention of LidarMap::initializeLayer, see LidarMap for more infomation\n  bool initializeLayer(int layer_id) override;\n\n  /// @brief initialize a layer by specify type_name, grid_size and tile\n  /// @return the layer_id of the initilized layer, if failed, a negtive number will be returned\n  int initializeLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief implimention of LidarMap::addPointCloud, see LidarMap for more infomation\n  bool addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) override;\n\n  /// @brief load the map to cache\n  /// @param[in] pos the center of the region to be loaded\n  /// @return true on succeed, else false\n  bool load(const Eigen::Vector3f& pos);\n\n  /// @brief Get the map of a layer in specific region\n  ///\n  /// @param layer_id[in] specify which layer to get\n  /// @param[in] scope specifies the submap region.\n  /// @param[in] blocking if is true, this call will block if cache miss happens,\n  /// until tiles are loaded or timeout\n  /// @param[out] ndt3 stores the map we got\n  ///\n  /// @return true on succeed, else false. we may fails when there is a cache miss\n  /// in blocking mode\n  bool getMap(int layer_id, const MapScope& scope, bool blocking,\n              std::shared_ptr<Ndt3Interface>* ndt3);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @param layer_item[in] a layer item contains nessecery infomation\n  /// to add one layer\n  ///\n  /// @return true on succeed, else false\n  bool addLayer(const proto::config::MapLayerItem& layer_item);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @return the layer id of the layer we add\n  int addLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief save the map into database\n  ///\n  /// @return true on succeed, else false\n  bool save();\n\n  /// @brief get one maplayer\n  ///\n  /// @param layer_id[in] specify which layer to get\n  ///\n  /// @return a const ref of maplayer\n  std::shared_ptr<const MapLayer> getLayer(int layer_id);\n\n  /// @brief get one maplayer\n  ///\n  /// @param type_name[in] such as ndt3_corner...\n  ///\n  /// @return map layer got\n  std::shared_ptr<const MapLayer> getLayer(const std::string& type_name, float grid_size, float tile_size);\n\n private:\n  static std::shared_ptr<LocalDatabase> database_;\n  static LocalDatabase::MODE database_operation_mode_;\n  static proto::map::MapInfo map_info_;\n\n  std::map<int, std::shared_ptr<MapLayer>> layers_;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h"
		}
	}
]
I0402 15:57:31.773308  6725 json_parser.cpp:18] 
[
	42,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/eigen_types.h\"\n\n#include \"common/proto/config/config_map.pb.h\"\n\n#include \"lidar_map.h\"\n#include \"local_database.h\"\n#include \"map_layer.h\"\n#include \"map_scope.h\"\n#include \"ndt3interface.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass LidarMapOffline : public LidarMap {\n public:\n  /// @brief configure the LidarMapOffline class, mainly static members\n  /// which shared by all LidarMapOffline instance, such as database\n  ///\n  /// @param mode[in] specify the database operation mode, read, write, create...\n  ///\n  /// @note this should be called first before any operation about\n  /// LidarMapOffline\n  static bool configure(LocalDatabase::MODE mode);\n\n  /// @brief get the cache range(in number of tiles)\n  static int getCacheRange() { return LidarMap::cache_range_; }\n\n  /// @brief get the watermark of tile cache\n  static int getCacheMargin() { return LidarMap::cache_margin_; }\n\n  /// @brief implimention of LidarMap::initializeLayer, see LidarMap for more infomation\n  bool initializeLayer(int layer_id) override;\n\n  /// @brief initialize a layer by specify type_name, grid_size and tile\n  /// @return the layer_id of the initilized layer, if failed, a negtive number will be returned\n  int initializeLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief implimention of LidarMap::addPointCloud, see LidarMap for more infomation\n  bool addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) override;\n\n  /// @brief load the map to cache\n  /// @param[in] pos the center of the region to be loaded\n  /// @return true on succeed, else false\n  bool load(const Eigen::Vector3f& pos);\n\n  /// @brief Get the map of a layer in specific region\n  ///\n  /// @param layer_id[in] specify which layer to get\n  /// @param[in] scope specifies the submap region.\n  /// @param[in] blocking if is true, this call will block if cache miss happens,\n  /// until tiles are loaded or timeout\n  /// @param[out] ndt3 stores the map we got\n  ///\n  /// @return true on succeed, else false. we may fails when there is a cache miss\n  /// in blocking mode\n  bool getMap(int layer_id, const MapScope& scope, bool blocking,\n              std::shared_ptr<Ndt3Interface>* ndt3);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @param layer_item[in] a layer item contains nessecery infomation\n  /// to add one layer\n  ///\n  /// @return true on succeed, else false\n  bool addLayer(const proto::config::MapLayerItem& layer_item);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @return the layer id of the layer we add\n  int addLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief save the map into database\n  ///\n  /// @return true on succeed, else false\n  bool save();\n\n  /// @brief get one maplayer\n  ///\n  /// @param layer_id[in] specify which layer to get\n  ///\n  /// @return a const ref of maplaye\n  std::shared_ptr<const MapLayer> getLayer(int layer_id);\n\n  /// @brief get one maplayer\n  ///\n  /// @param type_name[in] such as ndt3_corner...\n  ///\n  /// @return map layer got\n  std::shared_ptr<const MapLayer> getLayer(const std::string& type_name, float grid_size, float tile_size);\n\n private:\n  static std::shared_ptr<LocalDatabase> database_;\n  static LocalDatabase::MODE database_operation_mode_;\n  static proto::map::MapInfo map_info_;\n\n  std::map<int, std::shared_ptr<MapLayer>> layers_;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h"
		}
	}
]
I0402 15:57:32.432588  6725 json_parser.cpp:18] 
[
	43,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/eigen_types.h\"\n\n#include \"common/proto/config/config_map.pb.h\"\n\n#include \"lidar_map.h\"\n#include \"local_database.h\"\n#include \"map_layer.h\"\n#include \"map_scope.h\"\n#include \"ndt3interface.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass LidarMapOffline : public LidarMap {\n public:\n  /// @brief configure the LidarMapOffline class, mainly static members\n  /// which shared by all LidarMapOffline instance, such as database\n  ///\n  /// @param mode[in] specify the database operation mode, read, write, create...\n  ///\n  /// @note this should be called first before any operation about\n  /// LidarMapOffline\n  static bool configure(LocalDatabase::MODE mode);\n\n  /// @brief get the cache range(in number of tiles)\n  static int getCacheRange() { return LidarMap::cache_range_; }\n\n  /// @brief get the watermark of tile cache\n  static int getCacheMargin() { return LidarMap::cache_margin_; }\n\n  /// @brief implimention of LidarMap::initializeLayer, see LidarMap for more infomation\n  bool initializeLayer(int layer_id) override;\n\n  /// @brief initialize a layer by specify type_name, grid_size and tile\n  /// @return the layer_id of the initilized layer, if failed, a negtive number will be returned\n  int initializeLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief implimention of LidarMap::addPointCloud, see LidarMap for more infomation\n  bool addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) override;\n\n  /// @brief load the map to cache\n  /// @param[in] pos the center of the region to be loaded\n  /// @return true on succeed, else false\n  bool load(const Eigen::Vector3f& pos);\n\n  /// @brief Get the map of a layer in specific region\n  ///\n  /// @param layer_id[in] specify which layer to get\n  /// @param[in] scope specifies the submap region.\n  /// @param[in] blocking if is true, this call will block if cache miss happens,\n  /// until tiles are loaded or timeout\n  /// @param[out] ndt3 stores the map we got\n  ///\n  /// @return true on succeed, else false. we may fails when there is a cache miss\n  /// in blocking mode\n  bool getMap(int layer_id, const MapScope& scope, bool blocking,\n              std::shared_ptr<Ndt3Interface>* ndt3);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @param layer_item[in] a layer item contains nessecery infomation\n  /// to add one layer\n  ///\n  /// @return true on succeed, else false\n  bool addLayer(const proto::config::MapLayerItem& layer_item);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @return the layer id of the layer we add\n  int addLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief save the map into database\n  ///\n  /// @return true on succeed, else false\n  bool save();\n\n  /// @brief get one maplayer\n  ///\n  /// @param layer_id[in] specify which layer to get\n  ///\n  /// @return a const ref of maplay\n  std::shared_ptr<const MapLayer> getLayer(int layer_id);\n\n  /// @brief get one maplayer\n  ///\n  /// @param type_name[in] such as ndt3_corner...\n  ///\n  /// @return map layer got\n  std::shared_ptr<const MapLayer> getLayer(const std::string& type_name, float grid_size, float tile_size);\n\n private:\n  static std::shared_ptr<LocalDatabase> database_;\n  static LocalDatabase::MODE database_operation_mode_;\n  static proto::map::MapInfo map_info_;\n\n  std::map<int, std::shared_ptr<MapLayer>> layers_;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h"
		}
	}
]
I0402 15:57:32.470619  6725 json_parser.cpp:18] 
[
	44,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/eigen_types.h\"\n\n#include \"common/proto/config/config_map.pb.h\"\n\n#include \"lidar_map.h\"\n#include \"local_database.h\"\n#include \"map_layer.h\"\n#include \"map_scope.h\"\n#include \"ndt3interface.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass LidarMapOffline : public LidarMap {\n public:\n  /// @brief configure the LidarMapOffline class, mainly static members\n  /// which shared by all LidarMapOffline instance, such as database\n  ///\n  /// @param mode[in] specify the database operation mode, read, write, create...\n  ///\n  /// @note this should be called first before any operation about\n  /// LidarMapOffline\n  static bool configure(LocalDatabase::MODE mode);\n\n  /// @brief get the cache range(in number of tiles)\n  static int getCacheRange() { return LidarMap::cache_range_; }\n\n  /// @brief get the watermark of tile cache\n  static int getCacheMargin() { return LidarMap::cache_margin_; }\n\n  /// @brief implimention of LidarMap::initializeLayer, see LidarMap for more infomation\n  bool initializeLayer(int layer_id) override;\n\n  /// @brief initialize a layer by specify type_name, grid_size and tile\n  /// @return the layer_id of the initilized layer, if failed, a negtive number will be returned\n  int initializeLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief implimention of LidarMap::addPointCloud, see LidarMap for more infomation\n  bool addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) override;\n\n  /// @brief load the map to cache\n  /// @param[in] pos the center of the region to be loaded\n  /// @return true on succeed, else false\n  bool load(const Eigen::Vector3f& pos);\n\n  /// @brief Get the map of a layer in specific region\n  ///\n  /// @param layer_id[in] specify which layer to get\n  /// @param[in] scope specifies the submap region.\n  /// @param[in] blocking if is true, this call will block if cache miss happens,\n  /// until tiles are loaded or timeout\n  /// @param[out] ndt3 stores the map we got\n  ///\n  /// @return true on succeed, else false. we may fails when there is a cache miss\n  /// in blocking mode\n  bool getMap(int layer_id, const MapScope& scope, bool blocking,\n              std::shared_ptr<Ndt3Interface>* ndt3);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @param layer_item[in] a layer item contains nessecery infomation\n  /// to add one layer\n  ///\n  /// @return true on succeed, else false\n  bool addLayer(const proto::config::MapLayerItem& layer_item);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @return the layer id of the layer we add\n  int addLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief save the map into database\n  ///\n  /// @return true on succeed, else false\n  bool save();\n\n  /// @brief get one maplayer\n  ///\n  /// @param layer_id[in] specify which layer to get\n  ///\n  /// @return a const ref of mapla\n  std::shared_ptr<const MapLayer> getLayer(int layer_id);\n\n  /// @brief get one maplayer\n  ///\n  /// @param type_name[in] such as ndt3_corner...\n  ///\n  /// @return map layer got\n  std::shared_ptr<const MapLayer> getLayer(const std::string& type_name, float grid_size, float tile_size);\n\n private:\n  static std::shared_ptr<LocalDatabase> database_;\n  static LocalDatabase::MODE database_operation_mode_;\n  static proto::map::MapInfo map_info_;\n\n  std::map<int, std::shared_ptr<MapLayer>> layers_;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h"
		}
	}
]
I0402 15:57:32.509801  6725 json_parser.cpp:18] 
[
	45,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/eigen_types.h\"\n\n#include \"common/proto/config/config_map.pb.h\"\n\n#include \"lidar_map.h\"\n#include \"local_database.h\"\n#include \"map_layer.h\"\n#include \"map_scope.h\"\n#include \"ndt3interface.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass LidarMapOffline : public LidarMap {\n public:\n  /// @brief configure the LidarMapOffline class, mainly static members\n  /// which shared by all LidarMapOffline instance, such as database\n  ///\n  /// @param mode[in] specify the database operation mode, read, write, create...\n  ///\n  /// @note this should be called first before any operation about\n  /// LidarMapOffline\n  static bool configure(LocalDatabase::MODE mode);\n\n  /// @brief get the cache range(in number of tiles)\n  static int getCacheRange() { return LidarMap::cache_range_; }\n\n  /// @brief get the watermark of tile cache\n  static int getCacheMargin() { return LidarMap::cache_margin_; }\n\n  /// @brief implimention of LidarMap::initializeLayer, see LidarMap for more infomation\n  bool initializeLayer(int layer_id) override;\n\n  /// @brief initialize a layer by specify type_name, grid_size and tile\n  /// @return the layer_id of the initilized layer, if failed, a negtive number will be returned\n  int initializeLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief implimention of LidarMap::addPointCloud, see LidarMap for more infomation\n  bool addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) override;\n\n  /// @brief load the map to cache\n  /// @param[in] pos the center of the region to be loaded\n  /// @return true on succeed, else false\n  bool load(const Eigen::Vector3f& pos);\n\n  /// @brief Get the map of a layer in specific region\n  ///\n  /// @param layer_id[in] specify which layer to get\n  /// @param[in] scope specifies the submap region.\n  /// @param[in] blocking if is true, this call will block if cache miss happens,\n  /// until tiles are loaded or timeout\n  /// @param[out] ndt3 stores the map we got\n  ///\n  /// @return true on succeed, else false. we may fails when there is a cache miss\n  /// in blocking mode\n  bool getMap(int layer_id, const MapScope& scope, bool blocking,\n              std::shared_ptr<Ndt3Interface>* ndt3);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @param layer_item[in] a layer item contains nessecery infomation\n  /// to add one layer\n  ///\n  /// @return true on succeed, else false\n  bool addLayer(const proto::config::MapLayerItem& layer_item);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @return the layer id of the layer we add\n  int addLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief save the map into database\n  ///\n  /// @return true on succeed, else false\n  bool save();\n\n  /// @brief get one maplayer\n  ///\n  /// @param layer_id[in] specify which layer to get\n  ///\n  /// @return a const ref of mapl\n  std::shared_ptr<const MapLayer> getLayer(int layer_id);\n\n  /// @brief get one maplayer\n  ///\n  /// @param type_name[in] such as ndt3_corner...\n  ///\n  /// @return map layer got\n  std::shared_ptr<const MapLayer> getLayer(const std::string& type_name, float grid_size, float tile_size);\n\n private:\n  static std::shared_ptr<LocalDatabase> database_;\n  static LocalDatabase::MODE database_operation_mode_;\n  static proto::map::MapInfo map_info_;\n\n  std::map<int, std::shared_ptr<MapLayer>> layers_;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h"
		}
	}
]
I0402 15:57:32.549995  6725 json_parser.cpp:18] 
[
	46,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/eigen_types.h\"\n\n#include \"common/proto/config/config_map.pb.h\"\n\n#include \"lidar_map.h\"\n#include \"local_database.h\"\n#include \"map_layer.h\"\n#include \"map_scope.h\"\n#include \"ndt3interface.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass LidarMapOffline : public LidarMap {\n public:\n  /// @brief configure the LidarMapOffline class, mainly static members\n  /// which shared by all LidarMapOffline instance, such as database\n  ///\n  /// @param mode[in] specify the database operation mode, read, write, create...\n  ///\n  /// @note this should be called first before any operation about\n  /// LidarMapOffline\n  static bool configure(LocalDatabase::MODE mode);\n\n  /// @brief get the cache range(in number of tiles)\n  static int getCacheRange() { return LidarMap::cache_range_; }\n\n  /// @brief get the watermark of tile cache\n  static int getCacheMargin() { return LidarMap::cache_margin_; }\n\n  /// @brief implimention of LidarMap::initializeLayer, see LidarMap for more infomation\n  bool initializeLayer(int layer_id) override;\n\n  /// @brief initialize a layer by specify type_name, grid_size and tile\n  /// @return the layer_id of the initilized layer, if failed, a negtive number will be returned\n  int initializeLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief implimention of LidarMap::addPointCloud, see LidarMap for more infomation\n  bool addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) override;\n\n  /// @brief load the map to cache\n  /// @param[in] pos the center of the region to be loaded\n  /// @return true on succeed, else false\n  bool load(const Eigen::Vector3f& pos);\n\n  /// @brief Get the map of a layer in specific region\n  ///\n  /// @param layer_id[in] specify which layer to get\n  /// @param[in] scope specifies the submap region.\n  /// @param[in] blocking if is true, this call will block if cache miss happens,\n  /// until tiles are loaded or timeout\n  /// @param[out] ndt3 stores the map we got\n  ///\n  /// @return true on succeed, else false. we may fails when there is a cache miss\n  /// in blocking mode\n  bool getMap(int layer_id, const MapScope& scope, bool blocking,\n              std::shared_ptr<Ndt3Interface>* ndt3);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @param layer_item[in] a layer item contains nessecery infomation\n  /// to add one layer\n  ///\n  /// @return true on succeed, else false\n  bool addLayer(const proto::config::MapLayerItem& layer_item);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @return the layer id of the layer we add\n  int addLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief save the map into database\n  ///\n  /// @return true on succeed, else false\n  bool save();\n\n  /// @brief get one maplayer\n  ///\n  /// @param layer_id[in] specify which layer to get\n  ///\n  /// @return a const ref of map\n  std::shared_ptr<const MapLayer> getLayer(int layer_id);\n\n  /// @brief get one maplayer\n  ///\n  /// @param type_name[in] such as ndt3_corner...\n  ///\n  /// @return map layer got\n  std::shared_ptr<const MapLayer> getLayer(const std::string& type_name, float grid_size, float tile_size);\n\n private:\n  static std::shared_ptr<LocalDatabase> database_;\n  static LocalDatabase::MODE database_operation_mode_;\n  static proto::map::MapInfo map_info_;\n\n  std::map<int, std::shared_ptr<MapLayer>> layers_;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h"
		}
	}
]
I0402 15:57:32.590399  6725 json_parser.cpp:18] 
[
	47,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/eigen_types.h\"\n\n#include \"common/proto/config/config_map.pb.h\"\n\n#include \"lidar_map.h\"\n#include \"local_database.h\"\n#include \"map_layer.h\"\n#include \"map_scope.h\"\n#include \"ndt3interface.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass LidarMapOffline : public LidarMap {\n public:\n  /// @brief configure the LidarMapOffline class, mainly static members\n  /// which shared by all LidarMapOffline instance, such as database\n  ///\n  /// @param mode[in] specify the database operation mode, read, write, create...\n  ///\n  /// @note this should be called first before any operation about\n  /// LidarMapOffline\n  static bool configure(LocalDatabase::MODE mode);\n\n  /// @brief get the cache range(in number of tiles)\n  static int getCacheRange() { return LidarMap::cache_range_; }\n\n  /// @brief get the watermark of tile cache\n  static int getCacheMargin() { return LidarMap::cache_margin_; }\n\n  /// @brief implimention of LidarMap::initializeLayer, see LidarMap for more infomation\n  bool initializeLayer(int layer_id) override;\n\n  /// @brief initialize a layer by specify type_name, grid_size and tile\n  /// @return the layer_id of the initilized layer, if failed, a negtive number will be returned\n  int initializeLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief implimention of LidarMap::addPointCloud, see LidarMap for more infomation\n  bool addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) override;\n\n  /// @brief load the map to cache\n  /// @param[in] pos the center of the region to be loaded\n  /// @return true on succeed, else false\n  bool load(const Eigen::Vector3f& pos);\n\n  /// @brief Get the map of a layer in specific region\n  ///\n  /// @param layer_id[in] specify which layer to get\n  /// @param[in] scope specifies the submap region.\n  /// @param[in] blocking if is true, this call will block if cache miss happens,\n  /// until tiles are loaded or timeout\n  /// @param[out] ndt3 stores the map we got\n  ///\n  /// @return true on succeed, else false. we may fails when there is a cache miss\n  /// in blocking mode\n  bool getMap(int layer_id, const MapScope& scope, bool blocking,\n              std::shared_ptr<Ndt3Interface>* ndt3);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @param layer_item[in] a layer item contains nessecery infomation\n  /// to add one layer\n  ///\n  /// @return true on succeed, else false\n  bool addLayer(const proto::config::MapLayerItem& layer_item);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @return the layer id of the layer we add\n  int addLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief save the map into database\n  ///\n  /// @return true on succeed, else false\n  bool save();\n\n  /// @brief get one maplayer\n  ///\n  /// @param layer_id[in] specify which layer to get\n  ///\n  /// @return a const ref of ma\n  std::shared_ptr<const MapLayer> getLayer(int layer_id);\n\n  /// @brief get one maplayer\n  ///\n  /// @param type_name[in] such as ndt3_corner...\n  ///\n  /// @return map layer got\n  std::shared_ptr<const MapLayer> getLayer(const std::string& type_name, float grid_size, float tile_size);\n\n private:\n  static std::shared_ptr<LocalDatabase> database_;\n  static LocalDatabase::MODE database_operation_mode_;\n  static proto::map::MapInfo map_info_;\n\n  std::map<int, std::shared_ptr<MapLayer>> layers_;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h"
		}
	}
]
I0402 15:57:32.631193  6725 json_parser.cpp:18] 
[
	48,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/eigen_types.h\"\n\n#include \"common/proto/config/config_map.pb.h\"\n\n#include \"lidar_map.h\"\n#include \"local_database.h\"\n#include \"map_layer.h\"\n#include \"map_scope.h\"\n#include \"ndt3interface.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass LidarMapOffline : public LidarMap {\n public:\n  /// @brief configure the LidarMapOffline class, mainly static members\n  /// which shared by all LidarMapOffline instance, such as database\n  ///\n  /// @param mode[in] specify the database operation mode, read, write, create...\n  ///\n  /// @note this should be called first before any operation about\n  /// LidarMapOffline\n  static bool configure(LocalDatabase::MODE mode);\n\n  /// @brief get the cache range(in number of tiles)\n  static int getCacheRange() { return LidarMap::cache_range_; }\n\n  /// @brief get the watermark of tile cache\n  static int getCacheMargin() { return LidarMap::cache_margin_; }\n\n  /// @brief implimention of LidarMap::initializeLayer, see LidarMap for more infomation\n  bool initializeLayer(int layer_id) override;\n\n  /// @brief initialize a layer by specify type_name, grid_size and tile\n  /// @return the layer_id of the initilized layer, if failed, a negtive number will be returned\n  int initializeLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief implimention of LidarMap::addPointCloud, see LidarMap for more infomation\n  bool addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) override;\n\n  /// @brief load the map to cache\n  /// @param[in] pos the center of the region to be loaded\n  /// @return true on succeed, else false\n  bool load(const Eigen::Vector3f& pos);\n\n  /// @brief Get the map of a layer in specific region\n  ///\n  /// @param layer_id[in] specify which layer to get\n  /// @param[in] scope specifies the submap region.\n  /// @param[in] blocking if is true, this call will block if cache miss happens,\n  /// until tiles are loaded or timeout\n  /// @param[out] ndt3 stores the map we got\n  ///\n  /// @return true on succeed, else false. we may fails when there is a cache miss\n  /// in blocking mode\n  bool getMap(int layer_id, const MapScope& scope, bool blocking,\n              std::shared_ptr<Ndt3Interface>* ndt3);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @param layer_item[in] a layer item contains nessecery infomation\n  /// to add one layer\n  ///\n  /// @return true on succeed, else false\n  bool addLayer(const proto::config::MapLayerItem& layer_item);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @return the layer id of the layer we add\n  int addLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief save the map into database\n  ///\n  /// @return true on succeed, else false\n  bool save();\n\n  /// @brief get one maplayer\n  ///\n  /// @param layer_id[in] specify which layer to get\n  ///\n  /// @return a const ref of m\n  std::shared_ptr<const MapLayer> getLayer(int layer_id);\n\n  /// @brief get one maplayer\n  ///\n  /// @param type_name[in] such as ndt3_corner...\n  ///\n  /// @return map layer got\n  std::shared_ptr<const MapLayer> getLayer(const std::string& type_name, float grid_size, float tile_size);\n\n private:\n  static std::shared_ptr<LocalDatabase> database_;\n  static LocalDatabase::MODE database_operation_mode_;\n  static proto::map::MapInfo map_info_;\n\n  std::map<int, std::shared_ptr<MapLayer>> layers_;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h"
		}
	}
]
I0402 15:57:32.670790  6725 json_parser.cpp:18] 
[
	49,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/eigen_types.h\"\n\n#include \"common/proto/config/config_map.pb.h\"\n\n#include \"lidar_map.h\"\n#include \"local_database.h\"\n#include \"map_layer.h\"\n#include \"map_scope.h\"\n#include \"ndt3interface.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass LidarMapOffline : public LidarMap {\n public:\n  /// @brief configure the LidarMapOffline class, mainly static members\n  /// which shared by all LidarMapOffline instance, such as database\n  ///\n  /// @param mode[in] specify the database operation mode, read, write, create...\n  ///\n  /// @note this should be called first before any operation about\n  /// LidarMapOffline\n  static bool configure(LocalDatabase::MODE mode);\n\n  /// @brief get the cache range(in number of tiles)\n  static int getCacheRange() { return LidarMap::cache_range_; }\n\n  /// @brief get the watermark of tile cache\n  static int getCacheMargin() { return LidarMap::cache_margin_; }\n\n  /// @brief implimention of LidarMap::initializeLayer, see LidarMap for more infomation\n  bool initializeLayer(int layer_id) override;\n\n  /// @brief initialize a layer by specify type_name, grid_size and tile\n  /// @return the layer_id of the initilized layer, if failed, a negtive number will be returned\n  int initializeLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief implimention of LidarMap::addPointCloud, see LidarMap for more infomation\n  bool addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) override;\n\n  /// @brief load the map to cache\n  /// @param[in] pos the center of the region to be loaded\n  /// @return true on succeed, else false\n  bool load(const Eigen::Vector3f& pos);\n\n  /// @brief Get the map of a layer in specific region\n  ///\n  /// @param layer_id[in] specify which layer to get\n  /// @param[in] scope specifies the submap region.\n  /// @param[in] blocking if is true, this call will block if cache miss happens,\n  /// until tiles are loaded or timeout\n  /// @param[out] ndt3 stores the map we got\n  ///\n  /// @return true on succeed, else false. we may fails when there is a cache miss\n  /// in blocking mode\n  bool getMap(int layer_id, const MapScope& scope, bool blocking,\n              std::shared_ptr<Ndt3Interface>* ndt3);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @param layer_item[in] a layer item contains nessecery infomation\n  /// to add one layer\n  ///\n  /// @return true on succeed, else false\n  bool addLayer(const proto::config::MapLayerItem& layer_item);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @return the layer id of the layer we add\n  int addLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief save the map into database\n  ///\n  /// @return true on succeed, else false\n  bool save();\n\n  /// @brief get one maplayer\n  ///\n  /// @param layer_id[in] specify which layer to get\n  ///\n  /// @return a const ref of \n  std::shared_ptr<const MapLayer> getLayer(int layer_id);\n\n  /// @brief get one maplayer\n  ///\n  /// @param type_name[in] such as ndt3_corner...\n  ///\n  /// @return map layer got\n  std::shared_ptr<const MapLayer> getLayer(const std::string& type_name, float grid_size, float tile_size);\n\n private:\n  static std::shared_ptr<LocalDatabase> database_;\n  static LocalDatabase::MODE database_operation_mode_;\n  static proto::map::MapInfo map_info_;\n\n  std::map<int, std::shared_ptr<MapLayer>> layers_;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h"
		}
	}
]
I0402 15:57:32.715687  6725 json_parser.cpp:18] 
[
	50,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/eigen_types.h\"\n\n#include \"common/proto/config/config_map.pb.h\"\n\n#include \"lidar_map.h\"\n#include \"local_database.h\"\n#include \"map_layer.h\"\n#include \"map_scope.h\"\n#include \"ndt3interface.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass LidarMapOffline : public LidarMap {\n public:\n  /// @brief configure the LidarMapOffline class, mainly static members\n  /// which shared by all LidarMapOffline instance, such as database\n  ///\n  /// @param mode[in] specify the database operation mode, read, write, create...\n  ///\n  /// @note this should be called first before any operation about\n  /// LidarMapOffline\n  static bool configure(LocalDatabase::MODE mode);\n\n  /// @brief get the cache range(in number of tiles)\n  static int getCacheRange() { return LidarMap::cache_range_; }\n\n  /// @brief get the watermark of tile cache\n  static int getCacheMargin() { return LidarMap::cache_margin_; }\n\n  /// @brief implimention of LidarMap::initializeLayer, see LidarMap for more infomation\n  bool initializeLayer(int layer_id) override;\n\n  /// @brief initialize a layer by specify type_name, grid_size and tile\n  /// @return the layer_id of the initilized layer, if failed, a negtive number will be returned\n  int initializeLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief implimention of LidarMap::addPointCloud, see LidarMap for more infomation\n  bool addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) override;\n\n  /// @brief load the map to cache\n  /// @param[in] pos the center of the region to be loaded\n  /// @return true on succeed, else false\n  bool load(const Eigen::Vector3f& pos);\n\n  /// @brief Get the map of a layer in specific region\n  ///\n  /// @param layer_id[in] specify which layer to get\n  /// @param[in] scope specifies the submap region.\n  /// @param[in] blocking if is true, this call will block if cache miss happens,\n  /// until tiles are loaded or timeout\n  /// @param[out] ndt3 stores the map we got\n  ///\n  /// @return true on succeed, else false. we may fails when there is a cache miss\n  /// in blocking mode\n  bool getMap(int layer_id, const MapScope& scope, bool blocking,\n              std::shared_ptr<Ndt3Interface>* ndt3);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @param layer_item[in] a layer item contains nessecery infomation\n  /// to add one layer\n  ///\n  /// @return true on succeed, else false\n  bool addLayer(const proto::config::MapLayerItem& layer_item);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @return the layer id of the layer we add\n  int addLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief save the map into database\n  ///\n  /// @return true on succeed, else false\n  bool save();\n\n  /// @brief get one maplayer\n  ///\n  /// @param layer_id[in] specify which layer to get\n  ///\n  /// @return a const ref of\n  std::shared_ptr<const MapLayer> getLayer(int layer_id);\n\n  /// @brief get one maplayer\n  ///\n  /// @param type_name[in] such as ndt3_corner...\n  ///\n  /// @return map layer got\n  std::shared_ptr<const MapLayer> getLayer(const std::string& type_name, float grid_size, float tile_size);\n\n private:\n  static std::shared_ptr<LocalDatabase> database_;\n  static LocalDatabase::MODE database_operation_mode_;\n  static proto::map::MapInfo map_info_;\n\n  std::map<int, std::shared_ptr<MapLayer>> layers_;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h"
		}
	}
]
I0402 15:57:32.759187  6725 json_parser.cpp:18] 
[
	51,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/eigen_types.h\"\n\n#include \"common/proto/config/config_map.pb.h\"\n\n#include \"lidar_map.h\"\n#include \"local_database.h\"\n#include \"map_layer.h\"\n#include \"map_scope.h\"\n#include \"ndt3interface.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass LidarMapOffline : public LidarMap {\n public:\n  /// @brief configure the LidarMapOffline class, mainly static members\n  /// which shared by all LidarMapOffline instance, such as database\n  ///\n  /// @param mode[in] specify the database operation mode, read, write, create...\n  ///\n  /// @note this should be called first before any operation about\n  /// LidarMapOffline\n  static bool configure(LocalDatabase::MODE mode);\n\n  /// @brief get the cache range(in number of tiles)\n  static int getCacheRange() { return LidarMap::cache_range_; }\n\n  /// @brief get the watermark of tile cache\n  static int getCacheMargin() { return LidarMap::cache_margin_; }\n\n  /// @brief implimention of LidarMap::initializeLayer, see LidarMap for more infomation\n  bool initializeLayer(int layer_id) override;\n\n  /// @brief initialize a layer by specify type_name, grid_size and tile\n  /// @return the layer_id of the initilized layer, if failed, a negtive number will be returned\n  int initializeLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief implimention of LidarMap::addPointCloud, see LidarMap for more infomation\n  bool addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) override;\n\n  /// @brief load the map to cache\n  /// @param[in] pos the center of the region to be loaded\n  /// @return true on succeed, else false\n  bool load(const Eigen::Vector3f& pos);\n\n  /// @brief Get the map of a layer in specific region\n  ///\n  /// @param layer_id[in] specify which layer to get\n  /// @param[in] scope specifies the submap region.\n  /// @param[in] blocking if is true, this call will block if cache miss happens,\n  /// until tiles are loaded or timeout\n  /// @param[out] ndt3 stores the map we got\n  ///\n  /// @return true on succeed, else false. we may fails when there is a cache miss\n  /// in blocking mode\n  bool getMap(int layer_id, const MapScope& scope, bool blocking,\n              std::shared_ptr<Ndt3Interface>* ndt3);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @param layer_item[in] a layer item contains nessecery infomation\n  /// to add one layer\n  ///\n  /// @return true on succeed, else false\n  bool addLayer(const proto::config::MapLayerItem& layer_item);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @return the layer id of the layer we add\n  int addLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief save the map into database\n  ///\n  /// @return true on succeed, else false\n  bool save();\n\n  /// @brief get one maplayer\n  ///\n  /// @param layer_id[in] specify which layer to get\n  ///\n  /// @return a const ref o\n  std::shared_ptr<const MapLayer> getLayer(int layer_id);\n\n  /// @brief get one maplayer\n  ///\n  /// @param type_name[in] such as ndt3_corner...\n  ///\n  /// @return map layer got\n  std::shared_ptr<const MapLayer> getLayer(const std::string& type_name, float grid_size, float tile_size);\n\n private:\n  static std::shared_ptr<LocalDatabase> database_;\n  static LocalDatabase::MODE database_operation_mode_;\n  static proto::map::MapInfo map_info_;\n\n  std::map<int, std::shared_ptr<MapLayer>> layers_;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h"
		}
	}
]
I0402 15:57:32.791417  6725 json_parser.cpp:18] 
[
	52,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/eigen_types.h\"\n\n#include \"common/proto/config/config_map.pb.h\"\n\n#include \"lidar_map.h\"\n#include \"local_database.h\"\n#include \"map_layer.h\"\n#include \"map_scope.h\"\n#include \"ndt3interface.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass LidarMapOffline : public LidarMap {\n public:\n  /// @brief configure the LidarMapOffline class, mainly static members\n  /// which shared by all LidarMapOffline instance, such as database\n  ///\n  /// @param mode[in] specify the database operation mode, read, write, create...\n  ///\n  /// @note this should be called first before any operation about\n  /// LidarMapOffline\n  static bool configure(LocalDatabase::MODE mode);\n\n  /// @brief get the cache range(in number of tiles)\n  static int getCacheRange() { return LidarMap::cache_range_; }\n\n  /// @brief get the watermark of tile cache\n  static int getCacheMargin() { return LidarMap::cache_margin_; }\n\n  /// @brief implimention of LidarMap::initializeLayer, see LidarMap for more infomation\n  bool initializeLayer(int layer_id) override;\n\n  /// @brief initialize a layer by specify type_name, grid_size and tile\n  /// @return the layer_id of the initilized layer, if failed, a negtive number will be returned\n  int initializeLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief implimention of LidarMap::addPointCloud, see LidarMap for more infomation\n  bool addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) override;\n\n  /// @brief load the map to cache\n  /// @param[in] pos the center of the region to be loaded\n  /// @return true on succeed, else false\n  bool load(const Eigen::Vector3f& pos);\n\n  /// @brief Get the map of a layer in specific region\n  ///\n  /// @param layer_id[in] specify which layer to get\n  /// @param[in] scope specifies the submap region.\n  /// @param[in] blocking if is true, this call will block if cache miss happens,\n  /// until tiles are loaded or timeout\n  /// @param[out] ndt3 stores the map we got\n  ///\n  /// @return true on succeed, else false. we may fails when there is a cache miss\n  /// in blocking mode\n  bool getMap(int layer_id, const MapScope& scope, bool blocking,\n              std::shared_ptr<Ndt3Interface>* ndt3);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @param layer_item[in] a layer item contains nessecery infomation\n  /// to add one layer\n  ///\n  /// @return true on succeed, else false\n  bool addLayer(const proto::config::MapLayerItem& layer_item);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @return the layer id of the layer we add\n  int addLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief save the map into database\n  ///\n  /// @return true on succeed, else false\n  bool save();\n\n  /// @brief get one maplayer\n  ///\n  /// @param layer_id[in] specify which layer to get\n  ///\n  /// @return a const ref \n  std::shared_ptr<const MapLayer> getLayer(int layer_id);\n\n  /// @brief get one maplayer\n  ///\n  /// @param type_name[in] such as ndt3_corner...\n  ///\n  /// @return map layer got\n  std::shared_ptr<const MapLayer> getLayer(const std::string& type_name, float grid_size, float tile_size);\n\n private:\n  static std::shared_ptr<LocalDatabase> database_;\n  static LocalDatabase::MODE database_operation_mode_;\n  static proto::map::MapInfo map_info_;\n\n  std::map<int, std::shared_ptr<MapLayer>> layers_;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h"
		}
	}
]
I0402 15:57:32.831897  6725 json_parser.cpp:18] 
[
	53,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/eigen_types.h\"\n\n#include \"common/proto/config/config_map.pb.h\"\n\n#include \"lidar_map.h\"\n#include \"local_database.h\"\n#include \"map_layer.h\"\n#include \"map_scope.h\"\n#include \"ndt3interface.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass LidarMapOffline : public LidarMap {\n public:\n  /// @brief configure the LidarMapOffline class, mainly static members\n  /// which shared by all LidarMapOffline instance, such as database\n  ///\n  /// @param mode[in] specify the database operation mode, read, write, create...\n  ///\n  /// @note this should be called first before any operation about\n  /// LidarMapOffline\n  static bool configure(LocalDatabase::MODE mode);\n\n  /// @brief get the cache range(in number of tiles)\n  static int getCacheRange() { return LidarMap::cache_range_; }\n\n  /// @brief get the watermark of tile cache\n  static int getCacheMargin() { return LidarMap::cache_margin_; }\n\n  /// @brief implimention of LidarMap::initializeLayer, see LidarMap for more infomation\n  bool initializeLayer(int layer_id) override;\n\n  /// @brief initialize a layer by specify type_name, grid_size and tile\n  /// @return the layer_id of the initilized layer, if failed, a negtive number will be returned\n  int initializeLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief implimention of LidarMap::addPointCloud, see LidarMap for more infomation\n  bool addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) override;\n\n  /// @brief load the map to cache\n  /// @param[in] pos the center of the region to be loaded\n  /// @return true on succeed, else false\n  bool load(const Eigen::Vector3f& pos);\n\n  /// @brief Get the map of a layer in specific region\n  ///\n  /// @param layer_id[in] specify which layer to get\n  /// @param[in] scope specifies the submap region.\n  /// @param[in] blocking if is true, this call will block if cache miss happens,\n  /// until tiles are loaded or timeout\n  /// @param[out] ndt3 stores the map we got\n  ///\n  /// @return true on succeed, else false. we may fails when there is a cache miss\n  /// in blocking mode\n  bool getMap(int layer_id, const MapScope& scope, bool blocking,\n              std::shared_ptr<Ndt3Interface>* ndt3);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @param layer_item[in] a layer item contains nessecery infomation\n  /// to add one layer\n  ///\n  /// @return true on succeed, else false\n  bool addLayer(const proto::config::MapLayerItem& layer_item);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @return the layer id of the layer we add\n  int addLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief save the map into database\n  ///\n  /// @return true on succeed, else false\n  bool save();\n\n  /// @brief get one maplayer\n  ///\n  /// @param layer_id[in] specify which layer to get\n  ///\n  /// @return a const ref\n  std::shared_ptr<const MapLayer> getLayer(int layer_id);\n\n  /// @brief get one maplayer\n  ///\n  /// @param type_name[in] such as ndt3_corner...\n  ///\n  /// @return map layer got\n  std::shared_ptr<const MapLayer> getLayer(const std::string& type_name, float grid_size, float tile_size);\n\n private:\n  static std::shared_ptr<LocalDatabase> database_;\n  static LocalDatabase::MODE database_operation_mode_;\n  static proto::map::MapInfo map_info_;\n\n  std::map<int, std::shared_ptr<MapLayer>> layers_;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h"
		}
	}
]
I0402 15:57:32.872051  6725 json_parser.cpp:18] 
[
	54,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/eigen_types.h\"\n\n#include \"common/proto/config/config_map.pb.h\"\n\n#include \"lidar_map.h\"\n#include \"local_database.h\"\n#include \"map_layer.h\"\n#include \"map_scope.h\"\n#include \"ndt3interface.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass LidarMapOffline : public LidarMap {\n public:\n  /// @brief configure the LidarMapOffline class, mainly static members\n  /// which shared by all LidarMapOffline instance, such as database\n  ///\n  /// @param mode[in] specify the database operation mode, read, write, create...\n  ///\n  /// @note this should be called first before any operation about\n  /// LidarMapOffline\n  static bool configure(LocalDatabase::MODE mode);\n\n  /// @brief get the cache range(in number of tiles)\n  static int getCacheRange() { return LidarMap::cache_range_; }\n\n  /// @brief get the watermark of tile cache\n  static int getCacheMargin() { return LidarMap::cache_margin_; }\n\n  /// @brief implimention of LidarMap::initializeLayer, see LidarMap for more infomation\n  bool initializeLayer(int layer_id) override;\n\n  /// @brief initialize a layer by specify type_name, grid_size and tile\n  /// @return the layer_id of the initilized layer, if failed, a negtive number will be returned\n  int initializeLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief implimention of LidarMap::addPointCloud, see LidarMap for more infomation\n  bool addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) override;\n\n  /// @brief load the map to cache\n  /// @param[in] pos the center of the region to be loaded\n  /// @return true on succeed, else false\n  bool load(const Eigen::Vector3f& pos);\n\n  /// @brief Get the map of a layer in specific region\n  ///\n  /// @param layer_id[in] specify which layer to get\n  /// @param[in] scope specifies the submap region.\n  /// @param[in] blocking if is true, this call will block if cache miss happens,\n  /// until tiles are loaded or timeout\n  /// @param[out] ndt3 stores the map we got\n  ///\n  /// @return true on succeed, else false. we may fails when there is a cache miss\n  /// in blocking mode\n  bool getMap(int layer_id, const MapScope& scope, bool blocking,\n              std::shared_ptr<Ndt3Interface>* ndt3);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @param layer_item[in] a layer item contains nessecery infomation\n  /// to add one layer\n  ///\n  /// @return true on succeed, else false\n  bool addLayer(const proto::config::MapLayerItem& layer_item);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @return the layer id of the layer we add\n  int addLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief save the map into database\n  ///\n  /// @return true on succeed, else false\n  bool save();\n\n  /// @brief get one maplayer\n  ///\n  /// @param layer_id[in] specify which layer to get\n  ///\n  /// @return a const re\n  std::shared_ptr<const MapLayer> getLayer(int layer_id);\n\n  /// @brief get one maplayer\n  ///\n  /// @param type_name[in] such as ndt3_corner...\n  ///\n  /// @return map layer got\n  std::shared_ptr<const MapLayer> getLayer(const std::string& type_name, float grid_size, float tile_size);\n\n private:\n  static std::shared_ptr<LocalDatabase> database_;\n  static LocalDatabase::MODE database_operation_mode_;\n  static proto::map::MapInfo map_info_;\n\n  std::map<int, std::shared_ptr<MapLayer>> layers_;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h"
		}
	}
]
I0402 15:57:32.917392  6725 json_parser.cpp:18] 
[
	55,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/eigen_types.h\"\n\n#include \"common/proto/config/config_map.pb.h\"\n\n#include \"lidar_map.h\"\n#include \"local_database.h\"\n#include \"map_layer.h\"\n#include \"map_scope.h\"\n#include \"ndt3interface.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass LidarMapOffline : public LidarMap {\n public:\n  /// @brief configure the LidarMapOffline class, mainly static members\n  /// which shared by all LidarMapOffline instance, such as database\n  ///\n  /// @param mode[in] specify the database operation mode, read, write, create...\n  ///\n  /// @note this should be called first before any operation about\n  /// LidarMapOffline\n  static bool configure(LocalDatabase::MODE mode);\n\n  /// @brief get the cache range(in number of tiles)\n  static int getCacheRange() { return LidarMap::cache_range_; }\n\n  /// @brief get the watermark of tile cache\n  static int getCacheMargin() { return LidarMap::cache_margin_; }\n\n  /// @brief implimention of LidarMap::initializeLayer, see LidarMap for more infomation\n  bool initializeLayer(int layer_id) override;\n\n  /// @brief initialize a layer by specify type_name, grid_size and tile\n  /// @return the layer_id of the initilized layer, if failed, a negtive number will be returned\n  int initializeLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief implimention of LidarMap::addPointCloud, see LidarMap for more infomation\n  bool addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) override;\n\n  /// @brief load the map to cache\n  /// @param[in] pos the center of the region to be loaded\n  /// @return true on succeed, else false\n  bool load(const Eigen::Vector3f& pos);\n\n  /// @brief Get the map of a layer in specific region\n  ///\n  /// @param layer_id[in] specify which layer to get\n  /// @param[in] scope specifies the submap region.\n  /// @param[in] blocking if is true, this call will block if cache miss happens,\n  /// until tiles are loaded or timeout\n  /// @param[out] ndt3 stores the map we got\n  ///\n  /// @return true on succeed, else false. we may fails when there is a cache miss\n  /// in blocking mode\n  bool getMap(int layer_id, const MapScope& scope, bool blocking,\n              std::shared_ptr<Ndt3Interface>* ndt3);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @param layer_item[in] a layer item contains nessecery infomation\n  /// to add one layer\n  ///\n  /// @return true on succeed, else false\n  bool addLayer(const proto::config::MapLayerItem& layer_item);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @return the layer id of the layer we add\n  int addLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief save the map into database\n  ///\n  /// @return true on succeed, else false\n  bool save();\n\n  /// @brief get one maplayer\n  ///\n  /// @param layer_id[in] specify which layer to get\n  ///\n  /// @return a const r\n  std::shared_ptr<const MapLayer> getLayer(int layer_id);\n\n  /// @brief get one maplayer\n  ///\n  /// @param type_name[in] such as ndt3_corner...\n  ///\n  /// @return map layer got\n  std::shared_ptr<const MapLayer> getLayer(const std::string& type_name, float grid_size, float tile_size);\n\n private:\n  static std::shared_ptr<LocalDatabase> database_;\n  static LocalDatabase::MODE database_operation_mode_;\n  static proto::map::MapInfo map_info_;\n\n  std::map<int, std::shared_ptr<MapLayer>> layers_;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h"
		}
	}
]
I0402 15:57:32.959376  6725 json_parser.cpp:18] 
[
	56,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/eigen_types.h\"\n\n#include \"common/proto/config/config_map.pb.h\"\n\n#include \"lidar_map.h\"\n#include \"local_database.h\"\n#include \"map_layer.h\"\n#include \"map_scope.h\"\n#include \"ndt3interface.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass LidarMapOffline : public LidarMap {\n public:\n  /// @brief configure the LidarMapOffline class, mainly static members\n  /// which shared by all LidarMapOffline instance, such as database\n  ///\n  /// @param mode[in] specify the database operation mode, read, write, create...\n  ///\n  /// @note this should be called first before any operation about\n  /// LidarMapOffline\n  static bool configure(LocalDatabase::MODE mode);\n\n  /// @brief get the cache range(in number of tiles)\n  static int getCacheRange() { return LidarMap::cache_range_; }\n\n  /// @brief get the watermark of tile cache\n  static int getCacheMargin() { return LidarMap::cache_margin_; }\n\n  /// @brief implimention of LidarMap::initializeLayer, see LidarMap for more infomation\n  bool initializeLayer(int layer_id) override;\n\n  /// @brief initialize a layer by specify type_name, grid_size and tile\n  /// @return the layer_id of the initilized layer, if failed, a negtive number will be returned\n  int initializeLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief implimention of LidarMap::addPointCloud, see LidarMap for more infomation\n  bool addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) override;\n\n  /// @brief load the map to cache\n  /// @param[in] pos the center of the region to be loaded\n  /// @return true on succeed, else false\n  bool load(const Eigen::Vector3f& pos);\n\n  /// @brief Get the map of a layer in specific region\n  ///\n  /// @param layer_id[in] specify which layer to get\n  /// @param[in] scope specifies the submap region.\n  /// @param[in] blocking if is true, this call will block if cache miss happens,\n  /// until tiles are loaded or timeout\n  /// @param[out] ndt3 stores the map we got\n  ///\n  /// @return true on succeed, else false. we may fails when there is a cache miss\n  /// in blocking mode\n  bool getMap(int layer_id, const MapScope& scope, bool blocking,\n              std::shared_ptr<Ndt3Interface>* ndt3);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @param layer_item[in] a layer item contains nessecery infomation\n  /// to add one layer\n  ///\n  /// @return true on succeed, else false\n  bool addLayer(const proto::config::MapLayerItem& layer_item);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @return the layer id of the layer we add\n  int addLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief save the map into database\n  ///\n  /// @return true on succeed, else false\n  bool save();\n\n  /// @brief get one maplayer\n  ///\n  /// @param layer_id[in] specify which layer to get\n  ///\n  /// @return a const \n  std::shared_ptr<const MapLayer> getLayer(int layer_id);\n\n  /// @brief get one maplayer\n  ///\n  /// @param type_name[in] such as ndt3_corner...\n  ///\n  /// @return map layer got\n  std::shared_ptr<const MapLayer> getLayer(const std::string& type_name, float grid_size, float tile_size);\n\n private:\n  static std::shared_ptr<LocalDatabase> database_;\n  static LocalDatabase::MODE database_operation_mode_;\n  static proto::map::MapInfo map_info_;\n\n  std::map<int, std::shared_ptr<MapLayer>> layers_;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h"
		}
	}
]
I0402 15:57:32.994421  6725 json_parser.cpp:18] 
[
	57,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/eigen_types.h\"\n\n#include \"common/proto/config/config_map.pb.h\"\n\n#include \"lidar_map.h\"\n#include \"local_database.h\"\n#include \"map_layer.h\"\n#include \"map_scope.h\"\n#include \"ndt3interface.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass LidarMapOffline : public LidarMap {\n public:\n  /// @brief configure the LidarMapOffline class, mainly static members\n  /// which shared by all LidarMapOffline instance, such as database\n  ///\n  /// @param mode[in] specify the database operation mode, read, write, create...\n  ///\n  /// @note this should be called first before any operation about\n  /// LidarMapOffline\n  static bool configure(LocalDatabase::MODE mode);\n\n  /// @brief get the cache range(in number of tiles)\n  static int getCacheRange() { return LidarMap::cache_range_; }\n\n  /// @brief get the watermark of tile cache\n  static int getCacheMargin() { return LidarMap::cache_margin_; }\n\n  /// @brief implimention of LidarMap::initializeLayer, see LidarMap for more infomation\n  bool initializeLayer(int layer_id) override;\n\n  /// @brief initialize a layer by specify type_name, grid_size and tile\n  /// @return the layer_id of the initilized layer, if failed, a negtive number will be returned\n  int initializeLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief implimention of LidarMap::addPointCloud, see LidarMap for more infomation\n  bool addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) override;\n\n  /// @brief load the map to cache\n  /// @param[in] pos the center of the region to be loaded\n  /// @return true on succeed, else false\n  bool load(const Eigen::Vector3f& pos);\n\n  /// @brief Get the map of a layer in specific region\n  ///\n  /// @param layer_id[in] specify which layer to get\n  /// @param[in] scope specifies the submap region.\n  /// @param[in] blocking if is true, this call will block if cache miss happens,\n  /// until tiles are loaded or timeout\n  /// @param[out] ndt3 stores the map we got\n  ///\n  /// @return true on succeed, else false. we may fails when there is a cache miss\n  /// in blocking mode\n  bool getMap(int layer_id, const MapScope& scope, bool blocking,\n              std::shared_ptr<Ndt3Interface>* ndt3);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @param layer_item[in] a layer item contains nessecery infomation\n  /// to add one layer\n  ///\n  /// @return true on succeed, else false\n  bool addLayer(const proto::config::MapLayerItem& layer_item);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @return the layer id of the layer we add\n  int addLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief save the map into database\n  ///\n  /// @return true on succeed, else false\n  bool save();\n\n  /// @brief get one maplayer\n  ///\n  /// @param layer_id[in] specify which layer to get\n  ///\n  /// @return a const\n  std::shared_ptr<const MapLayer> getLayer(int layer_id);\n\n  /// @brief get one maplayer\n  ///\n  /// @param type_name[in] such as ndt3_corner...\n  ///\n  /// @return map layer got\n  std::shared_ptr<const MapLayer> getLayer(const std::string& type_name, float grid_size, float tile_size);\n\n private:\n  static std::shared_ptr<LocalDatabase> database_;\n  static LocalDatabase::MODE database_operation_mode_;\n  static proto::map::MapInfo map_info_;\n\n  std::map<int, std::shared_ptr<MapLayer>> layers_;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h"
		}
	}
]
I0402 15:57:33.032042  6725 json_parser.cpp:18] 
[
	58,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/eigen_types.h\"\n\n#include \"common/proto/config/config_map.pb.h\"\n\n#include \"lidar_map.h\"\n#include \"local_database.h\"\n#include \"map_layer.h\"\n#include \"map_scope.h\"\n#include \"ndt3interface.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass LidarMapOffline : public LidarMap {\n public:\n  /// @brief configure the LidarMapOffline class, mainly static members\n  /// which shared by all LidarMapOffline instance, such as database\n  ///\n  /// @param mode[in] specify the database operation mode, read, write, create...\n  ///\n  /// @note this should be called first before any operation about\n  /// LidarMapOffline\n  static bool configure(LocalDatabase::MODE mode);\n\n  /// @brief get the cache range(in number of tiles)\n  static int getCacheRange() { return LidarMap::cache_range_; }\n\n  /// @brief get the watermark of tile cache\n  static int getCacheMargin() { return LidarMap::cache_margin_; }\n\n  /// @brief implimention of LidarMap::initializeLayer, see LidarMap for more infomation\n  bool initializeLayer(int layer_id) override;\n\n  /// @brief initialize a layer by specify type_name, grid_size and tile\n  /// @return the layer_id of the initilized layer, if failed, a negtive number will be returned\n  int initializeLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief implimention of LidarMap::addPointCloud, see LidarMap for more infomation\n  bool addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) override;\n\n  /// @brief load the map to cache\n  /// @param[in] pos the center of the region to be loaded\n  /// @return true on succeed, else false\n  bool load(const Eigen::Vector3f& pos);\n\n  /// @brief Get the map of a layer in specific region\n  ///\n  /// @param layer_id[in] specify which layer to get\n  /// @param[in] scope specifies the submap region.\n  /// @param[in] blocking if is true, this call will block if cache miss happens,\n  /// until tiles are loaded or timeout\n  /// @param[out] ndt3 stores the map we got\n  ///\n  /// @return true on succeed, else false. we may fails when there is a cache miss\n  /// in blocking mode\n  bool getMap(int layer_id, const MapScope& scope, bool blocking,\n              std::shared_ptr<Ndt3Interface>* ndt3);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @param layer_item[in] a layer item contains nessecery infomation\n  /// to add one layer\n  ///\n  /// @return true on succeed, else false\n  bool addLayer(const proto::config::MapLayerItem& layer_item);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @return the layer id of the layer we add\n  int addLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief save the map into database\n  ///\n  /// @return true on succeed, else false\n  bool save();\n\n  /// @brief get one maplayer\n  ///\n  /// @param layer_id[in] specify which layer to get\n  ///\n  /// @return a cons\n  std::shared_ptr<const MapLayer> getLayer(int layer_id);\n\n  /// @brief get one maplayer\n  ///\n  /// @param type_name[in] such as ndt3_corner...\n  ///\n  /// @return map layer got\n  std::shared_ptr<const MapLayer> getLayer(const std::string& type_name, float grid_size, float tile_size);\n\n private:\n  static std::shared_ptr<LocalDatabase> database_;\n  static LocalDatabase::MODE database_operation_mode_;\n  static proto::map::MapInfo map_info_;\n\n  std::map<int, std::shared_ptr<MapLayer>> layers_;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h"
		}
	}
]
I0402 15:57:33.073081  6725 json_parser.cpp:18] 
[
	59,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/eigen_types.h\"\n\n#include \"common/proto/config/config_map.pb.h\"\n\n#include \"lidar_map.h\"\n#include \"local_database.h\"\n#include \"map_layer.h\"\n#include \"map_scope.h\"\n#include \"ndt3interface.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass LidarMapOffline : public LidarMap {\n public:\n  /// @brief configure the LidarMapOffline class, mainly static members\n  /// which shared by all LidarMapOffline instance, such as database\n  ///\n  /// @param mode[in] specify the database operation mode, read, write, create...\n  ///\n  /// @note this should be called first before any operation about\n  /// LidarMapOffline\n  static bool configure(LocalDatabase::MODE mode);\n\n  /// @brief get the cache range(in number of tiles)\n  static int getCacheRange() { return LidarMap::cache_range_; }\n\n  /// @brief get the watermark of tile cache\n  static int getCacheMargin() { return LidarMap::cache_margin_; }\n\n  /// @brief implimention of LidarMap::initializeLayer, see LidarMap for more infomation\n  bool initializeLayer(int layer_id) override;\n\n  /// @brief initialize a layer by specify type_name, grid_size and tile\n  /// @return the layer_id of the initilized layer, if failed, a negtive number will be returned\n  int initializeLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief implimention of LidarMap::addPointCloud, see LidarMap for more infomation\n  bool addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) override;\n\n  /// @brief load the map to cache\n  /// @param[in] pos the center of the region to be loaded\n  /// @return true on succeed, else false\n  bool load(const Eigen::Vector3f& pos);\n\n  /// @brief Get the map of a layer in specific region\n  ///\n  /// @param layer_id[in] specify which layer to get\n  /// @param[in] scope specifies the submap region.\n  /// @param[in] blocking if is true, this call will block if cache miss happens,\n  /// until tiles are loaded or timeout\n  /// @param[out] ndt3 stores the map we got\n  ///\n  /// @return true on succeed, else false. we may fails when there is a cache miss\n  /// in blocking mode\n  bool getMap(int layer_id, const MapScope& scope, bool blocking,\n              std::shared_ptr<Ndt3Interface>* ndt3);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @param layer_item[in] a layer item contains nessecery infomation\n  /// to add one layer\n  ///\n  /// @return true on succeed, else false\n  bool addLayer(const proto::config::MapLayerItem& layer_item);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @return the layer id of the layer we add\n  int addLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief save the map into database\n  ///\n  /// @return true on succeed, else false\n  bool save();\n\n  /// @brief get one maplayer\n  ///\n  /// @param layer_id[in] specify which layer to get\n  ///\n  /// @return a con\n  std::shared_ptr<const MapLayer> getLayer(int layer_id);\n\n  /// @brief get one maplayer\n  ///\n  /// @param type_name[in] such as ndt3_corner...\n  ///\n  /// @return map layer got\n  std::shared_ptr<const MapLayer> getLayer(const std::string& type_name, float grid_size, float tile_size);\n\n private:\n  static std::shared_ptr<LocalDatabase> database_;\n  static LocalDatabase::MODE database_operation_mode_;\n  static proto::map::MapInfo map_info_;\n\n  std::map<int, std::shared_ptr<MapLayer>> layers_;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h"
		}
	}
]
I0402 15:57:33.113411  6725 json_parser.cpp:18] 
[
	60,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/eigen_types.h\"\n\n#include \"common/proto/config/config_map.pb.h\"\n\n#include \"lidar_map.h\"\n#include \"local_database.h\"\n#include \"map_layer.h\"\n#include \"map_scope.h\"\n#include \"ndt3interface.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass LidarMapOffline : public LidarMap {\n public:\n  /// @brief configure the LidarMapOffline class, mainly static members\n  /// which shared by all LidarMapOffline instance, such as database\n  ///\n  /// @param mode[in] specify the database operation mode, read, write, create...\n  ///\n  /// @note this should be called first before any operation about\n  /// LidarMapOffline\n  static bool configure(LocalDatabase::MODE mode);\n\n  /// @brief get the cache range(in number of tiles)\n  static int getCacheRange() { return LidarMap::cache_range_; }\n\n  /// @brief get the watermark of tile cache\n  static int getCacheMargin() { return LidarMap::cache_margin_; }\n\n  /// @brief implimention of LidarMap::initializeLayer, see LidarMap for more infomation\n  bool initializeLayer(int layer_id) override;\n\n  /// @brief initialize a layer by specify type_name, grid_size and tile\n  /// @return the layer_id of the initilized layer, if failed, a negtive number will be returned\n  int initializeLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief implimention of LidarMap::addPointCloud, see LidarMap for more infomation\n  bool addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) override;\n\n  /// @brief load the map to cache\n  /// @param[in] pos the center of the region to be loaded\n  /// @return true on succeed, else false\n  bool load(const Eigen::Vector3f& pos);\n\n  /// @brief Get the map of a layer in specific region\n  ///\n  /// @param layer_id[in] specify which layer to get\n  /// @param[in] scope specifies the submap region.\n  /// @param[in] blocking if is true, this call will block if cache miss happens,\n  /// until tiles are loaded or timeout\n  /// @param[out] ndt3 stores the map we got\n  ///\n  /// @return true on succeed, else false. we may fails when there is a cache miss\n  /// in blocking mode\n  bool getMap(int layer_id, const MapScope& scope, bool blocking,\n              std::shared_ptr<Ndt3Interface>* ndt3);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @param layer_item[in] a layer item contains nessecery infomation\n  /// to add one layer\n  ///\n  /// @return true on succeed, else false\n  bool addLayer(const proto::config::MapLayerItem& layer_item);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @return the layer id of the layer we add\n  int addLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief save the map into database\n  ///\n  /// @return true on succeed, else false\n  bool save();\n\n  /// @brief get one maplayer\n  ///\n  /// @param layer_id[in] specify which layer to get\n  ///\n  /// @return a co\n  std::shared_ptr<const MapLayer> getLayer(int layer_id);\n\n  /// @brief get one maplayer\n  ///\n  /// @param type_name[in] such as ndt3_corner...\n  ///\n  /// @return map layer got\n  std::shared_ptr<const MapLayer> getLayer(const std::string& type_name, float grid_size, float tile_size);\n\n private:\n  static std::shared_ptr<LocalDatabase> database_;\n  static LocalDatabase::MODE database_operation_mode_;\n  static proto::map::MapInfo map_info_;\n\n  std::map<int, std::shared_ptr<MapLayer>> layers_;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h"
		}
	}
]
I0402 15:57:33.157629  6725 json_parser.cpp:18] 
[
	61,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/eigen_types.h\"\n\n#include \"common/proto/config/config_map.pb.h\"\n\n#include \"lidar_map.h\"\n#include \"local_database.h\"\n#include \"map_layer.h\"\n#include \"map_scope.h\"\n#include \"ndt3interface.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass LidarMapOffline : public LidarMap {\n public:\n  /// @brief configure the LidarMapOffline class, mainly static members\n  /// which shared by all LidarMapOffline instance, such as database\n  ///\n  /// @param mode[in] specify the database operation mode, read, write, create...\n  ///\n  /// @note this should be called first before any operation about\n  /// LidarMapOffline\n  static bool configure(LocalDatabase::MODE mode);\n\n  /// @brief get the cache range(in number of tiles)\n  static int getCacheRange() { return LidarMap::cache_range_; }\n\n  /// @brief get the watermark of tile cache\n  static int getCacheMargin() { return LidarMap::cache_margin_; }\n\n  /// @brief implimention of LidarMap::initializeLayer, see LidarMap for more infomation\n  bool initializeLayer(int layer_id) override;\n\n  /// @brief initialize a layer by specify type_name, grid_size and tile\n  /// @return the layer_id of the initilized layer, if failed, a negtive number will be returned\n  int initializeLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief implimention of LidarMap::addPointCloud, see LidarMap for more infomation\n  bool addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) override;\n\n  /// @brief load the map to cache\n  /// @param[in] pos the center of the region to be loaded\n  /// @return true on succeed, else false\n  bool load(const Eigen::Vector3f& pos);\n\n  /// @brief Get the map of a layer in specific region\n  ///\n  /// @param layer_id[in] specify which layer to get\n  /// @param[in] scope specifies the submap region.\n  /// @param[in] blocking if is true, this call will block if cache miss happens,\n  /// until tiles are loaded or timeout\n  /// @param[out] ndt3 stores the map we got\n  ///\n  /// @return true on succeed, else false. we may fails when there is a cache miss\n  /// in blocking mode\n  bool getMap(int layer_id, const MapScope& scope, bool blocking,\n              std::shared_ptr<Ndt3Interface>* ndt3);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @param layer_item[in] a layer item contains nessecery infomation\n  /// to add one layer\n  ///\n  /// @return true on succeed, else false\n  bool addLayer(const proto::config::MapLayerItem& layer_item);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @return the layer id of the layer we add\n  int addLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief save the map into database\n  ///\n  /// @return true on succeed, else false\n  bool save();\n\n  /// @brief get one maplayer\n  ///\n  /// @param layer_id[in] specify which layer to get\n  ///\n  /// @return a c\n  std::shared_ptr<const MapLayer> getLayer(int layer_id);\n\n  /// @brief get one maplayer\n  ///\n  /// @param type_name[in] such as ndt3_corner...\n  ///\n  /// @return map layer got\n  std::shared_ptr<const MapLayer> getLayer(const std::string& type_name, float grid_size, float tile_size);\n\n private:\n  static std::shared_ptr<LocalDatabase> database_;\n  static LocalDatabase::MODE database_operation_mode_;\n  static proto::map::MapInfo map_info_;\n\n  std::map<int, std::shared_ptr<MapLayer>> layers_;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h"
		}
	}
]
I0402 15:57:33.204433  6725 json_parser.cpp:18] 
[
	62,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/eigen_types.h\"\n\n#include \"common/proto/config/config_map.pb.h\"\n\n#include \"lidar_map.h\"\n#include \"local_database.h\"\n#include \"map_layer.h\"\n#include \"map_scope.h\"\n#include \"ndt3interface.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass LidarMapOffline : public LidarMap {\n public:\n  /// @brief configure the LidarMapOffline class, mainly static members\n  /// which shared by all LidarMapOffline instance, such as database\n  ///\n  /// @param mode[in] specify the database operation mode, read, write, create...\n  ///\n  /// @note this should be called first before any operation about\n  /// LidarMapOffline\n  static bool configure(LocalDatabase::MODE mode);\n\n  /// @brief get the cache range(in number of tiles)\n  static int getCacheRange() { return LidarMap::cache_range_; }\n\n  /// @brief get the watermark of tile cache\n  static int getCacheMargin() { return LidarMap::cache_margin_; }\n\n  /// @brief implimention of LidarMap::initializeLayer, see LidarMap for more infomation\n  bool initializeLayer(int layer_id) override;\n\n  /// @brief initialize a layer by specify type_name, grid_size and tile\n  /// @return the layer_id of the initilized layer, if failed, a negtive number will be returned\n  int initializeLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief implimention of LidarMap::addPointCloud, see LidarMap for more infomation\n  bool addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) override;\n\n  /// @brief load the map to cache\n  /// @param[in] pos the center of the region to be loaded\n  /// @return true on succeed, else false\n  bool load(const Eigen::Vector3f& pos);\n\n  /// @brief Get the map of a layer in specific region\n  ///\n  /// @param layer_id[in] specify which layer to get\n  /// @param[in] scope specifies the submap region.\n  /// @param[in] blocking if is true, this call will block if cache miss happens,\n  /// until tiles are loaded or timeout\n  /// @param[out] ndt3 stores the map we got\n  ///\n  /// @return true on succeed, else false. we may fails when there is a cache miss\n  /// in blocking mode\n  bool getMap(int layer_id, const MapScope& scope, bool blocking,\n              std::shared_ptr<Ndt3Interface>* ndt3);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @param layer_item[in] a layer item contains nessecery infomation\n  /// to add one layer\n  ///\n  /// @return true on succeed, else false\n  bool addLayer(const proto::config::MapLayerItem& layer_item);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @return the layer id of the layer we add\n  int addLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief save the map into database\n  ///\n  /// @return true on succeed, else false\n  bool save();\n\n  /// @brief get one maplayer\n  ///\n  /// @param layer_id[in] specify which layer to get\n  ///\n  /// @return a \n  std::shared_ptr<const MapLayer> getLayer(int layer_id);\n\n  /// @brief get one maplayer\n  ///\n  /// @param type_name[in] such as ndt3_corner...\n  ///\n  /// @return map layer got\n  std::shared_ptr<const MapLayer> getLayer(const std::string& type_name, float grid_size, float tile_size);\n\n private:\n  static std::shared_ptr<LocalDatabase> database_;\n  static LocalDatabase::MODE database_operation_mode_;\n  static proto::map::MapInfo map_info_;\n\n  std::map<int, std::shared_ptr<MapLayer>> layers_;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h"
		}
	}
]
I0402 15:57:33.235016  6725 json_parser.cpp:18] 
[
	63,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/eigen_types.h\"\n\n#include \"common/proto/config/config_map.pb.h\"\n\n#include \"lidar_map.h\"\n#include \"local_database.h\"\n#include \"map_layer.h\"\n#include \"map_scope.h\"\n#include \"ndt3interface.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass LidarMapOffline : public LidarMap {\n public:\n  /// @brief configure the LidarMapOffline class, mainly static members\n  /// which shared by all LidarMapOffline instance, such as database\n  ///\n  /// @param mode[in] specify the database operation mode, read, write, create...\n  ///\n  /// @note this should be called first before any operation about\n  /// LidarMapOffline\n  static bool configure(LocalDatabase::MODE mode);\n\n  /// @brief get the cache range(in number of tiles)\n  static int getCacheRange() { return LidarMap::cache_range_; }\n\n  /// @brief get the watermark of tile cache\n  static int getCacheMargin() { return LidarMap::cache_margin_; }\n\n  /// @brief implimention of LidarMap::initializeLayer, see LidarMap for more infomation\n  bool initializeLayer(int layer_id) override;\n\n  /// @brief initialize a layer by specify type_name, grid_size and tile\n  /// @return the layer_id of the initilized layer, if failed, a negtive number will be returned\n  int initializeLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief implimention of LidarMap::addPointCloud, see LidarMap for more infomation\n  bool addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) override;\n\n  /// @brief load the map to cache\n  /// @param[in] pos the center of the region to be loaded\n  /// @return true on succeed, else false\n  bool load(const Eigen::Vector3f& pos);\n\n  /// @brief Get the map of a layer in specific region\n  ///\n  /// @param layer_id[in] specify which layer to get\n  /// @param[in] scope specifies the submap region.\n  /// @param[in] blocking if is true, this call will block if cache miss happens,\n  /// until tiles are loaded or timeout\n  /// @param[out] ndt3 stores the map we got\n  ///\n  /// @return true on succeed, else false. we may fails when there is a cache miss\n  /// in blocking mode\n  bool getMap(int layer_id, const MapScope& scope, bool blocking,\n              std::shared_ptr<Ndt3Interface>* ndt3);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @param layer_item[in] a layer item contains nessecery infomation\n  /// to add one layer\n  ///\n  /// @return true on succeed, else false\n  bool addLayer(const proto::config::MapLayerItem& layer_item);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @return the layer id of the layer we add\n  int addLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief save the map into database\n  ///\n  /// @return true on succeed, else false\n  bool save();\n\n  /// @brief get one maplayer\n  ///\n  /// @param layer_id[in] specify which layer to get\n  ///\n  /// @return a\n  std::shared_ptr<const MapLayer> getLayer(int layer_id);\n\n  /// @brief get one maplayer\n  ///\n  /// @param type_name[in] such as ndt3_corner...\n  ///\n  /// @return map layer got\n  std::shared_ptr<const MapLayer> getLayer(const std::string& type_name, float grid_size, float tile_size);\n\n private:\n  static std::shared_ptr<LocalDatabase> database_;\n  static LocalDatabase::MODE database_operation_mode_;\n  static proto::map::MapInfo map_info_;\n\n  std::map<int, std::shared_ptr<MapLayer>> layers_;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h"
		}
	}
]
I0402 15:57:33.275151  6725 json_parser.cpp:18] 
[
	64,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/eigen_types.h\"\n\n#include \"common/proto/config/config_map.pb.h\"\n\n#include \"lidar_map.h\"\n#include \"local_database.h\"\n#include \"map_layer.h\"\n#include \"map_scope.h\"\n#include \"ndt3interface.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass LidarMapOffline : public LidarMap {\n public:\n  /// @brief configure the LidarMapOffline class, mainly static members\n  /// which shared by all LidarMapOffline instance, such as database\n  ///\n  /// @param mode[in] specify the database operation mode, read, write, create...\n  ///\n  /// @note this should be called first before any operation about\n  /// LidarMapOffline\n  static bool configure(LocalDatabase::MODE mode);\n\n  /// @brief get the cache range(in number of tiles)\n  static int getCacheRange() { return LidarMap::cache_range_; }\n\n  /// @brief get the watermark of tile cache\n  static int getCacheMargin() { return LidarMap::cache_margin_; }\n\n  /// @brief implimention of LidarMap::initializeLayer, see LidarMap for more infomation\n  bool initializeLayer(int layer_id) override;\n\n  /// @brief initialize a layer by specify type_name, grid_size and tile\n  /// @return the layer_id of the initilized layer, if failed, a negtive number will be returned\n  int initializeLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief implimention of LidarMap::addPointCloud, see LidarMap for more infomation\n  bool addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) override;\n\n  /// @brief load the map to cache\n  /// @param[in] pos the center of the region to be loaded\n  /// @return true on succeed, else false\n  bool load(const Eigen::Vector3f& pos);\n\n  /// @brief Get the map of a layer in specific region\n  ///\n  /// @param layer_id[in] specify which layer to get\n  /// @param[in] scope specifies the submap region.\n  /// @param[in] blocking if is true, this call will block if cache miss happens,\n  /// until tiles are loaded or timeout\n  /// @param[out] ndt3 stores the map we got\n  ///\n  /// @return true on succeed, else false. we may fails when there is a cache miss\n  /// in blocking mode\n  bool getMap(int layer_id, const MapScope& scope, bool blocking,\n              std::shared_ptr<Ndt3Interface>* ndt3);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @param layer_item[in] a layer item contains nessecery infomation\n  /// to add one layer\n  ///\n  /// @return true on succeed, else false\n  bool addLayer(const proto::config::MapLayerItem& layer_item);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @return the layer id of the layer we add\n  int addLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief save the map into database\n  ///\n  /// @return true on succeed, else false\n  bool save();\n\n  /// @brief get one maplayer\n  ///\n  /// @param layer_id[in] specify which layer to get\n  ///\n  /// @return \n  std::shared_ptr<const MapLayer> getLayer(int layer_id);\n\n  /// @brief get one maplayer\n  ///\n  /// @param type_name[in] such as ndt3_corner...\n  ///\n  /// @return map layer got\n  std::shared_ptr<const MapLayer> getLayer(const std::string& type_name, float grid_size, float tile_size);\n\n private:\n  static std::shared_ptr<LocalDatabase> database_;\n  static LocalDatabase::MODE database_operation_mode_;\n  static proto::map::MapInfo map_info_;\n\n  std::map<int, std::shared_ptr<MapLayer>> layers_;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h"
		}
	}
]
I0402 15:57:33.460811  6725 json_parser.cpp:18] 
[
	65,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/eigen_types.h\"\n\n#include \"common/proto/config/config_map.pb.h\"\n\n#include \"lidar_map.h\"\n#include \"local_database.h\"\n#include \"map_layer.h\"\n#include \"map_scope.h\"\n#include \"ndt3interface.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass LidarMapOffline : public LidarMap {\n public:\n  /// @brief configure the LidarMapOffline class, mainly static members\n  /// which shared by all LidarMapOffline instance, such as database\n  ///\n  /// @param mode[in] specify the database operation mode, read, write, create...\n  ///\n  /// @note this should be called first before any operation about\n  /// LidarMapOffline\n  static bool configure(LocalDatabase::MODE mode);\n\n  /// @brief get the cache range(in number of tiles)\n  static int getCacheRange() { return LidarMap::cache_range_; }\n\n  /// @brief get the watermark of tile cache\n  static int getCacheMargin() { return LidarMap::cache_margin_; }\n\n  /// @brief implimention of LidarMap::initializeLayer, see LidarMap for more infomation\n  bool initializeLayer(int layer_id) override;\n\n  /// @brief initialize a layer by specify type_name, grid_size and tile\n  /// @return the layer_id of the initilized layer, if failed, a negtive number will be returned\n  int initializeLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief implimention of LidarMap::addPointCloud, see LidarMap for more infomation\n  bool addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) override;\n\n  /// @brief load the map to cache\n  /// @param[in] pos the center of the region to be loaded\n  /// @return true on succeed, else false\n  bool load(const Eigen::Vector3f& pos);\n\n  /// @brief Get the map of a layer in specific region\n  ///\n  /// @param layer_id[in] specify which layer to get\n  /// @param[in] scope specifies the submap region.\n  /// @param[in] blocking if is true, this call will block if cache miss happens,\n  /// until tiles are loaded or timeout\n  /// @param[out] ndt3 stores the map we got\n  ///\n  /// @return true on succeed, else false. we may fails when there is a cache miss\n  /// in blocking mode\n  bool getMap(int layer_id, const MapScope& scope, bool blocking,\n              std::shared_ptr<Ndt3Interface>* ndt3);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @param layer_item[in] a layer item contains nessecery infomation\n  /// to add one layer\n  ///\n  /// @return true on succeed, else false\n  bool addLayer(const proto::config::MapLayerItem& layer_item);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @return the layer id of the layer we add\n  int addLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief save the map into database\n  ///\n  /// @return true on succeed, else false\n  bool save();\n\n  /// @brief get one maplayer\n  ///\n  /// @param layer_id[in] specify which layer to get\n  ///\n  /// @return\n  std::shared_ptr<const MapLayer> getLayer(int layer_id);\n\n  /// @brief get one maplayer\n  ///\n  /// @param type_name[in] such as ndt3_corner...\n  ///\n  /// @return map layer got\n  std::shared_ptr<const MapLayer> getLayer(const std::string& type_name, float grid_size, float tile_size);\n\n private:\n  static std::shared_ptr<LocalDatabase> database_;\n  static LocalDatabase::MODE database_operation_mode_;\n  static proto::map::MapInfo map_info_;\n\n  std::map<int, std::shared_ptr<MapLayer>> layers_;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h"
		}
	}
]
I0402 15:57:33.881048  6725 json_parser.cpp:18] 
[
	66,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/eigen_types.h\"\n\n#include \"common/proto/config/config_map.pb.h\"\n\n#include \"lidar_map.h\"\n#include \"local_database.h\"\n#include \"map_layer.h\"\n#include \"map_scope.h\"\n#include \"ndt3interface.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass LidarMapOffline : public LidarMap {\n public:\n  /// @brief configure the LidarMapOffline class, mainly static members\n  /// which shared by all LidarMapOffline instance, such as database\n  ///\n  /// @param mode[in] specify the database operation mode, read, write, create...\n  ///\n  /// @note this should be called first before any operation about\n  /// LidarMapOffline\n  static bool configure(LocalDatabase::MODE mode);\n\n  /// @brief get the cache range(in number of tiles)\n  static int getCacheRange() { return LidarMap::cache_range_; }\n\n  /// @brief get the watermark of tile cache\n  static int getCacheMargin() { return LidarMap::cache_margin_; }\n\n  /// @brief implimention of LidarMap::initializeLayer, see LidarMap for more infomation\n  bool initializeLayer(int layer_id) override;\n\n  /// @brief initialize a layer by specify type_name, grid_size and tile\n  /// @return the layer_id of the initilized layer, if failed, a negtive number will be returned\n  int initializeLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief implimention of LidarMap::addPointCloud, see LidarMap for more infomation\n  bool addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) override;\n\n  /// @brief load the map to cache\n  /// @param[in] pos the center of the region to be loaded\n  /// @return true on succeed, else false\n  bool load(const Eigen::Vector3f& pos);\n\n  /// @brief Get the map of a layer in specific region\n  ///\n  /// @param layer_id[in] specify which layer to get\n  /// @param[in] scope specifies the submap region.\n  /// @param[in] blocking if is true, this call will block if cache miss happens,\n  /// until tiles are loaded or timeout\n  /// @param[out] ndt3 stores the map we got\n  ///\n  /// @return true on succeed, else false. we may fails when there is a cache miss\n  /// in blocking mode\n  bool getMap(int layer_id, const MapScope& scope, bool blocking,\n              std::shared_ptr<Ndt3Interface>* ndt3);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @param layer_item[in] a layer item contains nessecery infomation\n  /// to add one layer\n  ///\n  /// @return true on succeed, else false\n  bool addLayer(const proto::config::MapLayerItem& layer_item);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @return the layer id of the layer we add\n  int addLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief save the map into database\n  ///\n  /// @return true on succeed, else false\n  bool save();\n\n  /// @brief get one maplayer\n  ///\n  /// @param layer_id[in] specify which layer to get\n  ///\n  /// @return\n  std::shared_ptr<const MapLayer> getLayer(int layer_id);\n\n  /// @brief get one maplayer\n  ///\n  /// @param type_name[in] such as ndt3_corner...\n  ///\n  /// @return map layer got\n  std::shared_ptr<const MapLayer> getLayer(const std::string& type_name, float grid_size, float tile_size);\n\n private:\n  static std::shared_ptr<LocalDatabase> database_;\n  static LocalDatabase::MODE database_operation_mode_;\n  static proto::map::MapInfo map_info_;\n\n  std::map<int, std::shared_ptr<MapLayer>> layers_;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h"
		}
	}
]
I0402 15:57:37.080010  6725 json_parser.cpp:18] 
[
	67,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/eigen_types.h\"\n\n#include \"common/proto/config/config_map.pb.h\"\n\n#include \"lidar_map.h\"\n#include \"local_database.h\"\n#include \"map_layer.h\"\n#include \"map_scope.h\"\n#include \"ndt3interface.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass LidarMapOffline : public LidarMap {\n public:\n  /// @brief configure the LidarMapOffline class, mainly static members\n  /// which shared by all LidarMapOffline instance, such as database\n  ///\n  /// @param mode[in] specify the database operation mode, read, write, create...\n  ///\n  /// @note this should be called first before any operation about\n  /// LidarMapOffline\n  static bool configure(LocalDatabase::MODE mode);\n\n  /// @brief get the cache range(in number of tiles)\n  static int getCacheRange() { return LidarMap::cache_range_; }\n\n  /// @brief get the watermark of tile cache\n  static int getCacheMargin() { return LidarMap::cache_margin_; }\n\n  /// @brief implimention of LidarMap::initializeLayer, see LidarMap for more infomation\n  bool initializeLayer(int layer_id) override;\n\n  /// @brief initialize a layer by specify type_name, grid_size and tile\n  /// @return the layer_id of the initilized layer, if failed, a negtive number will be returned\n  int initializeLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief implimention of LidarMap::addPointCloud, see LidarMap for more infomation\n  bool addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) override;\n\n  /// @brief load the map to cache\n  /// @param[in] pos the center of the region to be loaded\n  /// @return true on succeed, else false\n  bool load(const Eigen::Vector3f& pos);\n\n  /// @brief Get the map of a layer in specific region\n  ///\n  /// @param layer_id[in] specify which layer to get\n  /// @param[in] scope specifies the submap region.\n  /// @param[in] blocking if is true, this call will block if cache miss happens,\n  /// until tiles are loaded or timeout\n  /// @param[out] ndt3 stores the map we got\n  ///\n  /// @return true on succeed, else false. we may fails when there is a cache miss\n  /// in blocking mode\n  bool getMap(int layer_id, const MapScope& scope, bool blocking,\n              std::shared_ptr<Ndt3Interface>* ndt3);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @param layer_item[in] a layer item contains nessecery infomation\n  /// to add one layer\n  ///\n  /// @return true on succeed, else false\n  bool addLayer(const proto::config::MapLayerItem& layer_item);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @return the layer id of the layer we add\n  int addLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief save the map into database\n  ///\n  /// @return true on succeed, else false\n  bool save();\n\n  /// @brief get one maplayer\n  ///\n  /// @param layer_id[in] specify which layer to get\n  ///\n  /// @return maplayer got\n  std::shared_ptr<const MapLayer> getLayer(int layer_id);\n\n  /// @brief get one maplayer\n  ///\n  /// @param type_name[in] such as ndt3_corner...\n  ///\n  /// @return map layer got\n  std::shared_ptr<const MapLayer> getLayer(const std::string& type_name, float grid_size, float tile_size);\n\n private:\n  static std::shared_ptr<LocalDatabase> database_;\n  static LocalDatabase::MODE database_operation_mode_;\n  static proto::map::MapInfo map_info_;\n\n  std::map<int, std::shared_ptr<MapLayer>> layers_;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h"
		}
	}
]
I0402 15:57:38.920660  6725 json_parser.cpp:18] 
[
	68,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/eigen_types.h\"\n\n#include \"common/proto/config/config_map.pb.h\"\n\n#include \"lidar_map.h\"\n#include \"local_database.h\"\n#include \"map_layer.h\"\n#include \"map_scope.h\"\n#include \"ndt3interface.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass LidarMapOffline : public LidarMap {\n public:\n  /// @brief configure the LidarMapOffline class, mainly static members\n  /// which shared by all LidarMapOffline instance, such as database\n  ///\n  /// @param mode[in] specify the database operation mode, read, write, create...\n  ///\n  /// @note this should be called first before any operation about\n  /// LidarMapOffline\n  static bool configure(LocalDatabase::MODE mode);\n\n  /// @brief get the cache range(in number of tiles)\n  static int getCacheRange() { return LidarMap::cache_range_; }\n\n  /// @brief get the watermark of tile cache\n  static int getCacheMargin() { return LidarMap::cache_margin_; }\n\n  /// @brief implimention of LidarMap::initializeLayer, see LidarMap for more infomation\n  bool initializeLayer(int layer_id) override;\n\n  /// @brief initialize a layer by specify type_name, grid_size and tile\n  /// @return the layer_id of the initilized layer, if failed, a negtive number will be returned\n  int initializeLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief implimention of LidarMap::addPointCloud, see LidarMap for more infomation\n  bool addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) override;\n\n  /// @brief load the map to cache\n  /// @param[in] pos the center of the region to be loaded\n  /// @return true on succeed, else false\n  bool load(const Eigen::Vector3f& pos);\n\n  /// @brief Get the map of a layer in specific region\n  ///\n  /// @param layer_id[in] specify which layer to get\n  /// @param[in] scope specifies the submap region.\n  /// @param[in] blocking if is true, this call will block if cache miss happens,\n  /// until tiles are loaded or timeout\n  /// @param[out] ndt3 stores the map we got\n  ///\n  /// @return true on succeed, else false. we may fails when there is a cache miss\n  /// in blocking mode\n  bool getMap(int layer_id, const MapScope& scope, bool blocking,\n              std::shared_ptr<Ndt3Interface>* ndt3);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @param layer_item[in] a layer item contains nessecery infomation\n  /// to add one layer\n  ///\n  /// @return true on succeed, else false\n  bool addLayer(const proto::config::MapLayerItem& layer_item);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @return the layer id of the layer we add\n  int addLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief save the map into database\n  ///\n  /// @return true on succeed, else false\n  bool save();\n\n  /// @brief get one maplayer\n  ///\n  /// @param layer_id[in] specify which layer to get\n  ///\n  /// @return maplayer got\n  std::shared_ptr<const MapLayer> getLayer(int layer_id);\n\n  /// @brief get one maplayer\n  ///\n  /// @param type_name[in] such as ndt3_corner...\n  ///\n  /// @return map layer got\n  std::shared_ptr<const MapLayer> getLayer(const std::string& type_name, float grid_size, float tile_size);\n\n private:\n  static std::shared_ptr<LocalDatabase> database_;\n  static LocalDatabase::MODE database_operation_mode_;\n  static proto::map::MapInfo map_info_;\n\n  std::map<int, std::shared_ptr<MapLayer>> layers_;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h"
		}
	}
]
I0402 15:57:41.075208  6725 json_parser.cpp:18] 
[
	69,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/eigen_types.h\"\n\n#include \"common/proto/config/config_map.pb.h\"\n\n#include \"lidar_map.h\"\n#include \"local_database.h\"\n#include \"map_layer.h\"\n#include \"map_scope.h\"\n#include \"ndt3interface.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass LidarMapOffline : public LidarMap {\n public:\n  /// @brief configure the LidarMapOffline class, mainly static members\n  /// which shared by all LidarMapOffline instance, such as database\n  ///\n  /// @param mode[in] specify the database operation mode, read, write, create...\n  ///\n  /// @note this should be called first before any operation about\n  /// LidarMapOffline\n  static bool configure(LocalDatabase::MODE mode);\n\n  /// @brief get the cache range(in number of tiles)\n  static int getCacheRange() { return LidarMap::cache_range_; }\n\n  /// @brief get the watermark of tile cache\n  static int getCacheMargin() { return LidarMap::cache_margin_; }\n\n  /// @brief implimention of LidarMap::initializeLayer, see LidarMap for more infomation\n  bool initializeLayer(int layer_id) override;\n\n  /// @brief initialize a layer by specify type_name, grid_size and tile\n  /// @return the layer_id of the initilized layer, if failed, a negtive number will be returned\n  int initializeLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief implimention of LidarMap::addPointCloud, see LidarMap for more infomation\n  bool addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) override;\n\n  /// @brief load the map to cache\n  /// @param[in] pos the center of the region to be loaded\n  /// @return true on succeed, else false\n  bool load(const Eigen::Vector3f& pos);\n\n  /// @brief Get the map of a layer in specific region\n  ///\n  /// @param layer_id[in] specify which layer to get\n  /// @param[in] scope specifies the submap region.\n  /// @param[in] blocking if is true, this call will block if cache miss happens,\n  /// until tiles are loaded or timeout\n  /// @param[out] ndt3 stores the map we got\n  ///\n  /// @return true on succeed, else false. we may fails when there is a cache miss\n  /// in blocking mode\n  bool getMap(int layer_id, const MapScope& scope, bool blocking,\n              std::shared_ptr<Ndt3Interface>* ndt3);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @param layer_item[in] a layer item contains nessecery infomation\n  /// to add one layer\n  ///\n  /// @return true on succeed, else false\n  bool addLayer(const proto::config::MapLayerItem& layer_item);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @return the layer id of the layer we add\n  int addLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief save the map into database\n  ///\n  /// @return true on succeed, else false\n  bool save();\n\n  /// @brief get one maplayer\n  ///\n  /// @param layer_id[in] specify which layer to get\n  ///\n  /// @return maplayer got\n  std::shared_ptr<const MapLayer> getLayer(int layer_id);\n\n  /// @brief get one maplayer\n  ///\n  /// @param type_name[in] such as ndt3_corner...\n  ///\n  /// @return map layer got\n  std::shared_ptr<const MapLayer> getLayer(const std::string& type_name, float grid_size, float tile_size);\n\n private:\n  static std::shared_ptr<LocalDatabase> database_;\n  static LocalDatabase::MODE database_operation_mode_;\n  static proto::map::MapInfo map_info_;\n\n  std::map<int, std::shared_ptr<MapLayer>> layers_;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h"
		}
	}
]
I0402 15:57:41.087131  6725 json_parser.cpp:18] 
[
	70,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/eigen_types.h\"\n\n#include \"common/proto/config/config_map.pb.h\"\n\n#include \"lidar_map.h\"\n#include \"local_database.h\"\n#include \"map_layer.h\"\n#include \"map_scope.h\"\n#include \"ndt3interface.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass LidarMapOffline : public LidarMap {\n public:\n  /// @brief configure the LidarMapOffline class, mainly static members\n  /// which shared by all LidarMapOffline instance, such as database\n  ///\n  /// @param mode[in] specify the database operation mode, read, write, create...\n  ///\n  /// @note this should be called first before any operation about\n  /// LidarMapOffline\n  static bool configure(LocalDatabase::MODE mode);\n\n  /// @brief get the cache range(in number of tiles)\n  static int getCacheRange() { return LidarMap::cache_range_; }\n\n  /// @brief get the watermark of tile cache\n  static int getCacheMargin() { return LidarMap::cache_margin_; }\n\n  /// @brief implimention of LidarMap::initializeLayer, see LidarMap for more infomation\n  bool initializeLayer(int layer_id) override;\n\n  /// @brief initialize a layer by specify type_name, grid_size and tile\n  /// @return the layer_id of the initilized layer, if failed, a negtive number will be returned\n  int initializeLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief implimention of LidarMap::addPointCloud, see LidarMap for more infomation\n  bool addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) override;\n\n  /// @brief load the map to cache\n  /// @param[in] pos the center of the region to be loaded\n  /// @return true on succeed, else false\n  bool load(const Eigen::Vector3f& pos);\n\n  /// @brief Get the map of a layer in specific region\n  ///\n  /// @param layer_id[in] specify which layer to get\n  /// @param[in] scope specifies the submap region.\n  /// @param[in] blocking if is true, this call will block if cache miss happens,\n  /// until tiles are loaded or timeout\n  /// @param[out] ndt3 stores the map we got\n  ///\n  /// @return true on succeed, else false. we may fails when there is a cache miss\n  /// in blocking mode\n  bool getMap(int layer_id, const MapScope& scope, bool blocking,\n              std::shared_ptr<Ndt3Interface>* ndt3);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @param layer_item[in] a layer item contains nessecery infomation\n  /// to add one layer\n  ///\n  /// @return true on succeed, else false\n  bool addLayer(const proto::config::MapLayerItem& layer_item);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @return the layer id of the layer we add\n  int addLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief save the map into database\n  ///\n  /// @return true on succeed, else false\n  bool save();\n\n  /// @brief get one maplayer\n  ///\n  /// @param layer_id[in] specify which layer to get\n  ///\n  /// @return maplayer got\n  std::shared_ptr<const MapLayer> getLayer(int layer_id);\n\n  /// @brief get one maplayer\n  ///\n  /// @param type_name[in] such as ndt3_corner...\n  ///\n  /// @return map layer got\n  std::shared_ptr<const MapLayer> getLayer(const std::string& type_name, float grid_size, float tile_size);\n\n private:\n  static std::shared_ptr<LocalDatabase> database_;\n  static LocalDatabase::MODE database_operation_mode_;\n  static proto::map::MapInfo map_info_;\n\n  std::map<int, std::shared_ptr<MapLayer>> layers_;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h"
		}
	}
]
I0402 15:57:41.098918  6725 json_parser.cpp:18] 
[
	71,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/eigen_types.h\"\n\n#include \"common/proto/config/config_map.pb.h\"\n\n#include \"lidar_map.h\"\n#include \"local_database.h\"\n#include \"map_layer.h\"\n#include \"map_scope.h\"\n#include \"ndt3interface.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass LidarMapOffline : public LidarMap {\n public:\n  /// @brief configure the LidarMapOffline class, mainly static members\n  /// which shared by all LidarMapOffline instance, such as database\n  ///\n  /// @param mode[in] specify the database operation mode, read, write, create...\n  ///\n  /// @note this should be called first before any operation about\n  /// LidarMapOffline\n  static bool configure(LocalDatabase::MODE mode);\n\n  /// @brief get the cache range(in number of tiles)\n  static int getCacheRange() { return LidarMap::cache_range_; }\n\n  /// @brief get the watermark of tile cache\n  static int getCacheMargin() { return LidarMap::cache_margin_; }\n\n  /// @brief implimention of LidarMap::initializeLayer, see LidarMap for more infomation\n  bool initializeLayer(int layer_id) override;\n\n  /// @brief initialize a layer by specify type_name, grid_size and tile\n  /// @return the layer_id of the initilized layer, if failed, a negtive number will be returned\n  int initializeLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief implimention of LidarMap::addPointCloud, see LidarMap for more infomation\n  bool addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) override;\n\n  /// @brief load the map to cache\n  /// @param[in] pos the center of the region to be loaded\n  /// @return true on succeed, else false\n  bool load(const Eigen::Vector3f& pos);\n\n  /// @brief Get the map of a layer in specific region\n  ///\n  /// @param layer_id[in] specify which layer to get\n  /// @param[in] scope specifies the submap region.\n  /// @param[in] blocking if is true, this call will block if cache miss happens,\n  /// until tiles are loaded or timeout\n  /// @param[out] ndt3 stores the map we got\n  ///\n  /// @return true on succeed, else false. we may fails when there is a cache miss\n  /// in blocking mode\n  bool getMap(int layer_id, const MapScope& scope, bool blocking,\n              std::shared_ptr<Ndt3Interface>* ndt3);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @param layer_item[in] a layer item contains nessecery infomation\n  /// to add one layer\n  ///\n  /// @return true on succeed, else false\n  bool addLayer(const proto::config::MapLayerItem& layer_item);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @return the layer id of the layer we add\n  int addLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief save the map into database\n  ///\n  /// @return true on succeed, else false\n  bool save();\n\n  /// @brief get one maplayer\n  ///\n  /// @param layer_id[in] specify which layer to get\n  ///\n  /// @return maplayer got\n  std::shared_ptr<const MapLayer> getLayer(int layer_id);\n\n  /// @brief get one maplayer\n  ///\n  /// @param type_name[in] such as ndt3_corner...\n  ///\n  /// @return map layer got\n  std::shared_ptr<const MapLayer> getLayer(const std::string& type_name, float grid_size, float tile_size);\n\n private:\n  static std::shared_ptr<LocalDatabase> database_;\n  static LocalDatabase::MODE database_operation_mode_;\n  static proto::map::MapInfo map_info_;\n\n  std::map<int, std::shared_ptr<MapLayer>> layers_;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h"
		}
	}
]
I0402 15:57:41.137678  6725 json_parser.cpp:18] 
[
	72,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if(!initializeLayer(layer_id)){\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nconst MapLayer& LidarMapOffline::getLayer(int layer_id) { return *(layers_[layer_id]); }\n\nconst MapLayer& LidarMapOffline::getLayer(const std::string& type_name, float grid_size,\n                                          float tile_size) {\n  int layer_id;\n  map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id);\n  return *(layers_[layer_id]);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 15:57:41.208020  6725 json_parser.cpp:18] 
[
	73,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if(!initializeLayer(layer_id)){\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nconst MapLayer& LidarMapOffline::getLayer(int layer_id) { return *(layers_[layer_id]); }\n\nconst MapLayer& LidarMapOffline::getLayer(const std::string& type_name, float grid_size,\n                                          float tile_size) {\n  int layer_id;\n  map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id);\n  return *(layers_[layer_id]);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 15:57:42.157949  6725 json_parser.cpp:18] 
[
	74,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if(!initializeLayer(layer_id)){\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nconst MapLayer& LidarMapOffline::getLayer(int layer_id) { return *(layers_[layer_id]); }\n\nconst MapLayer& LidarMapOffline::getLayer(const std::string& type_name, float grid_size,\n                                          float tile_size) {\n  int layer_id;\n  map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id);\n  return *(layers_[layer_id]);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 15:57:42.164454  6725 json_parser.cpp:18] 
[
	75,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if(!initializeLayer(layer_id)){\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nconst MapLayer& LidarMapOffline::getLayer(int layer_id) { return *(layers_[layer_id]); }\n\nconst MapLayer& LidarMapOffline::getLayer(const std::string& type_name, float grid_size,\n                                          float tile_size) {\n  int layer_id;\n  map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id);\n  return *(layers_[layer_id]);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 15:57:58.801136  6725 json_parser.cpp:18] 
[
	76,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if(!initializeLayer(layer_id)){\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nconst MapLayer& LidarMapOffline::getLayer(int layer_id) { return *(layers_[layer_id]); }\n\nconst MapLayer& LidarMapOffline::getLayer(const std::string& type_name, float grid_size,\n                                          float tile_size) {\n  int layer_id;\n  map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id);\n  return *(layers_[layer_id]);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 15:58:00.336982  6725 json_parser.cpp:18] 
[
	77,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if(!initializeLayer(layer_id)){\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nconst MapLayer& LidarMapOffline::getLayer(int layer_id) { return *(layers_[layer_id]); }\n\nconst MapLayer& LidarMapOffline::getLayer(const std::string& type_name, float grid_size,\n                                          float tile_size) {\n  int layer_id;\n  map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id);\n  return *(layers_[layer_id]);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 15:58:04.903455  6725 json_parser.cpp:18] 
[
	78,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if(!initializeLayer(layer_id)){\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nMapLayer& LidarMapOffline::getLayer(int layer_id) { return *(layers_[layer_id]); }\n\nconst MapLayer& LidarMapOffline::getLayer(const std::string& type_name, float grid_size,\n                                          float tile_size) {\n  int layer_id;\n  map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id);\n  return *(layers_[layer_id]);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 15:58:04.984403  6725 json_parser.cpp:18] 
[
	79,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if(!initializeLayer(layer_id)){\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nMapLayer& LidarMapOffline::getLayer(int layer_id) { return *(layers_[layer_id]); }\n\nconst MapLayer& LidarMapOffline::getLayer(const std::string& type_name, float grid_size,\n                                          float tile_size) {\n  int layer_id;\n  map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id);\n  return *(layers_[layer_id]);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 15:58:11.064507  6725 json_parser.cpp:18] 
[
	80,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if(!initializeLayer(layer_id)){\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<MapLayer& LidarMapOffline::getLayer(int layer_id) { return *(layers_[layer_id]); }\n\nconst MapLayer& LidarMapOffline::getLayer(const std::string& type_name, float grid_size,\n                                          float tile_size) {\n  int layer_id;\n  map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id);\n  return *(layers_[layer_id]);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 15:58:13.528407  6725 json_parser.cpp:18] 
[
	81,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if(!initializeLayer(layer_id)){\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<MapLayer& LidarMapOffline::getLayer(int layer_id) { return *(layers_[layer_id]); }\n\nconst MapLayer& LidarMapOffline::getLayer(const std::string& type_name, float grid_size,\n                                          float tile_size) {\n  int layer_id;\n  map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id);\n  return *(layers_[layer_id]);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 15:58:14.176764  6725 json_parser.cpp:18] 
[
	82,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if(!initializeLayer(layer_id)){\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<MapLayer>& LidarMapOffline::getLayer(int layer_id) { return *(layers_[layer_id]); }\n\nconst MapLayer& LidarMapOffline::getLayer(const std::string& type_name, float grid_size,\n                                          float tile_size) {\n  int layer_id;\n  map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id);\n  return *(layers_[layer_id]);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 15:58:14.469394  6725 json_parser.cpp:18] 
[
	83,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if(!initializeLayer(layer_id)){\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<MapLayer> LidarMapOffline::getLayer(int layer_id) { return *(layers_[layer_id]); }\n\nconst MapLayer& LidarMapOffline::getLayer(const std::string& type_name, float grid_size,\n                                          float tile_size) {\n  int layer_id;\n  map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id);\n  return *(layers_[layer_id]);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 15:58:16.033005  6725 json_parser.cpp:18] 
[
	84,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if(!initializeLayer(layer_id)){\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<MapLayer> LidarMapOffline::getLayer(int layer_id) { return *(layers_[layer_id]); }\n\nconst MapLayer& LidarMapOffline::getLayer(const std::string& type_name, float grid_size,\n                                          float tile_size) {\n  int layer_id;\n  map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id);\n  return *(layers_[layer_id]);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 15:58:17.136610  6725 json_parser.cpp:18] 
[
	85,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if(!initializeLayer(layer_id)){\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) { return *(layers_[layer_id]); }\n\nconst MapLayer& LidarMapOffline::getLayer(const std::string& type_name, float grid_size,\n                                          float tile_size) {\n  int layer_id;\n  map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id);\n  return *(layers_[layer_id]);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 15:58:20.389386  6725 json_parser.cpp:18] 
[
	86,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if(!initializeLayer(layer_id)){\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) { return *(layers_[layer_id]); }\n\nMapLayer& LidarMapOffline::getLayer(const std::string& type_name, float grid_size,\n                                          float tile_size) {\n  int layer_id;\n  map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id);\n  return *(layers_[layer_id]);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 15:58:20.498471  6725 json_parser.cpp:18] 
[
	87,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if(!initializeLayer(layer_id)){\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) { return *(layers_[layer_id]); }\n\nMapLayer& LidarMapOffline::getLayer(const std::string& type_name, float grid_size,\n                                          float tile_size) {\n  int layer_id;\n  map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id);\n  return *(layers_[layer_id]);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 15:58:23.320658  6725 json_parser.cpp:18] 
[
	88,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if(!initializeLayer(layer_id)){\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) { return *(layers_[layer_id]); }\n\nstd::shared_ptr<>MapLayer& LidarMapOffline::getLayer(const std::string& type_name, float grid_size,\n                                          float tile_size) {\n  int layer_id;\n  map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id);\n  return *(layers_[layer_id]);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 15:58:23.480949  6725 json_parser.cpp:18] 
[
	89,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if(!initializeLayer(layer_id)){\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) { return *(layers_[layer_id]); }\n\nstd::shared_ptr<>MapLayer& LidarMapOffline::getLayer(const std::string& type_name, float grid_size,\n                                          float tile_size) {\n  int layer_id;\n  map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id);\n  return *(layers_[layer_id]);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 15:58:28.321293  6725 json_parser.cpp:18] 
[
	90,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if(!initializeLayer(layer_id)){\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) { return *(layers_[layer_id]); }\n\nstd::shared_ptr<const MapLayer>MapLayer& LidarMapOffline::getLayer(const std::string& type_name, float grid_size,\n                                          float tile_size) {\n  int layer_id;\n  map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id);\n  return *(layers_[layer_id]);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 15:58:28.330938  6725 json_parser.cpp:18] 
[
	91,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if(!initializeLayer(layer_id)){\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) { return *(layers_[layer_id]); }\n\nstd::shared_ptr<const MapLayer>MapLayer& LidarMapOffline::getLayer(const std::string& type_name, float grid_size,\n                                          float tile_size) {\n  int layer_id;\n  map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id);\n  return *(layers_[layer_id]);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 15:58:29.168503  6725 json_parser.cpp:18] 
[
	92,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if(!initializeLayer(layer_id)){\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) { return *(layers_[layer_id]); }\n\nstd::shared_ptr<const MapLayer>MapLayer& LidarMapOffline::getLayer(const std::string& type_name, float grid_size,\n                                          float tile_size) {\n  int layer_id;\n  map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id);\n  return *(layers_[layer_id]);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 15:58:29.497710  6725 json_parser.cpp:18] 
[
	93,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if(!initializeLayer(layer_id)){\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) { return *(layers_[layer_id]); }\n\nstd::shared_ptr<const MapLayer> MapLayer& LidarMapOffline::getLayer(const std::string& type_name, float grid_size,\n                                          float tile_size) {\n  int layer_id;\n  map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id);\n  return *(layers_[layer_id]);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 15:58:31.286718  6725 json_parser.cpp:18] 
[
	94,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if(!initializeLayer(layer_id)){\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) { return *(layers_[layer_id]); }\n\nstd::shared_ptr<const MapLayer>MapLayer& LidarMapOffline::getLayer(const std::string& type_name, float grid_size,\n                                          float tile_size) {\n  int layer_id;\n  map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id);\n  return *(layers_[layer_id]);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 15:58:31.703064  6725 json_parser.cpp:18] 
[
	95,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if(!initializeLayer(layer_id)){\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) { return *(layers_[layer_id]); }\n\nstd::shared_ptr<const MapLayer>& LidarMapOffline::getLayer(const std::string& type_name, float grid_size,\n                                          float tile_size) {\n  int layer_id;\n  map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id);\n  return *(layers_[layer_id]);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 15:58:32.141573  6725 json_parser.cpp:18] 
[
	96,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if(!initializeLayer(layer_id)){\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) { return *(layers_[layer_id]); }\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(const std::string& type_name, float grid_size,\n                                          float tile_size) {\n  int layer_id;\n  map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id);\n  return *(layers_[layer_id]);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 15:58:37.737526  6725 json_parser.cpp:18] 
[
	97,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if(!initializeLayer(layer_id)){\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) { return *(layers_[layer_id]); }\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(const std::string& type_name, float grid_size,\n                                          float tile_size) {\n  int layer_id;\n  map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id);\n  return *(layers_[layer_id]);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 15:58:38.264560  6725 json_parser.cpp:18] 
[
	98,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if(!initializeLayer(layer_id)){\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) { \n  return *(layers_[layer_id]); }\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(const std::string& type_name, float grid_size,\n                                          float tile_size) {\n  int layer_id;\n  map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id);\n  return *(layers_[layer_id]);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 15:58:38.624668  6725 json_parser.cpp:18] 
[
	99,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if(!initializeLayer(layer_id)){\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) { \n  \n  return *(layers_[layer_id]); }\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(const std::string& type_name, float grid_size,\n                                          float tile_size) {\n  int layer_id;\n  map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id);\n  return *(layers_[layer_id]);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 15:58:38.810294  6725 json_parser.cpp:18] 
[
	100,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if(!initializeLayer(layer_id)){\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) { \n\n  return *(layers_[layer_id]); }\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(const std::string& type_name, float grid_size,\n                                          float tile_size) {\n  int layer_id;\n  map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id);\n  return *(layers_[layer_id]);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 15:58:38.877269  6725 json_parser.cpp:18] 
[
	101,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if(!initializeLayer(layer_id)){\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) { \n\n  return *(layers_[layer_id]); }\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(const std::string& type_name, float grid_size,\n                                          float tile_size) {\n  int layer_id;\n  map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id);\n  return *(layers_[layer_id]);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 15:58:39.862841  6725 json_parser.cpp:18] 
[
	102,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if(!initializeLayer(layer_id)){\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) { \n  return *(layers_[layer_id]); }\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(const std::string& type_name, float grid_size,\n                                          float tile_size) {\n  int layer_id;\n  map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id);\n  return *(layers_[layer_id]);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 15:58:40.089083  6725 json_parser.cpp:18] 
[
	103,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if(!initializeLayer(layer_id)){\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) { \n  \n  return *(layers_[layer_id]); }\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(const std::string& type_name, float grid_size,\n                                          float tile_size) {\n  int layer_id;\n  map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id);\n  return *(layers_[layer_id]);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 15:58:52.775969  6725 json_parser.cpp:18] 
[
	104,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if(!initializeLayer(layer_id)){\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) { \n  auto iter = layers_.find()\n  return *(layers_[layer_id]); }\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(const std::string& type_name, float grid_size,\n                                          float tile_size) {\n  int layer_id;\n  map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id);\n  return *(layers_[layer_id]);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 15:58:52.929085  6725 json_parser.cpp:18] 
[
	105,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if(!initializeLayer(layer_id)){\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) { \n  auto iter = layers_.find()\n  return *(layers_[layer_id]); }\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(const std::string& type_name, float grid_size,\n                                          float tile_size) {\n  int layer_id;\n  map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id);\n  return *(layers_[layer_id]);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 15:58:57.664960  6725 json_parser.cpp:18] 
[
	106,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if(!initializeLayer(layer_id)){\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) { \n  auto iter = layers_.find(layer_id)\n  return *(layers_[layer_id]); }\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(const std::string& type_name, float grid_size,\n                                          float tile_size) {\n  int layer_id;\n  map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id);\n  return *(layers_[layer_id]);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 15:58:57.675531  6725 json_parser.cpp:18] 
[
	107,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if(!initializeLayer(layer_id)){\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) { \n  auto iter = layers_.find(layer_id)\n  return *(layers_[layer_id]); }\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(const std::string& type_name, float grid_size,\n                                          float tile_size) {\n  int layer_id;\n  map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id);\n  return *(layers_[layer_id]);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 15:58:58.017091  6725 json_parser.cpp:18] 
[
	108,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if(!initializeLayer(layer_id)){\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) { \n  auto iter = layers_.find(layer_id)\n  return *(layers_[layer_id]); }\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(const std::string& type_name, float grid_size,\n                                          float tile_size) {\n  int layer_id;\n  map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id);\n  return *(layers_[layer_id]);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 15:58:58.400435  6725 json_parser.cpp:18] 
[
	109,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if(!initializeLayer(layer_id)){\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) { \n  auto iter = layers_.find(layer_id);\n  return *(layers_[layer_id]); }\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(const std::string& type_name, float grid_size,\n                                          float tile_size) {\n  int layer_id;\n  map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id);\n  return *(layers_[layer_id]);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 15:58:58.407670  6725 json_parser.cpp:18] 
[
	110,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if(!initializeLayer(layer_id)){\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) { \n  auto iter = layers_.find(layer_id);\n  return *(layers_[layer_id]); }\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(const std::string& type_name, float grid_size,\n                                          float tile_size) {\n  int layer_id;\n  map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id);\n  return *(layers_[layer_id]);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 15:59:01.056689  6725 json_parser.cpp:18] 
[
	111,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if(!initializeLayer(layer_id)){\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) { \n  auto iter = layers_.find(layer_id);\n  \n  return *(layers_[layer_id]); }\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(const std::string& type_name, float grid_size,\n                                          float tile_size) {\n  int layer_id;\n  map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id);\n  return *(layers_[layer_id]);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 15:59:02.280640  6725 json_parser.cpp:18] 
[
	112,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if(!initializeLayer(layer_id)){\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) { \n  auto iter = layers_.find(layer_id);\n  if()\n  return *(layers_[layer_id]); }\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(const std::string& type_name, float grid_size,\n                                          float tile_size) {\n  int layer_id;\n  map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id);\n  return *(layers_[layer_id]);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 15:59:02.560881  6725 json_parser.cpp:18] 
[
	113,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if(!initializeLayer(layer_id)){\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) { \n  auto iter = layers_.find(layer_id);\n  if()\n  return *(layers_[layer_id]); }\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(const std::string& type_name, float grid_size,\n                                          float tile_size) {\n  int layer_id;\n  map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id);\n  return *(layers_[layer_id]);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 15:59:11.336601  6725 json_parser.cpp:18] 
[
	114,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if(!initializeLayer(layer_id)){\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) { \n  auto iter = layers_.find(layer_id);\n  if(iter != layers_.end())\n  return *(layers_[layer_id]); }\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(const std::string& type_name, float grid_size,\n                                          float tile_size) {\n  int layer_id;\n  map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id);\n  return *(layers_[layer_id]);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 15:59:11.824848  6725 json_parser.cpp:18] 
[
	115,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if(!initializeLayer(layer_id)){\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) { \n  auto iter = layers_.find(layer_id);\n  if(iter != layers_.end())\n  return *(layers_[layer_id]); }\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(const std::string& type_name, float grid_size,\n                                          float tile_size) {\n  int layer_id;\n  map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id);\n  return *(layers_[layer_id]);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 15:59:12.840163  6725 json_parser.cpp:18] 
[
	116,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if(!initializeLayer(layer_id)){\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) { \n  auto iter = layers_.find(layer_id);\n  if(iter != layers_.end()){\n  }\n  return *(layers_[layer_id]); }\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(const std::string& type_name, float grid_size,\n                                          float tile_size) {\n  int layer_id;\n  map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id);\n  return *(layers_[layer_id]);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 15:59:12.851274  6725 json_parser.cpp:18] 
[
	117,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if(!initializeLayer(layer_id)){\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) { \n  auto iter = layers_.find(layer_id);\n  if(iter != layers_.end()){\n  }\n  return *(layers_[layer_id]); }\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(const std::string& type_name, float grid_size,\n                                          float tile_size) {\n  int layer_id;\n  map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id);\n  return *(layers_[layer_id]);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 15:59:12.868961  6725 json_parser.cpp:18] 
[
	118,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if(!initializeLayer(layer_id)){\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) { \n  auto iter = layers_.find(layer_id);\n  if(iter != layers_.end()){\n    \n  }\n  return *(layers_[layer_id]); }\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(const std::string& type_name, float grid_size,\n                                          float tile_size) {\n  int layer_id;\n  map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id);\n  return *(layers_[layer_id]);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 15:59:20.734828  6725 json_parser.cpp:18] 
[
	119,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if(!initializeLayer(layer_id)){\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) { \n  auto iter = layers_.find(layer_id);\n  if(iter != layers_.end()){\n    return iter.second;\n  }\n  return *(layers_[layer_id]); }\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(const std::string& type_name, float grid_size,\n                                          float tile_size) {\n  int layer_id;\n  map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id);\n  return *(layers_[layer_id]);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 15:59:20.741406  6725 json_parser.cpp:18] 
[
	120,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if(!initializeLayer(layer_id)){\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) { \n  auto iter = layers_.find(layer_id);\n  if(iter != layers_.end()){\n    return iter.second;\n  }\n  return *(layers_[layer_id]); }\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(const std::string& type_name, float grid_size,\n                                          float tile_size) {\n  int layer_id;\n  map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id);\n  return *(layers_[layer_id]);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 15:59:21.552744  6725 json_parser.cpp:18] 
[
	121,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if(!initializeLayer(layer_id)){\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) { \n  auto iter = layers_.find(layer_id);\n  if(iter != layers_.end()){\n    return iter.second;\n  }\n  return *(layers_[layer_id]); }\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(const std::string& type_name, float grid_size,\n                                          float tile_size) {\n  int layer_id;\n  map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id);\n  return *(layers_[layer_id]);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 15:59:23.512886  6725 json_parser.cpp:18] 
[
	122,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if(!initializeLayer(layer_id)){\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) { \n  auto iter = layers_.find(layer_id);\n  if(iter != layers_.end()){\n    return iter.second;\n  }else{\n  }\n  return *(layers_[layer_id]); }\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(const std::string& type_name, float grid_size,\n                                          float tile_size) {\n  int layer_id;\n  map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id);\n  return *(layers_[layer_id]);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 15:59:23.522166  6725 json_parser.cpp:18] 
[
	123,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if(!initializeLayer(layer_id)){\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) { \n  auto iter = layers_.find(layer_id);\n  if(iter != layers_.end()){\n    return iter.second;\n  }else{\n  }\n  return *(layers_[layer_id]); }\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(const std::string& type_name, float grid_size,\n                                          float tile_size) {\n  int layer_id;\n  map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id);\n  return *(layers_[layer_id]);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 15:59:23.539211  6725 json_parser.cpp:18] 
[
	124,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if(!initializeLayer(layer_id)){\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) { \n  auto iter = layers_.find(layer_id);\n  if(iter != layers_.end()){\n    return iter.second;\n  }else{\n    \n  }\n  return *(layers_[layer_id]); }\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(const std::string& type_name, float grid_size,\n                                          float tile_size) {\n  int layer_id;\n  map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id);\n  return *(layers_[layer_id]);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 15:59:24.000576  6725 json_parser.cpp:18] 
[
	125,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if(!initializeLayer(layer_id)){\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) { \n  auto iter = layers_.find(layer_id);\n  if(iter != layers_.end()){\n    return iter.second;\n  }else{\n\n  }\n  return *(layers_[layer_id]); }\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(const std::string& type_name, float grid_size,\n                                          float tile_size) {\n  int layer_id;\n  map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id);\n  return *(layers_[layer_id]);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 15:59:24.010717  6725 json_parser.cpp:18] 
[
	126,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if(!initializeLayer(layer_id)){\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) { \n  auto iter = layers_.find(layer_id);\n  if(iter != layers_.end()){\n    return iter.second;\n  }else{\n\n  }\n  return *(layers_[layer_id]); }\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(const std::string& type_name, float grid_size,\n                                          float tile_size) {\n  int layer_id;\n  map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id);\n  return *(layers_[layer_id]);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 15:59:25.566633  6725 json_parser.cpp:18] 
[
	127,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if(!initializeLayer(layer_id)){\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) { \n  auto iter = layers_.find(layer_id);\n  if(iter != layers_.end()){\n    return iter.second;\n  }else{\n  }\n  return *(layers_[layer_id]); }\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(const std::string& type_name, float grid_size,\n                                          float tile_size) {\n  int layer_id;\n  map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id);\n  return *(layers_[layer_id]);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 15:59:25.897101  6725 json_parser.cpp:18] 
[
	128,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if(!initializeLayer(layer_id)){\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) { \n  auto iter = layers_.find(layer_id);\n  if(iter != layers_.end()){\n    return iter.second;\n  }else{\n    \n  }\n  return *(layers_[layer_id]); }\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(const std::string& type_name, float grid_size,\n                                          float tile_size) {\n  int layer_id;\n  map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id);\n  return *(layers_[layer_id]);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 15:59:29.648854  6725 json_parser.cpp:18] 
[
	129,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if(!initializeLayer(layer_id)){\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) { \n  auto iter = layers_.find(layer_id);\n  if(iter != layers_.end()){\n    return iter.second;\n  }else{\n    return nullptr;\n  }\n  return *(layers_[layer_id]); }\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(const std::string& type_name, float grid_size,\n                                          float tile_size) {\n  int layer_id;\n  map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id);\n  return *(layers_[layer_id]);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 15:59:29.659551  6725 json_parser.cpp:18] 
[
	130,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if(!initializeLayer(layer_id)){\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) { \n  auto iter = layers_.find(layer_id);\n  if(iter != layers_.end()){\n    return iter.second;\n  }else{\n    return nullptr;\n  }\n  return *(layers_[layer_id]); }\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(const std::string& type_name, float grid_size,\n                                          float tile_size) {\n  int layer_id;\n  map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id);\n  return *(layers_[layer_id]);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 15:59:30.556951  6725 json_parser.cpp:18] 
[
	131,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if(!initializeLayer(layer_id)){\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) { \n  auto iter = layers_.find(layer_id);\n  if(iter != layers_.end()){\n    return iter.second;\n  }else{\n    return nullptr;\n  }\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(const std::string& type_name, float grid_size,\n                                          float tile_size) {\n  int layer_id;\n  map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id);\n  return *(layers_[layer_id]);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 15:59:32.969952  6725 json_parser.cpp:18] 
[
	132,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if(!initializeLayer(layer_id)){\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) { \n  auto iter = layers_.find(layer_id);\n  if(iter != layers_.end()){\n    return iter.second;\n  }else{\n    return nullptr;\n  }\n  \n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(const std::string& type_name, float grid_size,\n                                          float tile_size) {\n  int layer_id;\n  map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id);\n  return *(layers_[layer_id]);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 15:59:34.136519  6725 json_parser.cpp:18] 
[
	133,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if(!initializeLayer(layer_id)){\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) { \n  auto iter = layers_.find(layer_id);\n  if(iter != layers_.end()){\n    return iter.second;\n  }else{\n    return nullptr;\n  }\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(const std::string& type_name, float grid_size,\n                                          float tile_size) {\n  int layer_id;\n  map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id);\n  return *(layers_[layer_id]);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 15:59:36.497455  6725 json_parser.cpp:18] 
[
	134,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if (!initializeLayer(layer_id)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) {\n  auto iter = layers_.find(layer_id);\n  if (iter != layers_.end()) {\n    return iter.second;\n  } else {\n    return nullptr;\n  }\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(const std::string& type_name,\n                                                          float grid_size, float tile_size) {\n  int layer_id;\n  map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id);\n  return *(layers_[layer_id]);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 16:00:01.513418  6725 json_parser.cpp:18] 
[
	135,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if (!initializeLayer(layer_id)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) {\n  auto iter = layers_.find(layer_id);\n  if (iter != layers_.end()) {\n    return iter.second;\n  } else {\n    return nullptr;\n  }\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(const std::string& type_name,\n                                                          float grid_size, float tile_size) {\n  int layer_id;\n  map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id);\n  return *(layers_[layer_id]);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 16:00:03.656468  6725 json_parser.cpp:18] 
[
	136,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if (!initializeLayer(layer_id)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) {\n  auto iter = layers_.find(layer_id);\n  if (iter != layers_.end()) {\n    return iter.second;\n  } else {\n    return nullptr;\n  }\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(const std::string& type_name,\n                                                          float grid_size, float tile_size) {\n  int layer_id;\n  if(!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id);\n  return *(layers_[layer_id]);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 16:00:04.888942  6725 json_parser.cpp:18] 
[
	137,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if (!initializeLayer(layer_id)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) {\n  auto iter = layers_.find(layer_id);\n  if (iter != layers_.end()) {\n    return iter.second;\n  } else {\n    return nullptr;\n  }\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(const std::string& type_name,\n                                                          float grid_size, float tile_size) {\n  int layer_id;\n  if(!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id);\n  return *(layers_[layer_id]);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 16:00:06.520112  6725 json_parser.cpp:18] 
[
	138,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if (!initializeLayer(layer_id)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) {\n  auto iter = layers_.find(layer_id);\n  if (iter != layers_.end()) {\n    return iter.second;\n  } else {\n    return nullptr;\n  }\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(const std::string& type_name,\n                                                          float grid_size, float tile_size) {\n  int layer_id;\n  if(!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)){\n  }\n  return *(layers_[layer_id]);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 16:00:06.586961  6725 json_parser.cpp:18] 
[
	139,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if (!initializeLayer(layer_id)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) {\n  auto iter = layers_.find(layer_id);\n  if (iter != layers_.end()) {\n    return iter.second;\n  } else {\n    return nullptr;\n  }\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(const std::string& type_name,\n                                                          float grid_size, float tile_size) {\n  int layer_id;\n  if(!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)){\n  }\n  return *(layers_[layer_id]);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 16:00:10.050078  6725 json_parser.cpp:18] 
[
	141,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if (!initializeLayer(layer_id)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) {\n  auto iter = layers_.find(layer_id);\n  if (iter != layers_.end()) {\n    return iter.second;\n  } else {\n    return nullptr;\n  }\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(const std::string& type_name,\n                                                          float grid_size, float tile_size) {\n  int layer_id;\n  if(!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)){\n    return nullptr;\n  }\n  return *(layers_[layer_id]);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 16:00:10.059936  6725 json_parser.cpp:18] 
[
	142,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if (!initializeLayer(layer_id)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) {\n  auto iter = layers_.find(layer_id);\n  if (iter != layers_.end()) {\n    return iter.second;\n  } else {\n    return nullptr;\n  }\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(const std::string& type_name,\n                                                          float grid_size, float tile_size) {\n  int layer_id;\n  if(!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)){\n    return nullptr;\n  }\n  return *(layers_[layer_id]);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 16:00:18.616111  6725 json_parser.cpp:18] 
[
	143,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if (!initializeLayer(layer_id)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) {\n  auto iter = layers_.find(layer_id);\n  if (iter != layers_.end()) {\n    return iter.second;\n  } else {\n    return nullptr;\n  }\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(const std::string& type_name,\n                                                          float grid_size, float tile_size) {\n  int layer_id;\n  if(!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)){\n    return nullptr;\n  }\n  return *(layers_[layer_id])\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 16:00:19.274085  6725 json_parser.cpp:18] 
[
	144,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if (!initializeLayer(layer_id)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) {\n  auto iter = layers_.find(layer_id);\n  if (iter != layers_.end()) {\n    return iter.second;\n  } else {\n    return nullptr;\n  }\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(const std::string& type_name,\n                                                          float grid_size, float tile_size) {\n  int layer_id;\n  if(!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)){\n    return nullptr;\n  }\n  return *(layers_[layer_id]\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 16:00:19.308885  6725 json_parser.cpp:18] 
[
	145,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if (!initializeLayer(layer_id)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) {\n  auto iter = layers_.find(layer_id);\n  if (iter != layers_.end()) {\n    return iter.second;\n  } else {\n    return nullptr;\n  }\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(const std::string& type_name,\n                                                          float grid_size, float tile_size) {\n  int layer_id;\n  if(!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)){\n    return nullptr;\n  }\n  return *(layers_[layer_id\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 16:00:19.354360  6725 json_parser.cpp:18] 
[
	146,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if (!initializeLayer(layer_id)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) {\n  auto iter = layers_.find(layer_id);\n  if (iter != layers_.end()) {\n    return iter.second;\n  } else {\n    return nullptr;\n  }\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(const std::string& type_name,\n                                                          float grid_size, float tile_size) {\n  int layer_id;\n  if(!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)){\n    return nullptr;\n  }\n  return *(layers_[layer_i\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 16:00:19.389721  6725 json_parser.cpp:18] 
[
	147,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if (!initializeLayer(layer_id)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) {\n  auto iter = layers_.find(layer_id);\n  if (iter != layers_.end()) {\n    return iter.second;\n  } else {\n    return nullptr;\n  }\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(const std::string& type_name,\n                                                          float grid_size, float tile_size) {\n  int layer_id;\n  if(!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)){\n    return nullptr;\n  }\n  return *(layers_[layer_\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 16:00:19.429847  6725 json_parser.cpp:18] 
[
	148,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if (!initializeLayer(layer_id)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) {\n  auto iter = layers_.find(layer_id);\n  if (iter != layers_.end()) {\n    return iter.second;\n  } else {\n    return nullptr;\n  }\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(const std::string& type_name,\n                                                          float grid_size, float tile_size) {\n  int layer_id;\n  if(!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)){\n    return nullptr;\n  }\n  return *(layers_[layer\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 16:00:19.469964  6725 json_parser.cpp:18] 
[
	149,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if (!initializeLayer(layer_id)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) {\n  auto iter = layers_.find(layer_id);\n  if (iter != layers_.end()) {\n    return iter.second;\n  } else {\n    return nullptr;\n  }\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(const std::string& type_name,\n                                                          float grid_size, float tile_size) {\n  int layer_id;\n  if(!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)){\n    return nullptr;\n  }\n  return *(layers_[laye\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 16:00:19.515082  6725 json_parser.cpp:18] 
[
	150,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if (!initializeLayer(layer_id)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) {\n  auto iter = layers_.find(layer_id);\n  if (iter != layers_.end()) {\n    return iter.second;\n  } else {\n    return nullptr;\n  }\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(const std::string& type_name,\n                                                          float grid_size, float tile_size) {\n  int layer_id;\n  if(!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)){\n    return nullptr;\n  }\n  return *(layers_[lay\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 16:00:19.554724  6725 json_parser.cpp:18] 
[
	151,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if (!initializeLayer(layer_id)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) {\n  auto iter = layers_.find(layer_id);\n  if (iter != layers_.end()) {\n    return iter.second;\n  } else {\n    return nullptr;\n  }\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(const std::string& type_name,\n                                                          float grid_size, float tile_size) {\n  int layer_id;\n  if(!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)){\n    return nullptr;\n  }\n  return *(layers_[la\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 16:00:19.595140  6725 json_parser.cpp:18] 
[
	152,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if (!initializeLayer(layer_id)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) {\n  auto iter = layers_.find(layer_id);\n  if (iter != layers_.end()) {\n    return iter.second;\n  } else {\n    return nullptr;\n  }\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(const std::string& type_name,\n                                                          float grid_size, float tile_size) {\n  int layer_id;\n  if(!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)){\n    return nullptr;\n  }\n  return *(layers_[l\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 16:00:19.632750  6725 json_parser.cpp:18] 
[
	153,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if (!initializeLayer(layer_id)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) {\n  auto iter = layers_.find(layer_id);\n  if (iter != layers_.end()) {\n    return iter.second;\n  } else {\n    return nullptr;\n  }\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(const std::string& type_name,\n                                                          float grid_size, float tile_size) {\n  int layer_id;\n  if(!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)){\n    return nullptr;\n  }\n  return *(layers_[\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 16:00:19.672147  6725 json_parser.cpp:18] 
[
	154,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if (!initializeLayer(layer_id)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) {\n  auto iter = layers_.find(layer_id);\n  if (iter != layers_.end()) {\n    return iter.second;\n  } else {\n    return nullptr;\n  }\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(const std::string& type_name,\n                                                          float grid_size, float tile_size) {\n  int layer_id;\n  if(!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)){\n    return nullptr;\n  }\n  return *(layers_\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 16:00:19.717283  6725 json_parser.cpp:18] 
[
	155,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if (!initializeLayer(layer_id)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) {\n  auto iter = layers_.find(layer_id);\n  if (iter != layers_.end()) {\n    return iter.second;\n  } else {\n    return nullptr;\n  }\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(const std::string& type_name,\n                                                          float grid_size, float tile_size) {\n  int layer_id;\n  if(!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)){\n    return nullptr;\n  }\n  return *(layers\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 16:00:19.758510  6725 json_parser.cpp:18] 
[
	156,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if (!initializeLayer(layer_id)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) {\n  auto iter = layers_.find(layer_id);\n  if (iter != layers_.end()) {\n    return iter.second;\n  } else {\n    return nullptr;\n  }\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(const std::string& type_name,\n                                                          float grid_size, float tile_size) {\n  int layer_id;\n  if(!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)){\n    return nullptr;\n  }\n  return *(layer\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 16:00:19.797596  6725 json_parser.cpp:18] 
[
	157,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if (!initializeLayer(layer_id)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) {\n  auto iter = layers_.find(layer_id);\n  if (iter != layers_.end()) {\n    return iter.second;\n  } else {\n    return nullptr;\n  }\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(const std::string& type_name,\n                                                          float grid_size, float tile_size) {\n  int layer_id;\n  if(!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)){\n    return nullptr;\n  }\n  return *(laye\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 16:00:19.837996  6725 json_parser.cpp:18] 
[
	158,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if (!initializeLayer(layer_id)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) {\n  auto iter = layers_.find(layer_id);\n  if (iter != layers_.end()) {\n    return iter.second;\n  } else {\n    return nullptr;\n  }\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(const std::string& type_name,\n                                                          float grid_size, float tile_size) {\n  int layer_id;\n  if(!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)){\n    return nullptr;\n  }\n  return *(lay\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 16:00:19.878232  6725 json_parser.cpp:18] 
[
	159,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if (!initializeLayer(layer_id)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) {\n  auto iter = layers_.find(layer_id);\n  if (iter != layers_.end()) {\n    return iter.second;\n  } else {\n    return nullptr;\n  }\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(const std::string& type_name,\n                                                          float grid_size, float tile_size) {\n  int layer_id;\n  if(!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)){\n    return nullptr;\n  }\n  return *(la\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 16:00:19.913697  6725 json_parser.cpp:18] 
[
	160,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if (!initializeLayer(layer_id)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) {\n  auto iter = layers_.find(layer_id);\n  if (iter != layers_.end()) {\n    return iter.second;\n  } else {\n    return nullptr;\n  }\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(const std::string& type_name,\n                                                          float grid_size, float tile_size) {\n  int layer_id;\n  if(!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)){\n    return nullptr;\n  }\n  return *(l\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 16:00:19.954159  6725 json_parser.cpp:18] 
[
	161,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if (!initializeLayer(layer_id)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) {\n  auto iter = layers_.find(layer_id);\n  if (iter != layers_.end()) {\n    return iter.second;\n  } else {\n    return nullptr;\n  }\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(const std::string& type_name,\n                                                          float grid_size, float tile_size) {\n  int layer_id;\n  if(!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)){\n    return nullptr;\n  }\n  return *(\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 16:00:19.999075  6725 json_parser.cpp:18] 
[
	162,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if (!initializeLayer(layer_id)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) {\n  auto iter = layers_.find(layer_id);\n  if (iter != layers_.end()) {\n    return iter.second;\n  } else {\n    return nullptr;\n  }\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(const std::string& type_name,\n                                                          float grid_size, float tile_size) {\n  int layer_id;\n  if(!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)){\n    return nullptr;\n  }\n  return *\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 16:00:20.268995  6725 json_parser.cpp:18] 
[
	163,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if (!initializeLayer(layer_id)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) {\n  auto iter = layers_.find(layer_id);\n  if (iter != layers_.end()) {\n    return iter.second;\n  } else {\n    return nullptr;\n  }\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(const std::string& type_name,\n                                                          float grid_size, float tile_size) {\n  int layer_id;\n  if(!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)){\n    return nullptr;\n  }\n  return \n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 16:00:20.528757  6725 json_parser.cpp:18] 
[
	164,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if (!initializeLayer(layer_id)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) {\n  auto iter = layers_.find(layer_id);\n  if (iter != layers_.end()) {\n    return iter.second;\n  } else {\n    return nullptr;\n  }\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(const std::string& type_name,\n                                                          float grid_size, float tile_size) {\n  int layer_id;\n  if(!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)){\n    return nullptr;\n  }\n  return \n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 16:00:25.352126  6725 json_parser.cpp:18] 
[
	165,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if (!initializeLayer(layer_id)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) {\n  auto iter = layers_.find(layer_id);\n  if (iter != layers_.end()) {\n    return iter.second;\n  } else {\n    return nullptr;\n  }\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(const std::string& type_name,\n                                                          float grid_size, float tile_size) {\n  int layer_id;\n  if(!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)){\n    return nullptr;\n  }\n  return getLayer()\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 16:00:25.600880  6725 json_parser.cpp:18] 
[
	166,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if (!initializeLayer(layer_id)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) {\n  auto iter = layers_.find(layer_id);\n  if (iter != layers_.end()) {\n    return iter.second;\n  } else {\n    return nullptr;\n  }\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(const std::string& type_name,\n                                                          float grid_size, float tile_size) {\n  int layer_id;\n  if(!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)){\n    return nullptr;\n  }\n  return getLayer()\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 16:00:27.928670  6725 json_parser.cpp:18] 
[
	167,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if (!initializeLayer(layer_id)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) {\n  auto iter = layers_.find(layer_id);\n  if (iter != layers_.end()) {\n    return iter.second;\n  } else {\n    return nullptr;\n  }\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(const std::string& type_name,\n                                                          float grid_size, float tile_size) {\n  int layer_id;\n  if(!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)){\n    return nullptr;\n  }\n  return getLayer(layer_id)\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 16:00:27.990629  6725 json_parser.cpp:18] 
[
	168,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if (!initializeLayer(layer_id)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) {\n  auto iter = layers_.find(layer_id);\n  if (iter != layers_.end()) {\n    return iter.second;\n  } else {\n    return nullptr;\n  }\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(const std::string& type_name,\n                                                          float grid_size, float tile_size) {\n  int layer_id;\n  if(!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)){\n    return nullptr;\n  }\n  return getLayer(layer_id)\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 16:00:28.296741  6725 json_parser.cpp:18] 
[
	169,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if (!initializeLayer(layer_id)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) {\n  auto iter = layers_.find(layer_id);\n  if (iter != layers_.end()) {\n    return iter.second;\n  } else {\n    return nullptr;\n  }\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(const std::string& type_name,\n                                                          float grid_size, float tile_size) {\n  int layer_id;\n  if(!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)){\n    return nullptr;\n  }\n  return getLayer(layer_id)\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 16:00:28.640746  6725 json_parser.cpp:18] 
[
	170,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if (!initializeLayer(layer_id)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) {\n  auto iter = layers_.find(layer_id);\n  if (iter != layers_.end()) {\n    return iter.second;\n  } else {\n    return nullptr;\n  }\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(const std::string& type_name,\n                                                          float grid_size, float tile_size) {\n  int layer_id;\n  if(!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)){\n    return nullptr;\n  }\n  return getLayer(layer_id);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 16:00:28.650668  6725 json_parser.cpp:18] 
[
	171,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if (!initializeLayer(layer_id)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) {\n  auto iter = layers_.find(layer_id);\n  if (iter != layers_.end()) {\n    return iter.second;\n  } else {\n    return nullptr;\n  }\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(const std::string& type_name,\n                                                          float grid_size, float tile_size) {\n  int layer_id;\n  if(!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)){\n    return nullptr;\n  }\n  return getLayer(layer_id);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 16:00:31.135972  6725 json_parser.cpp:18] 
[
	172,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if (!initializeLayer(layer_id)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) {\n  auto iter = layers_.find(layer_id);\n  if (iter != layers_.end()) {\n    return iter.second;\n  } else {\n    return nullptr;\n  }\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(const std::string& type_name,\n                                                          float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return nullptr;\n  }\n  return getLayer(layer_id);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 16:01:56.834295  6725 json_parser.cpp:18] 
[
	173,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if (!initializeLayer(layer_id)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) {\n  auto iter = layers_.find(layer_id);\n  if (iter != layers_.end()) {\n    return iter.second;\n  } else {\n    return nullptr;\n  }\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(const std::string& type_name,\n                                                          float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return nullptr;\n  }\n  return getLayer(layer_id);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 16:01:58.011922  6725 json_parser.cpp:18] 
[
	174,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if (!initializeLayer(layer_id)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) {\n  auto iter = layers_.find(layer_id);\n  if (iter != layers_.end()) {\n    return iter.second;\n  } else {\n    return nullptr;\n  }\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(const std::string& type_name,\n                                                          float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return nullptr;\n  }\n  return getLayer(layer_id);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 16:01:58.022101  6725 json_parser.cpp:18] 
[
	175,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if (!initializeLayer(layer_id)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) {\n  auto iter = layers_.find(layer_id);\n  if (iter != layers_.end()) {\n    return iter.second;\n  } else {\n    return nullptr;\n  }\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(const std::string& type_name,\n                                                          float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return nullptr;\n  }\n  return getLayer(layer_id);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 16:01:59.066417  6725 json_parser.cpp:18] 
[
	176,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/eigen_types.h\"\n\n#include \"common/proto/config/config_map.pb.h\"\n\n#include \"lidar_map.h\"\n#include \"local_database.h\"\n#include \"map_layer.h\"\n#include \"map_scope.h\"\n#include \"ndt3interface.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass LidarMapOffline : public LidarMap {\n public:\n  /// @brief configure the LidarMapOffline class, mainly static members\n  /// which shared by all LidarMapOffline instance, such as database\n  ///\n  /// @param mode[in] specify the database operation mode, read, write, create...\n  ///\n  /// @note this should be called first before any operation about\n  /// LidarMapOffline\n  static bool configure(LocalDatabase::MODE mode);\n\n  /// @brief get the cache range(in number of tiles)\n  static int getCacheRange() { return LidarMap::cache_range_; }\n\n  /// @brief get the watermark of tile cache\n  static int getCacheMargin() { return LidarMap::cache_margin_; }\n\n  /// @brief implimention of LidarMap::initializeLayer, see LidarMap for more infomation\n  bool initializeLayer(int layer_id) override;\n\n  /// @brief initialize a layer by specify type_name, grid_size and tile\n  /// @return the layer_id of the initilized layer, if failed, a negtive number will be returned\n  int initializeLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief implimention of LidarMap::addPointCloud, see LidarMap for more infomation\n  bool addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) override;\n\n  /// @brief load the map to cache\n  /// @param[in] pos the center of the region to be loaded\n  /// @return true on succeed, else false\n  bool load(const Eigen::Vector3f& pos);\n\n  /// @brief Get the map of a layer in specific region\n  ///\n  /// @param layer_id[in] specify which layer to get\n  /// @param[in] scope specifies the submap region.\n  /// @param[in] blocking if is true, this call will block if cache miss happens,\n  /// until tiles are loaded or timeout\n  /// @param[out] ndt3 stores the map we got\n  ///\n  /// @return true on succeed, else false. we may fails when there is a cache miss\n  /// in blocking mode\n  bool getMap(int layer_id, const MapScope& scope, bool blocking,\n              std::shared_ptr<Ndt3Interface>* ndt3);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @param layer_item[in] a layer item contains nessecery infomation\n  /// to add one layer\n  ///\n  /// @return true on succeed, else false\n  bool addLayer(const proto::config::MapLayerItem& layer_item);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @return the layer id of the layer we add\n  int addLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief save the map into database\n  ///\n  /// @return true on succeed, else false\n  bool save();\n\n  /// @brief get one maplayer\n  ///\n  /// @param layer_id[in] specify which layer to get\n  ///\n  /// @return maplayer got\n  std::shared_ptr<const MapLayer> getLayer(int layer_id);\n\n  /// @brief get one maplayer\n  ///\n  /// @param type_name[in] such as ndt3_corner...\n  ///\n  /// @return map layer got\n  std::shared_ptr<const MapLayer> getLayer(const std::string& type_name, float grid_size, float tile_size);\n\n private:\n  static std::shared_ptr<LocalDatabase> database_;\n  static LocalDatabase::MODE database_operation_mode_;\n  static proto::map::MapInfo map_info_;\n\n  std::map<int, std::shared_ptr<MapLayer>> layers_;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h"
		}
	}
]
I0402 16:01:59.132740  6725 json_parser.cpp:18] 
[
	177,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/eigen_types.h\"\n\n#include \"common/proto/config/config_map.pb.h\"\n\n#include \"lidar_map.h\"\n#include \"local_database.h\"\n#include \"map_layer.h\"\n#include \"map_scope.h\"\n#include \"ndt3interface.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass LidarMapOffline : public LidarMap {\n public:\n  /// @brief configure the LidarMapOffline class, mainly static members\n  /// which shared by all LidarMapOffline instance, such as database\n  ///\n  /// @param mode[in] specify the database operation mode, read, write, create...\n  ///\n  /// @note this should be called first before any operation about\n  /// LidarMapOffline\n  static bool configure(LocalDatabase::MODE mode);\n\n  /// @brief get the cache range(in number of tiles)\n  static int getCacheRange() { return LidarMap::cache_range_; }\n\n  /// @brief get the watermark of tile cache\n  static int getCacheMargin() { return LidarMap::cache_margin_; }\n\n  /// @brief implimention of LidarMap::initializeLayer, see LidarMap for more infomation\n  bool initializeLayer(int layer_id) override;\n\n  /// @brief initialize a layer by specify type_name, grid_size and tile\n  /// @return the layer_id of the initilized layer, if failed, a negtive number will be returned\n  int initializeLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief implimention of LidarMap::addPointCloud, see LidarMap for more infomation\n  bool addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) override;\n\n  /// @brief load the map to cache\n  /// @param[in] pos the center of the region to be loaded\n  /// @return true on succeed, else false\n  bool load(const Eigen::Vector3f& pos);\n\n  /// @brief Get the map of a layer in specific region\n  ///\n  /// @param layer_id[in] specify which layer to get\n  /// @param[in] scope specifies the submap region.\n  /// @param[in] blocking if is true, this call will block if cache miss happens,\n  /// until tiles are loaded or timeout\n  /// @param[out] ndt3 stores the map we got\n  ///\n  /// @return true on succeed, else false. we may fails when there is a cache miss\n  /// in blocking mode\n  bool getMap(int layer_id, const MapScope& scope, bool blocking,\n              std::shared_ptr<Ndt3Interface>* ndt3);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @param layer_item[in] a layer item contains nessecery infomation\n  /// to add one layer\n  ///\n  /// @return true on succeed, else false\n  bool addLayer(const proto::config::MapLayerItem& layer_item);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @return the layer id of the layer we add\n  int addLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief save the map into database\n  ///\n  /// @return true on succeed, else false\n  bool save();\n\n  /// @brief get one maplayer\n  ///\n  /// @param layer_id[in] specify which layer to get\n  ///\n  /// @return maplayer got\n  std::shared_ptr<const MapLayer> getLayer(int layer_id);\n\n  /// @brief get one maplayer\n  ///\n  /// @param type_name[in] such as ndt3_corner...\n  ///\n  /// @return map layer got\n  std::shared_ptr<const MapLayer> getLayer(const std::string& type_name, float grid_size, float tile_size);\n\n private:\n  static std::shared_ptr<LocalDatabase> database_;\n  static LocalDatabase::MODE database_operation_mode_;\n  static proto::map::MapInfo map_info_;\n\n  std::map<int, std::shared_ptr<MapLayer>> layers_;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h"
		}
	}
]
I0402 16:02:25.330780  6725 json_parser.cpp:18] 
[
	178,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if (!initializeLayer(layer_id)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) {\n  auto iter = layers_.find(layer_id);\n  if (iter != layers_.end()) {\n    return iter.second;\n  } else {\n    return nullptr;\n  }\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(const std::string& type_name,\n                                                          float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return nullptr;\n  }\n  return getLayer(layer_id);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 16:02:25.404592  6725 json_parser.cpp:18] 
[
	179,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if (!initializeLayer(layer_id)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) {\n  auto iter = layers_.find(layer_id);\n  if (iter != layers_.end()) {\n    return iter.second;\n  } else {\n    return nullptr;\n  }\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(const std::string& type_name,\n                                                          float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return nullptr;\n  }\n  return getLayer(layer_id);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 16:03:05.343001  6725 json_parser.cpp:18] 
[
	180,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if (!initializeLayer(layer_id)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) {\n  auto iter = layers_.find(layer_id);\n  if (iter != layers_.end()) {\n    return iter.;\n  } else {\n    return nullptr;\n  }\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(const std::string& type_name,\n                                                          float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return nullptr;\n  }\n  return getLayer(layer_id);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 16:03:05.884811  6725 json_parser.cpp:18] 
[
	181,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if (!initializeLayer(layer_id)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) {\n  auto iter = layers_.find(layer_id);\n  if (iter != layers_.end()) {\n    return iter;\n  } else {\n    return nullptr;\n  }\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(const std::string& type_name,\n                                                          float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return nullptr;\n  }\n  return getLayer(layer_id);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 16:03:06.064165  6725 json_parser.cpp:18] 
[
	182,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if (!initializeLayer(layer_id)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) {\n  auto iter = layers_.find(layer_id);\n  if (iter != layers_.end()) {\n    return iter;\n  } else {\n    return nullptr;\n  }\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(const std::string& type_name,\n                                                          float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return nullptr;\n  }\n  return getLayer(layer_id);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 16:03:08.856247  6725 json_parser.cpp:18] 
[
	183,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if (!initializeLayer(layer_id)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) {\n  auto iter = layers_.find(layer_id);\n  if (iter != layers_.end()) {\n    return iter. ;\n  } else {\n    return nullptr;\n  }\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(const std::string& type_name,\n                                                          float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return nullptr;\n  }\n  return getLayer(layer_id);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 16:03:11.048723  6725 json_parser.cpp:18] 
[
	184,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if (!initializeLayer(layer_id)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) {\n  auto iter = layers_.find(layer_id);\n  if (iter != layers_.end()) {\n    return iter;\n  } else {\n    return nullptr;\n  }\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(const std::string& type_name,\n                                                          float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return nullptr;\n  }\n  return getLayer(layer_id);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 16:03:11.624795  6725 json_parser.cpp:18] 
[
	185,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if (!initializeLayer(layer_id)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) {\n  auto iter = layers_.find(layer_id);\n  if (iter != layers_.end()) {\n    return iter;\n  } else {\n    return nullptr;\n  }\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(const std::string& type_name,\n                                                          float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return nullptr;\n  }\n  return getLayer(layer_id);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 16:03:18.305927  6725 json_parser.cpp:18] 
[
	186,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if (!initializeLayer(layer_id)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) {\n  auto iter = layers_.find(layer_id);\n  if (iter != layers_.end()) {\n    return iter;\n  } else {\n    return nullptr;\n  }\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(const std::string& type_name,\n                                                          float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return nullptr;\n  }\n  return getLayer(layer_id);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 16:03:18.314517  6725 json_parser.cpp:18] 
[
	187,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if (!initializeLayer(layer_id)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) {\n  auto iter = layers_.find(layer_id);\n  if (iter != layers_.end()) {\n    return iter;\n  } else {\n    return nullptr;\n  }\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(const std::string& type_name,\n                                                          float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return nullptr;\n  }\n  return getLayer(layer_id);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 16:03:36.067958  6725 json_parser.cpp:18] 
[
	188,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/eigen_types.h\"\n\n#include \"common/proto/config/config_map.pb.h\"\n\n#include \"lidar_map.h\"\n#include \"local_database.h\"\n#include \"map_layer.h\"\n#include \"map_scope.h\"\n#include \"ndt3interface.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass LidarMapOffline : public LidarMap {\n public:\n  /// @brief configure the LidarMapOffline class, mainly static members\n  /// which shared by all LidarMapOffline instance, such as database\n  ///\n  /// @param mode[in] specify the database operation mode, read, write, create...\n  ///\n  /// @note this should be called first before any operation about\n  /// LidarMapOffline\n  static bool configure(LocalDatabase::MODE mode);\n\n  /// @brief get the cache range(in number of tiles)\n  static int getCacheRange() { return LidarMap::cache_range_; }\n\n  /// @brief get the watermark of tile cache\n  static int getCacheMargin() { return LidarMap::cache_margin_; }\n\n  /// @brief implimention of LidarMap::initializeLayer, see LidarMap for more infomation\n  bool initializeLayer(int layer_id) override;\n\n  /// @brief initialize a layer by specify type_name, grid_size and tile\n  /// @return the layer_id of the initilized layer, if failed, a negtive number will be returned\n  int initializeLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief implimention of LidarMap::addPointCloud, see LidarMap for more infomation\n  bool addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) override;\n\n  /// @brief load the map to cache\n  /// @param[in] pos the center of the region to be loaded\n  /// @return true on succeed, else false\n  bool load(const Eigen::Vector3f& pos);\n\n  /// @brief Get the map of a layer in specific region\n  ///\n  /// @param layer_id[in] specify which layer to get\n  /// @param[in] scope specifies the submap region.\n  /// @param[in] blocking if is true, this call will block if cache miss happens,\n  /// until tiles are loaded or timeout\n  /// @param[out] ndt3 stores the map we got\n  ///\n  /// @return true on succeed, else false. we may fails when there is a cache miss\n  /// in blocking mode\n  bool getMap(int layer_id, const MapScope& scope, bool blocking,\n              std::shared_ptr<Ndt3Interface>* ndt3);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @param layer_item[in] a layer item contains nessecery infomation\n  /// to add one layer\n  ///\n  /// @return true on succeed, else false\n  bool addLayer(const proto::config::MapLayerItem& layer_item);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @return the layer id of the layer we add\n  int addLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief save the map into database\n  ///\n  /// @return true on succeed, else false\n  bool save();\n\n  /// @brief get one maplayer\n  ///\n  /// @param layer_id[in] specify which layer to get\n  ///\n  /// @return maplayer got\n  std::shared_ptr<const MapLayer> getLayer(int layer_id);\n\n  /// @brief get one maplayer\n  ///\n  /// @param type_name[in] such as ndt3_corner...\n  ///\n  /// @return map layer got\n  std::shared_ptr<const MapLayer> getLayer(const std::string& type_name, float grid_size, float tile_size);\n\n private:\n  static std::shared_ptr<LocalDatabase> database_;\n  static LocalDatabase::MODE database_operation_mode_;\n  static proto::map::MapInfo map_info_;\n\n  std::map<int, std::shared_ptr<MapLayer>> layers_;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h"
		}
	}
]
I0402 16:03:36.081877  6725 json_parser.cpp:18] 
[
	189,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n#pragma once\n\n#include \"common/math/eigen_types.h\"\n\n#include \"common/proto/config/config_map.pb.h\"\n\n#include \"lidar_map.h\"\n#include \"local_database.h\"\n#include \"map_layer.h\"\n#include \"map_scope.h\"\n#include \"ndt3interface.h\"\n\nnamespace allride {\nnamespace mapping {\n\nclass LidarMapOffline : public LidarMap {\n public:\n  /// @brief configure the LidarMapOffline class, mainly static members\n  /// which shared by all LidarMapOffline instance, such as database\n  ///\n  /// @param mode[in] specify the database operation mode, read, write, create...\n  ///\n  /// @note this should be called first before any operation about\n  /// LidarMapOffline\n  static bool configure(LocalDatabase::MODE mode);\n\n  /// @brief get the cache range(in number of tiles)\n  static int getCacheRange() { return LidarMap::cache_range_; }\n\n  /// @brief get the watermark of tile cache\n  static int getCacheMargin() { return LidarMap::cache_margin_; }\n\n  /// @brief implimention of LidarMap::initializeLayer, see LidarMap for more infomation\n  bool initializeLayer(int layer_id) override;\n\n  /// @brief initialize a layer by specify type_name, grid_size and tile\n  /// @return the layer_id of the initilized layer, if failed, a negtive number will be returned\n  int initializeLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief implimention of LidarMap::addPointCloud, see LidarMap for more infomation\n  bool addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) override;\n\n  /// @brief load the map to cache\n  /// @param[in] pos the center of the region to be loaded\n  /// @return true on succeed, else false\n  bool load(const Eigen::Vector3f& pos);\n\n  /// @brief Get the map of a layer in specific region\n  ///\n  /// @param layer_id[in] specify which layer to get\n  /// @param[in] scope specifies the submap region.\n  /// @param[in] blocking if is true, this call will block if cache miss happens,\n  /// until tiles are loaded or timeout\n  /// @param[out] ndt3 stores the map we got\n  ///\n  /// @return true on succeed, else false. we may fails when there is a cache miss\n  /// in blocking mode\n  bool getMap(int layer_id, const MapScope& scope, bool blocking,\n              std::shared_ptr<Ndt3Interface>* ndt3);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @param layer_item[in] a layer item contains nessecery infomation\n  /// to add one layer\n  ///\n  /// @return true on succeed, else false\n  bool addLayer(const proto::config::MapLayerItem& layer_item);\n\n  /// @brief add a layer (when building map)\n  ///\n  /// @return the layer id of the layer we add\n  int addLayer(const std::string& type_name, float grid_size, float tile_size);\n\n  /// @brief save the map into database\n  ///\n  /// @return true on succeed, else false\n  bool save();\n\n  /// @brief get one maplayer\n  ///\n  /// @param layer_id[in] specify which layer to get\n  ///\n  /// @return maplayer got\n  std::shared_ptr<const MapLayer> getLayer(int layer_id);\n\n  /// @brief get one maplayer\n  ///\n  /// @param type_name[in] such as ndt3_corner...\n  ///\n  /// @return map layer got\n  std::shared_ptr<const MapLayer> getLayer(const std::string& type_name, float grid_size, float tile_size);\n\n private:\n  static std::shared_ptr<LocalDatabase> database_;\n  static LocalDatabase::MODE database_operation_mode_;\n  static proto::map::MapInfo map_info_;\n\n  std::map<int, std::shared_ptr<MapLayer>> layers_;\n};\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.h"
		}
	}
]
I0402 16:03:45.598901  6725 json_parser.cpp:18] 
[
	190,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if (!initializeLayer(layer_id)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) {\n  auto iter = layers_.find(layer_id);\n  if (iter != layers_.end()) {\n    return iter;\n  } else {\n    return nullptr;\n  }\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(const std::string& type_name,\n                                                          float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return nullptr;\n  }\n  return getLayer(layer_id);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 16:03:45.670938  6725 json_parser.cpp:18] 
[
	191,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if (!initializeLayer(layer_id)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) {\n  auto iter = layers_.find(layer_id);\n  if (iter != layers_.end()) {\n    return iter;\n  } else {\n    return nullptr;\n  }\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(const std::string& type_name,\n                                                          float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return nullptr;\n  }\n  return getLayer(layer_id);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 16:04:54.792616  6725 json_parser.cpp:18] 
[
	192,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if (!initializeLayer(layer_id)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) {\n  auto iter = layers_.find(layer_id);\n  if (iter != layers_.end()) {\n    return iter;\n  } else {\n    return nullptr;\n  }\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(const std::string& type_name,\n                                                          float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return nullptr;\n  }\n  return getLayer(layer_id);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 16:04:57.539268  6725 json_parser.cpp:18] 
[
	193,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if (!initializeLayer(layer_id)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  int layer_id = layer_item.layer_id();\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-add\n  }\n\n  // construct a layer_info\n  proto::map::MapLayerInfo layer_info;\n  layer_info.set_layer_id(layer_item.layer_id());\n  layer_info.set_grid_size(layer_item.grid_size());\n  layer_info.set_tile_size(layer_item.tile_size());\n  layer_info.set_type_name(layer_item.type_name());\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(layer_info, database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::addLayer(const std::string& type_name, float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  proto::config::MapLayerItem item;\n  item.set_layer_id(layer_id);\n  item.set_type_name(type_name);\n  item.set_grid_size(grid_size);\n  item.set_tile_size(tile_size);\n\n  if (!addLayer(item)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::save() {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->save();\n  }\n\n  return ret;\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(int layer_id) {\n  auto iter = layers_.find(layer_id);\n  if (iter != layers_.end()) {\n    return iter->second;\n  } else {\n    return nullptr;\n  }\n}\n\nstd::shared_ptr<const MapLayer> LidarMapOffline::getLayer(const std::string& type_name,\n                                                          float grid_size, float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return nullptr;\n  }\n  return getLayer(layer_id);\n}\n\n}  // namespace mapping\n}  // namespace allride\n",
			"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp"
		}
	}
]
I0402 16:04:57.546507  6725 json_parser.cpp:18] 
[
	194,
	{
		"filename" : "/home/mr/Workspace/loc/src/v2/mapping/map/lidar_map_offline.cpp",
		"flags" : 
		[
			"-x",
			"c++",
			"-std=c++14",
			"-DvtkRenderingVolume_AUTOINIT=\"1(vtkRenderingVolumeOpenGL)\"",
			"-DvtkIOSQL_AUTOINIT=\"2(vtkIOMySQL,vtkIOPostgreSQL)\"",
			"-DROS_PACKAGE_NAME=\\\"v2_mapping\\\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtWidgets",
			"-DvtkRenderingLIC_AUTOINIT=\"1(vtkRenderingParallelLIC)\"",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5",
			"-Dv2_mapping_EXPORTS",
			"-DvtkRenderingContext2D_AUTOINIT=\"1(vtkRenderingContextOpenGL)\"",
			"-I/home/mr/Workspace/loc/src/v2/mapping/map",
			"-I/usr/lib/openmpi/include",
			"-I/usr/local/include",
			"-I/home/mr/Workspace/loc/src/v2/mapping/src",
			"-DQT_GUI_LIB",
			"-I/usr/include/tcl",
			"-Dinertial_nav_EXPORTS",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-I/usr/include/x86_64-linux-gnu/freetype2",
			"-DvtkIOGeometry_AUTOINIT=\"1(vtkIOMPIParallel)\"",
			"-DvtkRenderingFreeType_AUTOINIT=\"2(vtkRenderingFreeTypeFontConfig,vtkRenderingMatplotlib)\"",
			"-DvtkRenderingCore_AUTOINIT=\"4(vtkInteractionStyle,vtkRenderingFreeType,vtkRenderingFreeTypeOpenGL,vtkRenderingOpenGL)\"",
			"-Dsensor_fusion_EXPORTS",
			"-I/usr/include/python2.7",
			"-I/usr/include/vtk-6.2",
			"-DQT_WIDGETS_LIB",
			"-I/usr/include/pcl-1.7",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent/include",
			"-I/usr/include/freetype2",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-DvtkFiltersFlowPaths_AUTOINIT=\"1(vtkFiltersParallelFlowPaths)\"",
			"-I/usr/lib/openmpi/include/openmpi/opal/mca/event/libevent2021/libevent",
			"-I/usr/include/jsoncpp",
			"-I/usr/include/ni",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtGui",
			"-DvtkIOImage_AUTOINIT=\"1(vtkIOMPIImage)\"",
			"-I/home/mr/Workspace/loc/src/v2",
			"-I/opt/ros/kinetic/include/opencv-3.3.1-dev/opencv",
			"-I/usr/lib/openmpi/include/openmpi",
			"-DQT_CORE_LIB",
			"-I/usr/include/openni2",
			"-I/home/mr/Workspace/loc/src/v2/build/common/proto",
			"-I/usr/include/hdf5/openmpi",
			"-DvtkIOExodus_AUTOINIT=\"1(vtkIOParallelExodus)\"",
			"-DQT_NO_DEBUG",
			"-Dcommon_io_EXPORTS",
			"-I/opt/ros/kinetic/include/xmlrpcpp",
			"-DROS_PACKAGE_NAME=\\\"common\\\"",
			"-Dcommon_proto_EXPORTS",
			"-isystem",
			"/usr/lib/x86_64-linux-gnu/qt5/mkspecs/linux-g++-64",
			"-I/usr/include/eigen3",
			"-I/usr/include/libxml2",
			"-I/opt/ros/kinetic/include",
			"-isystem",
			"/opt/ros/kinetic/include/opencv-3.3.1-dev",
			"-DDISABLE_PNG",
			"-DDISABLE_PCAP",
			"-isystem",
			"/usr/include/x86_64-linux-gnu/qt5/QtCore",
			"-DROS_PACKAGE_NAME=\\\"localization\\\"",
			"-Dcommon_geometry_EXPORTS",
			"-I/usr/include/x86_64-linux-gnu",
			"-I/home/mr/Workspace/loc/src/v2/third_party/thread_pool",
			"-DROSCONSOLE_BACKEND_LOG4CXX",
			"-I/usr/include/c++/5",
			"-I/usr/include",
			"-resource-dir=/home/mr/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/clang/lib/clang/7.0.0",
			"-fspell-checking"
		],
		"unsaved" : 
		{
			"content" : "// Copyright 2019 Allride.ai. All Rights Reserved.\n// Author: Rui Min (rui.min@allride.ai).\n\n#include \"lidar_map_offline.h\"\n#include \"lmdb_database.h\"\n\nnamespace allride {\nnamespace mapping {\n\nstd::shared_ptr<LocalDatabase> LidarMapOffline::database_ = nullptr;\nLocalDatabase::MODE LidarMapOffline::database_operation_mode_;\nproto::map::MapInfo LidarMapOffline::map_info_;\n\nbool LidarMapOffline::configure(LocalDatabase::MODE mode) {\n  database_ = std::shared_ptr<LmdbDatabase>(new LmdbDatabase);\n  database_operation_mode_ = mode;\n\n  if (!database_->open(database_path_, database_operation_mode_)) {\n    return false;\n  }\n\n  std::string map_info_data;\n  if (database_->get(\"MapInfo\", &map_info_data)) {\n    return false;\n  }\n\n  if (!map_info_.ParseFromString(map_info_data)) {\n    return false;\n  }\n\n  return true;\n}\n\nbool LidarMapOffline::initializeLayer(int layer_id) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it != layers_.end()) {\n    return false;  // re-initialize\n  }\n\n  // find the layer infomation in database\n  int layer_info_index = -1;\n  for (int i = 0; i < map_info_.layer_infos_size(); ++i) {\n    if (layer_id == map_info_.layer_infos(i).layer_id()) {\n      layer_info_index = i;\n      break;\n    }\n  }\n  if (-1 == layer_info_index) {\n    return false;  // the specific layer_id do not exist in database\n  }\n\n  auto new_layer = std::shared_ptr<MapLayer>(new MapLayer);\n  if (!new_layer->initialize(map_info_.layer_infos(layer_info_index), database_)) {\n    return false;\n  }\n\n  layers_[layer_id] = new_layer;\n\n  return false;\n}\n\nint LidarMapOffline::initializeLayer(const std::string& type_name, float grid_size,\n                                     float tile_size) {\n  int layer_id;\n  if (!map_layer_dict_.getIdByInfo(type_name, grid_size, tile_size, &layer_id)) {\n    return -1;\n  }\n\n  if (!initializeLayer(layer_id)) {\n    return -1;\n  }\n\n  return layer_id;\n}\n\nbool LidarMapOffline::load(const Eigen::Vector3f& pos) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  bool ret = true;\n  for (auto& pair : layers_) {\n    ret &= pair.second->load(pos);\n  }\n\n  return ret;\n}\n\nbool LidarMapOffline::addPointCloud(int layer_id, const common::PointCloudXYZI& pointcloud) {\n  // initializeLayer is only used in write and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->addPointCloud(pointcloud);\n\n  return false;\n}\n\nbool LidarMapOffline::getMap(int layer_id, const MapScope& scope, bool blocking,\n                             std::shared_ptr<Ndt3Interface>* ndt3) {\n  // initializeLayer is only used in read mode\n  if (database_operation_mode_ != LocalDatabase::READ) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == database_) {\n    return false;\n  }\n\n  auto it = layers_.find(layer_id);\n  if (it == layers_.end()) {\n    return false;  // layer not exist\n  }\n\n  it->second->getMap(scope, blocking, ndt3);\n\n  return false;\n}\n\nbool LidarMapOffline::addLayer(const proto::config::MapLayerItem& layer_item) {\n  // initializeLayer is only used in wrtie and create mode\n  if (database_operation_mode_ != LocalDatabase::WRITE &&\n      database_operation_mode_ != LocalDatabase::NEW) {\n    return false;\n  }\n\n  // database not set\n  if (nullptr == databa